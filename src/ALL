{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edited by Hannes de Jager 1996 & 1997                                  *}
{* Installation Program                                                     *}
{****************************************************************************}

{$F-,I-,O-,Q-,R-,S-}

program TestMaker_Install;
  uses sProcs, Objects, Dos, Crt;

{***þ Program Errors þ***}
const
  ErrDirCreate    = 1;
  ErrDiskSpace    = 2;
  ErrIncorrectDos = 3;
  ErrInvalidDrive = 4;
  ErrSourceOpen   = 5;
  ErrSourceRead   = 6;
  ErrSourceTarget = 7;
  ErrTargetOpen   = 8;
  ErrTargetWrite  = 9;

{***þ File Transfer Info Record þ***}
type
  PFileObject = ^TFileObject;
  TFileObject = Object(TObject)
    Essential :Boolean;
    Name      :String[12];
    Size      :LongInt;
  end;

{***þ File Copier Machine þ***}
  TFileCopy = Object(TObject)
    ErrCode   :Integer;
    SourceDir :PString;
    TargetDir :PString;
    FileList  :PCollection;
    Bytes     :LongInt;
    constructor Init(SDir, TDir :String; FileLst :PCollection);
    destructor  Done; virtual;
    function    CalcSize :LongInt;
    procedure   CopyAll;
    procedure   CopyFile(FileObj :PFileObject);
    function    EnoughDisk :Boolean;
    procedure   Error(Code :Integer);
    function    Overwrite(FileObj :PFileObject) :Boolean;
    procedure   ToTargetDir;
  end;

{***þ A type holding the characters used for drawing a text frame þ***}
type
  TFrame = array[1..8] of Char;

{***þ Two Frames þ***}
const
  SingleFrame: TFrame = 'ÚÄ¿³³ÀÄÙ';
  DoubleFrame: TFrame = 'ÉÍ»ººÈÍ¼';


{ Writes an amount of characters at a specific coordinate to the screen
  in a spesific color. }
procedure WriteChar(X, Y :Byte; Count :Word; Ch :Char; Attr :Byte);
  var I :Word;
begin
  GotoXY(X, Y);
  TextAttr := Attr;
  for I := 1 to Count do Write(Ch);
end;

{ Writes a string at a specific coordinate to the screen in a spesific color.}
procedure WriteStr(X, Y :Byte; S :String; Attr :Byte);
begin
  GotoXY(X, Y);
  TextAttr := Attr;
  Write(S);
end;

{ Creates a framed text window on the screen. }
procedure FrameWin(X1, Y1, X2, Y2 :Byte; Title: String;
                   TitleAttr, FrameAttr, FillAttr: Byte; Frame :TFrame);
var
  W, H, Y: Word;
begin
  Window(X1, Y1, X2+1, Y2);
  TextAttr := FillAttr;
  ClrScr;
  W := X2 - X1 + 1;
  H := Y2 - Y1 + 1;
  WriteChar(1, 1, 1, Frame[1], FrameAttr);
  WriteChar(2, 1, W - 2, Frame[2], FrameAttr);
  WriteChar(W, 1, 1, Frame[3], FrameAttr);
  if Length(Title) > W - 2 then Title[0] := Chr(W - 2);
  WriteStr((W - Length(Title)) shr 1 + 1, 1, Title, TitleAttr);
  for Y := 2 to H - 1 do
  begin
    WriteChar(1, Y, 1, Frame[4], FrameAttr);
    WriteChar(W, Y, 1, Frame[5], FrameAttr);
  end;
  WriteChar(1, H, 1, Frame[6], FrameAttr);
  WriteChar(2, H, W - 2, Frame[7], FrameAttr);
  WriteChar(W, H, 1, Frame[8], FrameAttr);
  Inc(WindMin, $0101);
  Dec(WindMax, $0102);
  GotoXY(1, 1);
end; { FrameWin }

{ Adds a backslash '\' to the givven path }
function AddSlash(S :String) :String;
begin
  if S[Length(S)] <> '\' then AddSlash := S+'\' else AddSlash := S;
end;

{ Removes the last backslash '\' from the givven path }
function StripSlash(S :String) :String;
begin
  if S[Length(S)] = '\' then Dec(S[0]);
  if (S[Length(S)] = ':') or (S = '') then S := S+'\';
  StripSlash := S;
end;

{ Displays a String on the bottomline of the screen }
procedure StatusStr(S :String; Attr :Word);
begin
  TextAttr := Attr;
  Window(1, 1, 80, 25);
  GotoXY(1, 25);
  ClrEol;
  Write(' '+S);
end; { StatusStr }

{ Initializes the object and creates the target directory if nessercary. }
constructor TFileCopy.Init(SDir, TDir :String; FileLst :PCollection);

   { Called to confirm a directory creation }
   function DirCreate :Boolean;
   begin
     if ErrCode <> 0 then Exit;
     StatusStr('Die gids kon nie gevind word nie. '+
               'Skep ''n nuwe gids ? [J/N] ', $6F);
     DirCreate := Upcase(Readkey) = 'J';
   end; { sub procedure DirCreate }

   { Called when the target directory needs to be created }
   procedure CreateTargetDir;
   begin
     if ErrCode <> 0 then Exit;
     StatusStr('Besig om gids te skep : ...', $2F);
     {$I-}
     MkDir(TargetDir^);
     if IOResult <> 0 then Error(ErrDirCreate);
     {$I+}
     StatusStr('', $77);
   end; { sub procedure CreateTargetDir }

   { Tells if Dos 3.0 or higher is present }
   function DosSatisfy :Boolean;
   begin
     DosSatisfy := Hi(DosVersion) >= 3;
   end;

begin { Init }
  inherited Init;
  { Check for Dos version }
  if not DosSatisfy then
  begin
    Error(errIncorrectDos);
    Done;
    Fail;
  end;
  { Add drive name at front of Target directory }
  if TDir = '' then TDir := GetCurPath;
  if TDir[2] <> ':' then
    if TDir[1] <> '\' then TDir := GetCurrentDrive+':\'+TDir
    else TDir := GetCurrentDrive+':'+TDir;
  SourceDir := NewStr(SUpper(StripSlash(SDir)));
  TargetDir := NewStr(SUpper(StripSlash(TDir)));
  { Screen Display }
  FrameWin(3, 9, 77, 12, ' Gidse ', $1E, $1E, $1F, SingleFrame);
  WriteStr(2, 1, 'Oorsprong Gids : '+SourceDir^, $1F);
  WriteStr(2, 2, 'TeikenGids     : '+TargetDir^, $1F);
  { Check for valid Target drive }
  if not PhysDriveValid(TargetDir^[1]) then
  begin
    Error(ErrInvalidDrive);
    Done;
    Fail;
  end; {if}
  { Check for source and destination overlap }
  if SourceDir^ = TargetDir^ then
  begin
    Error(ErrSourceTarget);
    Done;
    Fail;
  end; {if}
  FileList  := FileLst;
  if not DirExists(TargetDir^) then
    if DirCreate then CreateTargetDir
    else
    begin
      Done;
      Fail;
    end;{else}
  if ErrCode <> 0 then Exit;
  { Check for enough Free Disk space }
  if not EnoughDisk then
  begin
    Error(ErrDiskSpace);
    Fail;
  end;
end; { TFileCopy.Init }

{ Disposes of the object and changes to the target directory. }
destructor TFileCopy.Done;
begin
  ToTargetDir;
  if FileList <> nil then Dispose(FileList, Done);
  DisposeStr(SourceDir);
  DisposeStr(TargetDir);
  Inherited Done;
end; { TFileCopy.Done }

{ Calculates the sum of all the filesizes }
function TFileCopy.CalcSize :LongInt;
  var Size :LongInt;
    procedure IncSize(Item: PFileObject); far;
    begin
      Inc(Size, Item^.Size);
    end; { sub procedure IncSize }
begin
  Size := 0;
  FileList^.ForEach(@IncSize);
  CalcSize := Size;
end; { TFileCopy.CalcSize }

{ Copies all the files in FileList from source to destination }
procedure TFileCopy.CopyAll;
    procedure CopyItem(Item: PFileObject); far;
    begin
      CopyFile(Item);
    end; { sub procedure CopyItem }
begin
  FrameWin(3, 16, 77, 21, ' Kopie‰rings proses ', $1A, $1A, $1F, SingleFrame);
  FileList^.ForEach(@CopyItem);
end; { TFileCopy.CopyAll }

{ Copies the file at index of the list to the distination directory. }
procedure TFileCopy.CopyFile(FileObj :PFileObject);
  const MaxBufSize = $F000;
  var SF, TF  :file;
      SN, TN  :String;
      Buffer  :Pointer;
      DidXFer :LongInt;
      ToXFer  :LongInt;
begin
  Window(4, 17, 76, 20);
  TextAttr := $1F;
  if ErrCode <> 0 then Exit;
  if FileObj = nil then exit;
  with FileObj^ do
  begin
    SN := AddSlash(SourceDir^)+Name;
    TN := AddSlash(TargetDir^)+Name;
    { Update Display }
    Writeln('  Oorsprong Gids : '+AddSlash(SourceDir^));
    Writeln('  Teiken Gids    : '+AddSlash(TargetDir^));
    Writeln('  Lˆernaam       : ', Name);
    Write('  Grepe          : ', Bytes, ' van ', CalcSize);
    {$I-}
    Assign(SF, SN);
    Assign(TF, TN);
    {Open Files}
    Reset(SF, 1);
    if IOResult <> 0 then
    begin
      Error(ErrSourceOpen);
      ErrCode := 0;
      Exit;
    end; {if}
    if FileExists(TN) then
      if not Overwrite(FileObj) then
      begin
        Close(SF);
        ErrCode := 0;
        Exit;
      end; {if}
    Rewrite(TF, 1);
    if IOResult <> 0 then
    begin
      Error(ErrTargetOpen);
      Close(SF);
      ErrCode := 0;
      Exit;
    end; {if}
    { Transfer }
    DidXFer := 0;
    Repeat
      ToXFer := Size - DidXFer;
      if ToXFer > MaxBufSize then ToXFer := MaxBufSize;
      GetMem(Buffer, ToXFer);
      BlockRead(SF, Buffer^, ToXFer);
      If IOResult <> 0 then
      begin
        Error(ErrSourceRead);
        ErrCode := 0;
        Exit;
      end; {if}
      BlockWrite(TF, Buffer^, ToXFer);
      If IOResult <> 0 then
      begin
        Error(errTargetWrite);
        ErrCode := 0;
        Exit;
      end; {if}
      Inc(DidXFer, ToXFer);
      FreeMem(Buffer, ToXFer);
    Until DidXFer = Size;
    { Close Files }
    Close(SF);
    Close(TF);
    {$I+}
    Inc(Bytes, Size);
  end; {with}
end; { TFileCopy.CopyFile }


{ Tells if enough disk space is available to install the program }
function TFileCopy.EnoughDisk :Boolean;
begin
  EnoughDisk := CalcSize < DiskFree(Ord(TargetDir^[1])-64);
end; { TFileCopy.EnoughDisk }

{ Called whenever an error occurs. It displays an error on the BottomLine
  and sets ErrCode to Code }
procedure TFileCopy.Error(Code :Integer);
  var S :String;
begin
  ErrCode := Code;
  S := 'Fout : ';
  case Code of
    errDirCreate    :S := S+'Kon nie Gids skep nie. Geen installasie';
    errDiskSpace    :S := S+'Nie voldoende stoorspasie ! Geen installasie';
    errIncorrectDos :S := S+'DOS 3.0 of ho‰r is nodig om Testmaker te gebruik';
    errInvalidDrive :S := S+'Ongeldige aandrywer gespesifiseer';
    errSourceOpen   :S := S+'Kon nie bronlˆer open nie';
    errSourceRead   :S := S+'Kon nie van bronlˆer lees nie';
    errSourceTarget :S := S+'Bron en teiken gids kan nie dieselfde wees nie';
    errTargetOpen   :S := S+'Kon nie teikenlˆer skep nie';
    errTargetWrite  :S := S+'Kon nie na teikenlˆer skryf nie';
  end;
  StatusStr(S, $4F);
  ReadKey;
  StatusStr('', $77);
end; { TFileCopy.Error }

{ Called to confirm a file overwrite when a spesified target file
  already exists. }
function TFileCopy.Overwrite(FileObj :PFileObject) :Boolean;
begin
  StatusStr('Die teikenlˆer bestaan reeds. Herskryf ? [J/N] ', $4F);
  Overwrite := Upcase(Readkey) = 'J';
  StatusStr('', $77);
end;

{ Called to change the path to the target directory }
procedure TFileCopy.ToTargetDir;
  var I :Integer;
begin
  if ErrCode <> 0 then Exit;
  {$I-}
  ChDir(TargetDir^);
  {$I+}
  I := IOResult;
end; { TFileCopy.ToTargetDir }


{*********************}
{  Routines           }
{*********************}

{ Gets the target directory from the user }
function GetTargetDir :String;
  var S :String;
begin
  WriteStr(2, 2, 'Teiken Gids    : ', $1F);
  Readln(S);
  GetTargetDir := S;
end;

{ Sets up a collection list of all the files needed to be transferred. }
function SetUpList :PCollection;
  { List of Testmaker Files }
  const FileList :Array[1..6] of TFileObject = (
    (Essential :False; Name :'DEMO.TMS'),
    (Essential :False; Name :'TESTMAKE.CNF'),
    (Essential :True;  Name :'TESTMAKE.EXE'),
    (Essential :False; Name :'TESTMAKE.HLP'),
    (Essential :True;  Name :'TESTMAKE.OVR'),
    (Essential :False; Name :'TESTMAKE.RES'));

  var List :PCollection;
      Item :PFileObject;
      I :Byte;
      F :File;
      FileName :String;
begin
  New(List, Init(6, 0));
  for I := 1 to 6 do
  begin
    FileName := GetExeDir+FileList[I].Name; { Startup Dir + Name }
    if FileExists(FileName) then
    begin
      {$I-}
      Assign(F, FileName);
      Reset(F, 1);
      FileList[I].Size := FileSize(F);
      Close(F);
      {$I+}
      If IOResult <> 0 then
      begin
        StatusStr('Fout met lees van lˆer : '+FileList[I].Name, $4F);
        if FileList[I].Essential then Exit;
      end {if}
      else
      begin { Add to List }
        New(Item, Init);
        Item^ := FileList[I];
        List^.Insert(Item);
      end;{else}
    end {if fileExists}
    else
    begin
      StatusStr('Fout, lˆer kon nie gevind word nie : '+FileList[I].Name, $4F);
      if FileList[I].Essential then Exit;
    end; {else}
  end; {for}
  SetUpList := List;
end; { SetupList }




var
  Copier :TFileCopy;


begin { Program Install }
  { Initial Display }
  WriteChar(1, 1, 80*25, '°', $70);
  FrameWin(3, 1, 77, 5, '', $00, $1E, $1F, DoubleFrame);
  WriteStr(17, 2, 'T E S T M A K E R    I N S T A L E R I N G', $1F);
  FrameWin(3, 9, 77, 12, ' Gidse ', $1A, $1A, $1F, SingleFrame);
  WriteStr(2, 1, 'Oorsprong Gids : '+SUpper(GetExeDir), $1F);
  { Copy files }
  if Copier.Init(GetExeDir, GetTargetDir, SetupList) then
  begin
    Copier.CopyAll;
    Copier.Done;
    StatusStr('Druk enige sleutel. ', $74);
    Readkey;
  end;
  { Clear Screen for Exit }
  Window(1, 1, 80, 25);
  TextAttr := $07;
  Clrscr;
end. { Program }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{****************************************************************************}
Program TestMaker;
  Uses TMOvrlay, Main;

{$O Main     }   { Unit files to overlay }
{$O TMData   }
{$O Selector }
{$O EditMode }
{$O PRNMode  }



{***þ Program Object variable þ***}
var TM :TProgram;

begin
  TM.Init; { Initialize the Programs }
  TM.Run;  { Run the Program }
  TM.Done; { Cleanup Operations }
end.{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* Commands and other constants                                             *}
{****************************************************************************}
Unit Consts;

Interface

{***þ Notification Messages þ***}
const
  msgItemSelected = 1;
  msgPosChanged   = 2;
  msgClicked      = 3;
  msgItemsChanged = 4;
  msgBarChanged   = 5;
  msgChanged      = 6;
  msgDirChanged   = 7;
  msgDriveChanged = 8;
  msgFileChanged  = 9;

{***þ General Commands for views þ***}
const
  cmQuit          = 1;
  cmClose         = 2;
  cmTerminate     = 3;
  cmDraw          = 4;
  cmNext          = 5;
  cmPrevious      = 6;
  cmOk            = 10;
  cmAccept        = 11;
  cmCancel        = 12;
  cmYes           = 13;
  cmNo            = 14;
  cmAgain         = 10;
  cmNew           = 12;
  cmInsertNew     = 13;
  cmAppendNew     = 14;
  cmEdit          = 15;
  cmDelete        = 16;
  cmLoad          = 17;
  cmSave          = 18;
  cmHelpDisplay   = 19;
  cmEndModal      = 20;

{***þ Testmaker Modes þ***}
const
  TMMode_None  = 0;
  TMMode_Edit  = 1;
  TMMode_Print = 4;

{***þ Print OutPut Targets þ***}
const
  PrintTarget_File    = 1;
  PrintTarget_Printer = 2;

{***þ Paper Components þ***}
const
  QuestionPaper  = 1;
  AnsweringSheet = 2;
  Memmo          = 4;

{***þ Testmaker Password masks þ***}
const
  Pass_None       = 0;
  Pass_PrintPaper = 1;
  Pass_PrintSheet = 2;
  Pass_PrintMemmo = 4;
  Pass_Edit       = 8;
  Pass_Print      = 14;

{***þ Testmaker Item types þ***}
const
  tmAfdeling  = 50;
  tmMonkey    = 51;
  tmColumnAB  = 52;
  tmColABN    = 53;
  tmTerms     = 54;
  tmMessage   = 55;

{***þ Commands þ***}
const
  cmSelectionMenu  = 100;
  cmEditMenu       = 101;
  cmEditNew        = 102;
  cmEditOld        = 103;
  cmTest           = 104;
  cmLearn          = 105;
  cmPrintMenu      = 106;
  cmPrinterConfig  = 107;
  cmAboutMessage   = 108;

  cmExeSet         = 150;
  cmExeHeader      = 151;
  cmExeLayOut      = 152;
  cmExeItem        = 153;

  cmDoneMode       = 170;
  cmDoneEditMode   = 171;
  cmDoneItem       = 172;

  cmStartPrinting  = 200;
  cmAcceptPrnCnf   = 201;
  cmCancelPrnCnf   = 202;
  cmDonePrnWin     = 203;

{***þ Editor Commands þ***}
  cmNewSetFile         = 220;
  cmLoadSetFile        = 221;
  cmSaveSetFile        = 222;
  cmSaveSetFileAs      = 223;

  cmQuestNext          = 233;
  cmQuestPrev          = 234;
  cmQuestBegin         = 235;
  cmQuestEnd           = 236;
  cmQuestNewAfter      = 237;
  cmQuestNewAt         = 238;
  cmQuestDelete        = 239;
  cmItemNext           = 240;
  cmItemPrev           = 241;
  cmToggleInstructions = 242;

  cmAcceptSet          = 1001;
  cmCancelSet          = 1002;
  cmAcceptHeader       = 1003;
  cmCancelHeader       = 1004;
  cmAcceptItem         = 1005;
  cmCancelItem         = 1006;
  cmDoneEditorActive   = 1007;
  cmGetViewData        = 1008;
  cmHidebuttons        = 1009;
  cmShowButtons        = 1010;
  cmToggleMenu         = 1011;
  cmSelectPrev         = 1012;
  cmSelectNext         = 1013;

  cmStatusText         = 1100;
  cmHelpClose          = 1200;
  cmPasswordProtect    = 1300;

{***þ Another View state þ***}
const
  vsModeChange = $1000;

{***þ Testmaker PaperItem Objects þ***}
  IAfdeling  = 50;
  IMonkey    = 51;
  IColumnAB  = 52;
  IColABN    = 53;
  ITerms     = 54;
  IMessage   = 55;

{***þ Help contexts þ***}
const
  hcNoContext        = 0;
  hcButOpstel        = 1;
  hcButPrint         = 4;
  hcButVerlaat       = 5;
  hcClustPrnTarget   = 6;
  hcILinePrnToFile   = 7;
  hcClustCombo       = 8;
  hcClust4TermAns    = 9;
  hcClustMonkAns     = 10;
  hcButStartPrn      = 11;
  hcButSourceFile    = 12;
  hcButPrnConfig     = 13;
  hcButPrnLeave      = 14;
  hcColsPerLine      = 15;
  hcLinesPerPage     = 16;
  hcPrinterList      = 17;
  hcButPrnCnfAccept  = 18;
  hcButPrnCnfCancel  = 19;


Implementation

end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* This init implements all the views and routines used for the Edit Mode   *}
{* of Testmaker.                                                             *}
{****************************************************************************}
Unit EditMode;
  {$F+,O+,Q-,R-,S-}

interface
  Uses Objects, sView, sTypes, Quests;

{***þ Buttonbar view þ***}
type
  PButtonBar = ^TButtonBar;
  TButtonBar = Object(TViewGroup)
    constructor Init;
    procedure   Art; virtual;
  end;

{***þ Main Edit View þ***}
type
  PEditMode = ^TEditMode;
  TEditMode = Object(TViewGroup)
    Buttonbar :PButtonBar;
    Active :PView;
    constructor Init;
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   Listen(var Speech :TSpeech); virtual;
    procedure   GotFocus; virtual;
    procedure   NewActive(View :PView);
    procedure   SetWindow;
    procedure   HeaderWindow;
    procedure   LayoutWindow;
    procedure   ItemWindow;
    procedure   CloseQuestionWindow;
    procedure   ItemQuestionNext;
    procedure   ItemQuestionPrev;
    procedure   ItemQuestionDelete;
    procedure   ItemQuestionBegin;
    procedure   ItemQuestionEnd;
    procedure   ItemQuestionNewAfter;
    procedure   ItemQuestionNewAt;
    procedure   StoreActive;
  end;


Implementation
  uses sBasic, Graph, sGraph, STDViews, Consts, TMData, sProcs,
       Selector, Main;

{***þ Set Info Input window þ***}
type
  PSetView = ^TSetView;
  TSetView = Object(TViewGroup)
    constructor Init;
    procedure   Art; virtual;
  end;

{***þ Header Info Input Window þ***}
  PHeaderView = ^THeaderView;
  THeaderView = Object(TViewGroup)
    constructor Init;
    procedure   Art; virtual;
  end;

{***þ Layout Selection View þ***}
type
  PLayOutView = ^TLayOutView;
  TLayOutView = Object(TViewGroup)
    List    :PLayoutList;
    Buttons :Array[1..3] of PButton;
    constructor Init;
    procedure   Art; virtual;
    function    ConfirmDelete :Word;
    procedure   Listen(var Speech :TSpeech); virtual;
    procedure   RemoveButtons;
    procedure   InsertButtons;
  end;

{****************************************************************************}
{*  TSetView                                                               *}
{****************************************************************************}
constructor TSetView.Init;
  var B :TBounds;
begin
  B.Assign(110, 100, 530, 300);
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable or voFirstClick;
  Lock;
  { Description Line }
  B.Assign(110, 30, 400, 50);
  Append(New(PInputLine, Init(B, 30, '', [#32..#254])));
  { Password Line }
  B.Assign(110, 65, 400, 85);
  Append(New(PInputLine, Init(B, 30, '', [#32..#254])));
{ Password cluster }
  B.Assign(110, 110, Size.X-10, Size.Y-30);
  Append(New(PCluster, Init(B,
                         NewLPstring('Druk van Vraestel',
                         NewLPstring('Druk van Antwoordblad',
                         NewLPstring('Druk van Memmorandum',
                         NewLPString('Redigering',
                         nil)))), HcClustCombo)));
  { Accept button }
  B.Assign(10, Size.Y-23, 100, Size.Y-8);
  Append(New(PButton, Init(B, 'Aanvaar', cmAcceptSet, 0)));
  { Cancel button }
  B.Assign(Size.X-100, Size.Y-23, Size.X-10, Size.Y-8);
  Append(New(PButton, Init(B, 'Kanselleer', cmCancelSet, 0)));
  SelectNext;
  Unlock;
end; { TSetView.Init }

Procedure TSetView.Art;
begin
  Platform(0, 0, Size.X, Size.Y, $F007);
  Platform(1, 1, Size.X-1, Size.Y-1, $F007);
  Platform(3, 5, Size.X-3, 25, $F001);
  WriteStrXY(Size.X shr 1, 10, $1E, 2, 5, JustCenter, False, 'Stel Verwysing');
  WriteStrXY(10, 25, $1A, 4, 1, JustLeft+JustTop, False, 'Beskrywing');
  WriteStrXY(10, 60, $1A, 4, 1, JustLeft+JustTop, False, 'Wagwoord');
  WriteStrXY(100, 95, $E, 2, 5, JustLeft+JustTop, False, 'Wagwoord het betrekking op :');
  { Divider Lines }
  Setcolor(8);
  Line(10, 57, Size.X-10, 57);
  Setcolor($F);
  Line(10, 58, Size.X-10, 58);
  Setcolor($8);
  Line(10, 59, Size.X-10, 59);
  Setcolor(8);
  Line(10, Size.Y-30, Size.X-10, Size.Y-30);
  Setcolor($F);
  Line(10, Size.Y-31, Size.X-10, Size.Y-31);
  Setcolor($8);
  Line(10, Size.Y-32, Size.X-10, Size.Y-32);
end; { TSetView.Art }

{****************************************************************************}
{*  THeaderView                                                               *}
{****************************************************************************}
constructor THeaderView.Init;
  var B :TBounds;
begin
  B.Assign(110, 70, 530, 320);
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable or voFirstClick;
  Lock;
  { Subject Line }
  B.Assign(110, 35, 300, 55);
  Append(New(PInputLine, Init(B, 30, '', [#32..#254])));
  { PaperNumber Line }
  B.Assign(110, 60, 300, 80);
  Append(New(PInputLine, Init(B, 15, '', [#32..#254])));
  { Standard Line }
  B.Assign(110, 85, 300, 105);
  Append(New(PInputLine, Init(B, 20, '', [#32..#254])));
  { Grade Line }
  B.Assign(110, 110, 300, 130);
  Append(New(PInputLine, Init(B, 15, '', [#32..#254])));
  { Date Line }
  B.Assign(110, 135, 300, 155);
  Append(New(PInputLine, Init(B, 20, '', [#32..#254])));
  { Setter Line }
  B.Assign(110, 160, 300, 180);
  Append(New(PInputLine, Init(B, 30, '', [#32..#254])));
  { Time Line }
  B.Assign(110, 185, 300, 205);
  Append(New(PInputLine, Init(B, 10, '', [#32..#254])));
  { Accept button }
  B.Assign(10, 225, 100, 240);
  Append(New(PButton, Init(B, 'Aanvaar', cmAcceptHeader, 0)));
  { Cancel button }
  B.Assign(Size.X-100, 225, Size.X-10, 240);
  Append(New(PButton, Init(B, 'Kanselleer', cmCancelHeader, 0)));
  SelectNext;
  Unlock;
end; { THeaderView.Init }

Procedure THeaderView.Art;
  var I :Word;
    Procedure WriteLabel(Y :Integer; Str :String);
    begin
      SetColor(0);
      OutTextXY(26, Y+1, Str);
      SetColor(6);
      OutTextXY(25, Y, Str);
    end; { Writelabel }
begin
  Platform(0, 0, Size.X, Size.Y, $F007);
  Platform(1, 1, Size.X-1, Size.Y-1, $F007);
  Platform(3, 5, Size.X-3, 25, $F001);
  WriteStrXY(Size.X shr 1, 10, $1E, 2, 5, JustCenter, False,
    'Vraestel Opskrif');
  SetTextJustify(LeftText, TopText);
  SetTextStyle(3, Horizdir, 1);
  WriteLabel(30, 'Vak');
  WriteLabel(55, 'Nommer');
  WriteLabel(80, 'Vlak');
  WriteLabel(105, 'Graad');
  WriteLabel(130, 'Datum');
  WriteLabel(155, 'Opsteller');
  WriteLabel(180, 'Tyd');
  Line3D(10, 215, Size.X-10, 215, $8F);
end; { THeaderView.Art }

{****************************************************************************}
{*  TLayOutView                                                               *}
{****************************************************************************}
constructor TLayOutView.Init;
  var B :TBounds;
begin
  B.Assign(80, 100, 530, 300);
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable or voFirstClick;
  Lock;
  { List }
  B.Assign(15, 65, 265, Size.Y-38);
  New(List, Init(B));
  Append(List);
  { Buttons }
  B.Assign(285, 75, 440, 95);
  Buttons[1] := New(PButton, Init(B, 'Las ''n Item aan', cmAppendNew, 0));
  B.Assign(285, 105, 440, 125);
  Buttons[2] := New(PButton, Init(B, 'Voeg ''n Item in', cmInsertNew, 0));
  B.Assign(285, 135, 440, 155);
  Buttons[3] := New(PButton, Init(B, 'Verwyder ''n Item', cmDelete, 0));
  InsertButtons;
  Unlock;
end; { TLayOutView.Init }

procedure TLayOutView.Art;
  var I :Word;
begin
  Platform(0, 0, Size.X, Size.Y, $F007);
  Platform(1, 1, Size.X-1, Size.Y-1, $F007);
  Platform(3, 5, Size.X-3, 25, $F001);
  WriteStrXY(Size.X shr 1, 10, $1E, 2, 5, JustCenter, False,
    'Vraestel Uitleg ');
  Setcolor(8);
  Line3D(10, 57, Size.X-10, 57, $8F);
  Line3D(10, Size.Y-30, Size.X-10, Size.Y-30, $8F);
  Line3D(275, 59, 275, Size.Y-30, $8F);
end; { TLayOutView.Art }

procedure TLayOutView.Listen(var Speech :TSpeech);
begin
  if Speech.Tone = spCommand then
    case Speech.What of
      cmInsertNew   :List^.InsertItem;
      cmAppendNew   :List^.AppendItem;
      cmDelete      :if ConfirmDelete = cmYes then  List^.Delete;
      cmHideButtons :RemoveButtons;
      cmShowButtons :InsertButtons;
      else begin inherited Listen(Speech); end;
    end;
  SpeechHeard(Speech);
end; { TLayOutView.Listen }

{ ConfirmDelete will display a messagebox to confirm whether to delete a item
  or not. }
function TLayOutView.ConfirmDelete :Word;
  var B :TBounds;
begin
  B.Assign(125,200,515,300);
  ConfirmDelete :=
    MessageWindow(B, #3'Destruktiewe Operasie - Gaan voort ?',
      mwfWarning+mwfYes+mwfNo)
end; { TLayOutView.ConfirmDelete }

{ RemoveButtons will disable all buttons within the view }
procedure TLayOutView.RemoveButtons;
  var I :Byte;
begin
  Lock;
  for I := 1 to 3 do Remove(Buttons[I]);
  Unlock;
  Draw;
end; { TLayOutView.RemoveButtons }

{ InsertButtons will enable all buttons within the view }
procedure TLayOutView.InsertButtons;
  var I :Byte;
begin
  Lock;
  for I := 1 to 3 do Append(Buttons[I]);
  Unlock;
  Draw;
  SelectNext;
end; { TLayOutView.InsertButtons }

{****************************************************************************}
{*  TButtonBar                                                             *}
{****************************************************************************}
constructor TButtonBar.Init;
  var B :TBounds;
begin
  B.Assign(20, 10, 620, 35);
  Inherited Init(B);
  { Set View Options }
  ViewOptions := ViewOptions or voSelectable or vofirstClick;
  { Add Buttons }
  Lock;
  B.Assign(10, 5, 60, 20);
  Append(New(PButton, Init(B, 'Open', cmLoadsetFile, 0)));
  B.Assign(70, 5, 120, 20);
  Append(New(PButton, Init(B, 'Stoor', cmSaveSetFile, 0)));
  B.Assign(130, 5, 210, 20);
  Append(New(PButton, Init(B, 'Stoor As', cmSaveSetFileAs, 0)));
  B.Assign(250, 5, 300, 20);
  Append(New(PButton, Init(B, 'Stel', cmExeSet, 0)));
  B.Assign(310, 5, 380, 20);
  Append(New(PButton, Init(B, 'Opskrif', cmExeHeader, 0)));
  B.Assign(390, 5, 450, 20);
  Append(New(PButton, Init(B, 'Uitleg', cmExeLayout, 0)));
  B.Assign(Size.X-85, 5, Size.X-5, 20);
  Append(New(PButton, Init(B, 'Verlaat', cmDoneEditMode, 0)));
  SelectNext;
  UnLock;
end; { TButtonBar.Init }

procedure TButtonbar.Art;
begin
  PlatForm(0, 0, Size.X, Size.Y, $0F23);
end; { TButtonBar.Art }

{****************************************************************************}
{*  TEditMode                                                              *}
{****************************************************************************}
constructor TEditMode.Init;
  var B :TBounds;
begin
  CurrentMode := TMMode_Edit;
  B.Assign(0, 100, GetMaxX, 440);
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable or voFirstClick;
  { Insert ButtonBar }
  Lock;
  Buttonbar := New(PButtonBar, Init);
  Append(ButtonBar);
  Unlock;
end; { TEditmode.Init }

destructor TEditMode.Done;
begin
  inherited done;
end; { TEditmode.Done }

procedure TEditMode.Art;
begin
  PlatForm(0, 0, Size.X, Size.Y, $07);
  Level(2, 2, Size.X-2, Size.Y-2, RaiseGrey);
  Level(3, 3, Size.X-3, Size.Y-3, Raisegrey);
  Level(4, 4, Size.X-4, Size.Y-4, LowerGrey);
  Level(5, 5, Size.X-5, Size.Y-5, LowerGrey);
  PlatForm(10, 50, Size.X-10, Size.Y-10, $8FA4);
  PlatForm(Size.X shr 1-50, 37, Size.X shr 1 +50, 47, $0F09);
  WriteStrXY(Size.X shr 1, 41, $0F, 2, 4, JustCenter, False,
    PaperData^.GetTruncFileName);
end; { TEditmode.Art }

procedure TEditMode.Listen(var Speech :TSpeech);
begin
  if Speech.Tone = spCommand then
  case Speech.What of
    cmExeSet       :SetWindow;
    cmExeHeader    :HeaderWindow;
    cmExeLayOut    :LayOutWindow;
    cmExeItem      :ItemWindow;
    cmAcceptSet    :
      begin
        Active^.GetData(PaperData^.Descript);
        PaperData^.Modified := True;
        NewActive(nil);
      end;
    cmAcceptHeader :
      begin
        Active^.Getdata(PaperData^.Header);
        PaperData^.Modified := True;
        NewActive(nil);
      end;
    cmAcceptItem :
      begin
        PPAperItem_Data(PaperData^.Items^.At(CurrentItem))^.
          GetViewData(PPAperItem_View(Active));
        PaperData^.Modified := True;
        NewActive(nil);
      end;
    cmGetViewData :StoreActive;
    cmCancelHeader,
    cmCancelSet,
    cmCancelItem,
    cmDoneEditorActive :NewActive(nil);
    cmQuestNext   :ItemquestionNext;
    cmQuestPrev   :ItemQuestionPrev;
    cmQuestDelete :ItemquestionDelete;
    cmQuestBegin  :ItemQuestionBegin;
    cmQuestEnd    :ItemQuestionEnd;
    cmQuestNewAfter :ItemQuestionNewAfter;
    cmQuestNewAt  :ItemQuestionNewAt;
    cmToggleMenu  :SelectNext;
    cmSelectNext  :if ActiveView = PView(ButtonBar)
                   then ButtonBar^.SelectNext;
    cmSelectPrev  :if ActiveView = PView(ButtonBar)
                   then ButtonBar^.SelectPrevious;
    else begin Inherited Listen(Speech); exit; end;
  end;
  SpeechHeard(Speech);
end; { TEditmode.Listen }

{ Displays a new string on the statusline. }
procedure TEditMode.GotFocus;
begin
  PutMessage(spCommand, cmStatustext,
    NewStr('Testmaker Redigerings modus:  F1 - Hulp  F9 - Lokale Menu en terug'));
end;

{ Executes the PaperSet Info Input Window }
procedure TEditMode.SetWindow;
begin
  if PaperData^.Descript.Mask <> 0 then
  begin
    Message(Application, spCommand, cmPasswordProtect, nil);
    if not Access then Exit;
  end;
  Lock;
  NewActive(New(PSetView, Init));
  SetData(PaperData^.Descript);
  Unlock;
  Draw;
end; { TEditmode.SetWindow }

{ Executes the Header Info Input window }
procedure TEditMode.HeaderWindow;
begin
  if PaperData^.Descript.Mask and Pass_Edit <> 0 then
  begin
    Message(Application, spCommand, cmPasswordProtect, nil);
    if not Access then Exit;
  end;
  Lock;
  NewActive(New(PHeaderView, Init));
  SetData(PaperData^.Header);
  Unlock;
  Draw;
end; { TEditmode.HeaderWindow }

{ Executes the Layout selection window }
procedure TEditMode.LayoutWindow;
begin
  if PaperData^.Descript.Mask and Pass_Edit <> 0 then
  begin
    Message(Application, spCommand, cmPasswordProtect, nil);
    if not Access then Exit;
  end;
  Lock;
  NewActive(New(PLayOutView, Init));
  Unlock;
  Draw;
end; { TEditmode.LayoutWindow }

{ Execute the currently selected Question in the layout window }
procedure TEditMode.ItemWindow;
begin
  Lock;
  with PPAperItem_Data(PaperData^.Items^.At(CurrentItem))^ do
  begin
    NewActive(New_PaperItem_View(Itemtype));
    SetViewdata(PPaperItem_View(Active));
  end;
  Unlock;
  Draw;
end; { TEditmode.ItemWindow }

{ Terminates a Question Window and stores its data }
procedure TEditMode.CloseQuestionWindow;
begin
  with PPAperItem_Data(PaperData^.Items^.At(CurrentItem))^ do
  begin
    GetViewdata(PQuestionItem_View(Active));
    NewActive(nil);
  end;
end; { TEditmode.CloseQuestionWindow }

{ Removes the currently displayed sub-window of the edit mode and insert a
  the new Window View }
procedure TEditMode.NewActive(View :PView);
  var AddNew :Boolean;
begin
  { if a active view exist check if it will terminate }
  if Active <> nil then
    if Active^.Valid(cmTerminate) then AddNew := True
    else
    begin
      if View <> nil then Dispose(View, Done);
      AddNew := False;
    end
  else AddNew := true;
  { Add the new view }
  if AddNew then
  begin
    Lock;
    if Active <> nil then
    begin
      StoreActive;
      Delete(Active);
    end;
    Active := View;
    if Active <> nil then Append(Active);
    Unlock;
    Draw;
  end
end; { TEditmode.NewActive }

{ Displays the next sub-question record of the current question }
procedure TEditMode.ItemQuestionNext;
  var Item :PQuestionItem_Data;
begin
  Item := PaperData^.Items^.At(CurrentItem);
  with Item^ do
    if Current+1 < List^.Count then
    begin
      GetViewData(PQuestionItem_View(Active));
      Inc(Current);
      SetViewData(PQuestionItem_View(Active));
    end;
end; { TEditmode.ItemQuestionNext }

{ Displays the previous sub-question record of the current question }
procedure TEditMode.ItemQuestionPrev;
  var Item :PQuestionItem_Data;
begin
  Item := PaperData^.Items^.At(CurrentItem);
  with Item^ do
    if Current > 0 then
    begin
      GetViewData(PQuestionItem_View(Active));
      Dec(Current);
      SetViewData(PQuestionItem_View(Active));
    end;
end; { TEditmode.ItemQuestionPrev }

{ Deletes the current sub-question record of the current question
  and then displays the next record }
procedure TEditMode.ItemQuestionDelete;
  var Item :PQuestionItem_Data;
begin
  Item := PaperData^.Items^.At(CurrentItem);
  with Item^ do
  begin
    if List^.Count > 0 then
    begin
      List^.AtFree(Current);
      if List^.Count = 0 then List^.AtInsert(0, GetNew) else
        if (Current = List^.Count) and (Current > 0) then Dec(Current);
      SetViewData(PQuestionItem_View(Active));
      Changed;
    end
  end;
end; { TEditmode.ItemQuestionDelete }

{ Displays the first sub-question record of the current question }
procedure TEditMode.ItemQuestionBegin;
  var Item :PQuestionItem_Data;
begin
  Item := PaperData^.Items^.At(CurrentItem);
  with Item^ do
    if Current > 0 then
    begin
      GetViewData(PQuestionItem_View(Active));
      Current := 0;
      SetViewData(PQuestionItem_View(Active));
    end;
end; { TEditmode.ItemQuestionBegin }

{ Displays the last sub-question record of the current question }
procedure TEditMode.ItemQuestionEnd;
  var Item :PQuestionItem_Data;
begin
  Item := PaperData^.Items^.At(CurrentItem);
  with Item^ do
  begin
    if Current+1 < List^.Count then
    begin
      GetViewData(PQuestionItem_View(Active));
      Current := List^.Count-1;
      SetViewData(PQuestionItem_View(Active));
    end;
  end;
end;  { TEditmode.ItemQuestionEnd }

{ Creates a new sub-question record for the current question and displays
  its empty fields. It is inserted after the current record position }
procedure TEditMode.ItemQuestionNewAfter;
  var Item :PQuestionItem_Data;
      P :PObject;
begin
  Item := PaperData^.Items^.At(CurrentItem);
  with Item^ do
  begin
    P := GetNew;
    if P <> nil then
    begin
      GetViewData(PQuestionItem_View(Active));
      Inc(Current);
      List^.AtInsert(Current, P);
      SetViewData(PQuestionItem_View(Active));
      Changed;
    end;
  end;
end;  { TEditmode.ItemQuestionNewAfter }

{ Creates a new sub-question record for the current question and displays
  its empty fields. It is inserted at the current record position }
procedure TEditMode.ItemQuestionNewAt;
  var Item :PQuestionItem_Data;
      P :PObject;
begin
  Item := PaperData^.Items^.At(CurrentItem);
  with Item^ do
  begin
    P := GetNew;
    if P <> nil then
    begin
      GetViewData(PQuestionItem_View(Active));
      List^.AtInsert(Current, P);
      SetViewData(PQuestionItem_View(Active));
      Changed;
    end;
  end;
end; { TEditmode.ItemQuestionNewAt }


{ Stores the data of the current sub-question record of the current question }
procedure TEditMode.StoreActive;
begin
  if PaperData^.Items^.Count > 0 then
    if IsQuestionView(Active) then
       PQuestionItem_Data(PaperData^.Items^.At(CurrentItem))^.
         GetViewData(PQuestionItem_View(Active));
end; { TEditmode.StoreActive }

end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{****************************************************************************}
Unit Main;
  {$F+,O+,Q-,R-,S-}

Interface
  Uses Objects, sGraph, Graph, sView, sInput,  STDViews, sTypes,
       Selector, consts, EditMode, TMData;

{***þ StatusLine object þ***}
type
  PStatusLine = ^TStatusLine;
  TStatusLine = Object(Tview)
    Text :PString;
    constructor Init(TextStr :String);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   DisplayText(TextStr :String);
  end;

{***þ HelpViewer þ***}
type
  PHelpViewer =^THelpViewer;
  THelpViewer = Object(TViewGroup)
    Helpfile :PHelpFile;
    Context  :Word;
    constructor Init(HlpFile :PHelpFile; Ctx :Word);
    procedure   Art; virtual;
    procedure   Listen(var Speech :TSpeech); virtual;
  end;

{***þ Program controller object þ***}
type
  PProgram = ^TProgram;
  TProgram = Object(TViewGroup)
    Active :PViewGroup;
    constructor Init;
    destructor  Done;      virtual;
    procedure   Art;       virtual;
    procedure   Listen(var Speech :TSpeech); virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    procedure   MouseInput(var Input :TMouseInput); virtual;
    procedure   Run;
    procedure   NewActive(New :PViewGroup);
    function    ConfirmSave :Word;
    procedure   NewSet(Name :String);
    procedure   LoadSet;
    procedure   SaveSet;
    procedure   SaveSetAs;
    procedure   AboutMessage;
    procedure   LoadConfig;
    procedure   SaveConfig;
  end;

{***þ Initialized variables þ***}
const
  Application :PProgram       = nil;
  StatusLine  :PStatusLine    = nil;
  CurrentItem :Word           = 0;
  CurrentMode :Byte           = 0;
  Access      :Boolean        = False;


Implementation
  uses sBasic, sProcs, PrnMode, graphics, sInts;

{****************************************************************************}
{*  StatusLine                                                             *}
{****************************************************************************}
constructor TStatusLine.Init(TextStr :String);
  var B :TBounds;
begin
  StatusLine := @Self;
  B.Assign(0, 450, GetMaxX, GetMaxY);
  Inherited Init(B);
  Text := NewStr(TextStr);
end;

destructor TStatusLine.Done;
begin
  DisposeStr(Text);
  inherited Done;
end;

Procedure TStatusLine.Art;
begin
  Platform(0, 0, Size.X, Size.Y, RaiseGrey);
  Platform(5, 5, Size.X-5, Size.Y-5, LowerGrey);
  if Text <> nil then WriteStrXY
    (20, 12, ShadowWhite, 0, 1, JustLeft+JustTop, False, Text^);
end;

{ Displays the text TextStr on the statusline }
Procedure TStatusLine.DisplayText(TextStr :String);
begin
  DisposeStr(Text);
  Text := NewStr(TextStr);
  Draw;
end;

{****************************************************************************}
{*  THelpViewer                                                            *}
{****************************************************************************}
constructor THelpViewer.Init(HlpFile :PHelpFile; Ctx :Word);
  var B :TBounds;
begin
  B.Assign(50, 120, GetMaxX-50, GetMaxY-50);
  inherited Init(B);
  Context := Ctx;
  Lock;
  B.Assign(100, Size.Y-30, Size.X-100, Size.Y-10);
  Append(New(Pbutton, Init(B, 'Sluit Hulp Venster', cmHelpClose, 0)));
  HelpFile := HlpFile;
  Unlock;
end;

procedure THelpViewer.Art;
  var S :String;
      Y :Integer;
begin
  Platform(0, 0, Size.X, Size.Y,  $F008);
  Platform(5, 5, Size.X-5, Size.Y-5,  $8B03);
  { Draw Caption }
  Platform(6, 6, Size.X-6, 26,  $F807);
  Platform(10, 35, Size.X-10, Size.Y-40,  $0B03);
  WriteStrXY(Size.X shr 1, 13, $0E, 2, 5, JustCenter,
    False, 'Testmaker Hulp Stelsel');
  S := '';
  Y := 40;
  HelpFile^.ScanToCtx(Context);
  while (Y < Size.Y-45) and
        not(HelpFile^.CtxEnd) and
        not(HelpFile^.ErrorVal <> HelpFile_Ok) do
  Begin
    S := HelpFile^.ReadLine;
    SSetLen(S, MinByte(Length(S), (Size.X-30) div TextWidth('X')));
    WriteStrXY(15, Y, $1F, 0, 1, 0, False, S);
    Inc(Y, TextHeight(S));
  end; {while}
end; { THelpviewer.Art }

procedure THelpViewer.Listen(var Speech :TSpeech);
begin
  if Speech.Tone = spCommand then
    if Speech.What = cmHelpClose then
    begin
      EndModal(cmHelpClose);
      SpeechHeard(Speech);
    end; {if}
end; { THelpViewer.Listen }

{****************************************************************************}
{*  TProgram                                                               *}
{****************************************************************************}
constructor TProgram.Init;
  var B :TBounds;
begin
  StartUpDir := NewStr(GetExeDir);
  Application := @Self;
  { Initialize systems }
  InitGraphics;
  InitInput;
  { Initialize self }
  B.Assign(0, 0, GetMaxX, GetMaxY);
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable;
  { Set DataFile name to noname }
  NewSet('NAAMLOOS.TMS');
  { Add Views }
  Lock;
  { Add StatusLine }
  Append(New(PStatusLine, Init('Welkom by Testmaker - Kies asseblief ''n Opsie')));
  { Add and set active view }
  Active := New(PModeSelector, Init);
  Append(Active);
  Unlock;
end;

procedure TProgram.Run;
begin
  Execute;
end;

destructor TProgram.Done;
begin
  Dispose(PaperData, Done);
  Inherited Done;
  DoneInput;
  DoneGraphics;
  DisposeStr(StartUpDir);
end;

procedure TProgram.Art;
  var P :PBitImage;
begin
  PlatForm(0, 0, Size.X, Size.Y, 0);
  Platform(0, 0, 110, 90, RaiseGrey);
  Platform(530, 0, getMaxX, 90, RaiseGrey);
  Platform(125, 0, 515, 70, RaiseGrey);
  WriteStrXY(140, 60, ShadowWhite, 1, 2, JustBottom+JustLeft, True, 'TEST');
  WriteStrXY(175, 55, ShadowWhite, 1, 7, JustBottom+JustTop, False, 'MAKER');
  P := PBitImage(GetResource('Book1'));
  if P <> nil then
  begin
    P^.Put(10, 10, XorPut);
    P^.Put(40, 30, XorPut);
    P^.Put(70, 50, XorPut);
    Dispose(P, Done);
  end; {if}
end; { TProgram.Art }

procedure TProgram.Listen(var Speech :TSpeech);

     { Pops up a Password input window }
     function GetPassword :Boolean;
       var B :TBounds;
     begin
       GetPassword := True;
       if Access then Exit;
       if ExecView(New(PPasswordWin,
         Init(PaperData^.Descript.Password))) = cmYes then
       begin
         GetPassword := True;
         Access := True;
       end {if}
       else
       begin
         GetPassword := False;
         B.Assign(125,200,515,300);
         MessageWindow(B, #3'Wagwoord nie korrek.'#13#3'Toegang geweier.',
         mwfError+mwfOk);
       end; {else}
     end; {sub func GetPassword }

     { Starts to print a Testmaker setfile }
     procedure StartPrinting;
     begin
       Active^.GetData(PrintSettings);
       if PaperData^.Descript.Mask and PrintSettings.Combo <> 0 then
         if GetPassword then PrnMode.StartPrinting else
       else PrnMode.StartPrinting;
     end; { sub proc StartPrinting }

     { Closes the editmode, selector mode etc. }
     procedure DoneMode(EditMode :Boolean);
     begin
       if EditMode then
       begin
         Speech.What := ConfirmSave;
         if Speech.What = cmYes then SaveSet
         else if Speech.What = cmCancel then Exit;
       end; {if}
       if Active^.Valid(cmTerminate) then
       NewActive(New(PModeSelector, Init));
       CurrentMode := TMMode_None;
     end; { sub proc DoneMode }

     { Executes the Printer options window }
     procedure PrintOptionsWin;
     begin
       LoadConfig;
       NewActive(New(PPrintOptionsWin, Init));
       Active^.SetData(PrintSettings);
       if PaperData^.FileName^ = 'NAAMLOOS.TMS' then LoadSet;
       if PaperData^.FileName^ = 'NAAMLOOS.TMS' then DoneMode(False);
     end; { sub proc PrintOptionsWin }

     { Display the help context discribed in Speech.Infoword }
     procedure HelpDisplay;
       var HlpFile :THelpFile;
     begin
       with HlpFile do
       begin
         Init;
         ScanToCtx(Speech.InfoWord);
         if Errorval = HelpFile_Ok then
           ExecView(New(PHelpViewer, Init(@HlpFile, Speech.InfoWord)));
         Done;
       end; {with}
     end; { Sub proc HelpDisplay }

begin { TProgram.Listen }
  if Speech.Tone <> spNone then
  case Speech.What of
    cmSelectionMenu :NewActive(New(PModeSelector, Init));
    cmEditMenu      :
      begin
        if PaperData^.Descript.Mask and Pass_Edit <> 0 then
          if GetPassword  then NewActive(New(PEditMode, Init)) else
        else NewActive(New(PEditMode, Init));
      end;
    cmPrintMenu     :PrintOptionsWin;
    cmDoneEditMode  :DoneMode(True);
    cmDoneMode      :DoneMode(False);
    cmDonePrnWin    :
      begin
        Active^.GetData(Printsettings);
        SaveConfig;
        DoneMode(False);
      end;
    cmSaveSetFile   :SaveSet;
    cmSaveSetFileAs :SaveSetAs;
    cmLoadSetFile   :LoadSet;
    cmAboutMessage  :AboutMessage;
    cmStartPrinting :StartPrinting;
    cmStatusText    :
      begin
        StatusLine^.DisplayText(Speech.InfoPString^);
        DisposeStr(Speech.InfoPString);
      end;
    cmPrinterConfig :
      begin
        Lock;
        Active^.GetData(Printsettings);
        NewActive(New(PPrinterConfigWin, Init));
        Active^.SetData(Printsettings.CharsPL);
        Unlock;
        Draw;
      end;
    cmAcceptPrnCnf :
      begin
        Active^.GetData(PrintSettings.CharsPl);
        PrintOptionsWin;
      end;
    cmCancelPrnCnf :PrintOptionsWin;
    cmPasswordProtect :GetPassword;
    cmHelpDisplay  :HelpDisplay;
    else begin inherited Listen(Speech); exit; end;
  end;
  SpeechHeard(Speech);
end; { TProgram.Listen }

procedure TProgram.KeybordInput(var Input :TKeybordInput);
begin
  inherited KeybordInput(Input);
  if Input.What <> inNothing then
  Case Input.KeyCode of
    kbF9 :Message(Active, spCommand, cmToggleMenu, nil);
    kbLeft, kbUp    :Message(Active, spCommand, cmSelectPrev, nil);
    kbRight, kbDown :Message(Active, spCommand, cmSelectNext, nil);
  end;
end;

procedure TProgram.MouseInput(var Input :TMouseInput);
  var HelpViews :Array[1..3] of TBounds;
      Clicked   :Byte;
begin
  inherited MouseInput(Input);
  if Input.What and inMouseDown <> 0 then
  begin
    HelpViews[1].Assign(0, 0, 110, 90);
    HelpViews[2].Assign(125,1,515,70);
    HelpViews[3].Assign(530, 0, getMaxX, 90);
    for Clicked := 1 to 3 do
      if HelpViews[Clicked].WithIn(Input.Where) then
      begin
        Case Clicked of
          1 :PutMessage(spCommand, cmHelpDisplay, Ptr(0, 1));
          2 :PutMessage(spCommand, cmAboutMessage, nil);
        end;{case}
        InputHandled(Input);
      end; {if}
  end; {if}
end; { TProgram.MouseInput }

 { Executes a new sub view or Mode }
procedure TProgram.NewActive(New :PViewGroup);
begin
  Lock;
  Delete(Active);
  Active := New;
  Append(Active);
  Unlock;
  Draw;
end;

 { Opens a new setfile. It first asks if the currently opened file must be closed. }
procedure TProgram.NewSet;
begin
  if PaperData <> nil then
  begin
    case ConfirmSave of
      cmCancel :Exit;
      cmYes    :PaperData^.Save;
      cmNo     :;
     end;{case}
    Dispose(PaperData, Done);
  end;{if}
  New(PaperData, Init(Name));
end;  { TProgram.NewSet }

{ Loads a Testmaker setfile }
procedure TProgram.LoadSet;
begin
  { Ask if current setfile should be saved }
  case ConfirmSave of
    cmCancel :Exit;
    cmYes    :PaperData^.Save;
    cmNo     :;
  end;
  case ExecView(New(PSetLister, Init(True))) of
    cmAccept :
      begin
        Lock;
        Message(Active, spCommand, cmDoneEditorActive, nil);
        PaperData^.Load;
        Unlock;
        Active^.Draw;
        Access := False;
      end;
    cmCancel :;
  end;{case}
end; { TProgram.LoadSet }

{ Saves the active setfile }
procedure TProgram.SaveSet;
begin
  if PaperData^.FileName^ = 'NAAMLOOS.TMS' then SaveSetAs
  else
  begin
    Message(Active, spCommand, cmGetViewData, nil);
    PaperData^.Save;
    Unlock;
  end; {else}
end; { TProgram.SaveSet }

{ Saves the current setfile to another name }
procedure TProgram.SaveSetAs;
begin
  PaperData^.Modified := True;
  case ExecView(New(PSetLister, Init(False))) of
    cmAccept :
      begin
        Message(Active, spCommand, cmGetViewData, nil);
        PaperData^.Save;
      end;
    cmCancel :;
  end; {case}
end; { TProgram.SaveSetAs }

{ Pops up a confirmationbox which asks whether to save
  the current setfile or not }
function TProgram.ConfirmSave :Word;
  var B :TBounds;
begin
  if not PaperData^.Modified then
  begin
    ConfirmSave := cmNo;
    Exit;
  end;
  B.Assign(125, 200, 515, 300);
  ConfirmSave :=
    MessageWindow(B, #3'Stoor '+PaperData^.GetTruncFileName+'?',
      mwfConfirmation+mwfYes+mwfNo+mwfCancel)
end; { TProgram.ConfirmSave }

{ Pops up the About Testmaker Window }
procedure TProgram.AboutMessage;
  var B :TBounds;
begin
  B.Assign(120,100,500,350);
  MessageWindow(B, #3'Testmaker Weergawe 1.0 - Demonstrasie Program'#13+
                   #13+
                   #13+
                   #3'Alle Programmering gedoen deur:'#13+
                   #13+
                   #3'Hannes de Jager'#13+
                   #3'Posbus 112'#13+
                   #3'Reitz'#13+
                   #3'9810'#13+
                   #3'Tel: (058) 86 31304'#13+
                   #13+
                   #13+
                   #3'Grafika Sketsies verkry by Cedric Sceepers.'+
                   #3'Kontak my indien u enige vrae of aanbevelings het.',
                    mwfInformation+mwfOk);
end; { TProgram.AboutMessage }

{ Loads the Printsettings from the configuration file }
procedure TProgram.LoadConfig;
  var F :File of TPrintSettings;
      B :TBounds;
begin
  {$I-}
  Assign(F, StartUpDir^+CnfFile_Name);
  Reset(F);
  Read(F, PrintSettings);
  Close(F);
  {$I+}
  if IOResult <> 0 then
  begin
    B.Assign(125, 200, 515, 300);
    MessageWindow(B, #3'Kon nie drukker konfigurasie laai nie.'#13+
                     #3'Oorspronklike konfigurasie word gebruik',
                      mwfError+mwfOk);
  end;
end; { TProgram.LoadConfig }

{ Saves the Printsettings to the configuration file }
procedure TProgram.SaveConfig;
  var F :File of TPrintSettings;
      B :TBounds;
begin
  {$I-}
  Assign(F, StartUpDir^+CnfFile_Name);
  Rewrite(F);
  Write(F, PrintSettings);
  Close(F);
  {$I+}
  if IOResult <> 0 then
  begin
    B.Assign(125, 200, 515, 300);
    MessageWindow(B, 'Kon nie drukker konfigurasie stoor nie.',
                      mwfError+mwfOk);
  end; {if}
end; { TProgram.SaveConfig }

end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{  Contains all the code used to implement the Print Mode of Testmaker      *}
{****************************************************************************}
Unit PrnMode;
  {$F+,O+,Q-,R-,S-}

{ This Unit implements all the code used for the PRINT MODE of
  Testmaker. }

Interface
  uses Objects, sBasic, sView, STDViews, consts;

{***þ Available Printer types þ***}
const
  ASCIIPrinter   = 0;
  EpsonPrinter   = 1;
  HPLaserPrinter = 2;
  PostScrPrinter = 3;
  IBMPrinter     = 4;

{***þ Available Text Styles þ***}
const
  Style_Normal    = $00;
  Style_Bold      = $01;
  Style_Italic    = $02;
  Style_UnderLine = $04;

{***þ Printer States þ***}
const
  Prn_TimedOut    = $01;
  Prn_IOError     = $08;
  Prn_Selected    = $10;
  Prn_OutOfPaper  = $20;
  Prn_Acknowledge = $40;
  Prn_NotBusy     = $80;
  Prn_Ready       = Prn_Selected+Prn_NotBusy; { not a mask }

{***þ PrinterCodes þ***}
const
  ASCIIEndLine  = #13#10;
  ASCIIEndPage  = #12;

  EpsonInit      = #17#27'@';
  EpsonDone      = '';
  EpsonItalic    = #27'4';
  EpsonNoItalic  = #27'5';
  EpsonBold      = #27'E'#27'G';
  EpsonNoBold    = #27'F'#27'H';
  EpsonULine     = #27'-'#1;
  EpsonNoULine   = #27'-'#0;
  EpsonHQuality  = #27'x'#1;
  EpsonDraft     = #27'x'#0;
  EpsonEndLine   = ASCIIEndLine;
  EpsonStartPage = '';
  EpsonEndPage   = ASCIIEndPage;

  HPInit         = #27'E'#27'(10U'#27'&k0S'#27'(s3T';
  HPDone         = #12;
  HPItalic       = #27'(s1S';
  HPNoItalic     = #27'(s0S';
  HPBold         = #27'(s3B';
  HPNoBold       = #27'(s0B';
  HPULine        = #27'&dD';
  HPNoULine      = #27'&d@';
  HPHQuality     = '';
  HPDraft        = '';
  HPEndLine      = EpsonEndLine;
  HPStartPage    = EpsonStartPage;
  HPEndPage      = EpsonEndPage;

  PSInit1        = #4'%!PS-Adobe-3.0'#13#10'initgraphics'#13#10+
                   +'/fnr /Courier findfont 10 scalefont def'#13#10
                   +'/fni /Courier-Oblique findfont 10 scalefont def'#13#10
                   +'/fnb /Courier-Bold findfont 10 scalefont def'#13#10;
  PSInit2        =  '/fnbi /Courier-BoldOblique findfont 10 scalefont def'#13#10
                   +'/newl {20 currentpoint exch pop 12 sub moveto} def'#13#10
                   +'/newp {20 765 moveto} def'#13#10
                   +'fnr setfont'#13#10;
  PSDone         = #4;
  PSNormal       = 'fnr setfont'#13#10;
  PSItalic       = 'fni setfont'#13#10;
  PSBold         = 'fnb setfont'#13#10;
  PSBoldItalic   = 'fnbi setfont'#13#10;
  PSULine        = '';
  PSNoULine      = '';
  PSHQuality     = '';
  PSDraft        = '';
  PSEndLine      = 'newl'#13#10;
  PSStartPage    = 'newp'#13#10;
  PSEndPage      = 'showpage'#13#10;
  PSPreData      = '(';
  PSPostData     = ') show'#13#10;

  IBMInit       = #17;
  IBMDone       = '';
  IBMItalic     = '';
  IBMNoItalic   = '';
  IBMBold       = EpsonBold;
  IBMNoBold     = EpsonNoBold;
  IBMULine      = EpsonULine;
  IBMNoULine    = EpsonNoULine;
  IBMHQuality   = EpsonHQuality;
  IBMDraft      = EpsonDraft;
  IBMEndLine    = EpsonEndLine;
  IBMStartPage  = EpsonStartPage;
  IBMEndPage    = EpsonEndPage;


{***þ Print OutPut Errors þ***}
const
  PrintErr_NoError     = 0;
  PrintErr_Init        = 1;
  PrintErr_Write       = 2;
  PrintErr_Close       = 3;
  PrintErr_OutOfPaper  = 4;
  PrintErr_Busy        = 5;
  PrintErr_NotReady    = 6;

{***þ Print Settings record þ***}
type
  PPrintSettings = ^TPrintSettings;
  TPrintSettings = record
    Target   :Byte;        { Output target combination }
    FileName :String[79];  { Name of file to print to }
    Combo    :Byte;        { Paper component combination }
    CharsPl  :String[3];   { Characters per line }
    LinesPp  :String[2];   { Lines per page }
    Printer  :Byte;        { Printer type }
  end;

{***þ Print options window þ***
 This window lets the user spesify the following output options :
   þ Print to a file ?
   þ The filename of the file to print to.
   þ Output to Printer ?
   þ The paper component combination to print (Questionpaper, memmo and/or
     answering sheet).
   þ Enter another menu with Printer options. }
type
  PPrintOptionsWin = ^TPrintOptionsWin;
  TPrintOptionsWin = Object(TViewGroup)
    constructor Init;
    procedure   Art; virtual;
    procedure   GotFocus; virtual;
  end;

{***þ Printer options window þ***
 This window allows the user to spesify the following
   þ The Type of Printer in use
   þ The maximum amount of characters per line
   þ The maximum amount of lines per page. }
type
  PPrinterConfigWin = ^TPrinterConfigWin;
  TPrinterConfigWin = Object(TViewGroup)
    constructor Init;
    procedure   Art; virtual;
  end;

{***þ Print Target Oject þ***}
type
  PPrintTarget = ^TPrintTarget;
  TPrintTarget = Object(TObject)
    ColsperLine :Byte;
    Column      :Byte;
    LineCount   :Byte;
    LinesPerPage:Byte;
    PageCount   :Byte;
    Attributes  :Byte;
    ErrorValue  :Byte;
    constructor Init(Lines, Cols :Byte);
    procedure Advance(Pages, Lines, Cols :Integer); virtual;
    procedure Error(Code :Integer); virtual;
    procedure SetAttr(Attr :Byte; On :Boolean); virtual;
    procedure SendText(Text :String); virtual;
  end;

{***þ File Print Target Oject þ***}
type
  PFilePrintTarget = ^TFilePrintTarget;
  TFilePrintTarget = Object(TPrintTarget)
    TextFile :Text;
    constructor Init(Lines, Cols :Byte; FileName :String);
    destructor  Done; virtual;
    procedure   Advance(Pages, Lines, Cols :Integer); virtual;
    procedure   Error(Code :Integer); virtual;
    procedure   SendText(Text :String); virtual;
  end;

{***þ Printer Target Oject þ***}
type
  PPrinter = ^TPrinter;
  TPrinter = Object(TPrintTarget)
    Emulation :Byte;
    TextAttr  :Byte;
    constructor Init(Lines, Cols :Byte; AEmulation :Byte);
    destructor  Done; virtual;
    procedure Advance(Pages, Lines, Cols :Integer); virtual;
    procedure Error(Code :Integer); virtual;
    procedure SetAttr(Attr :Byte; On :Boolean); virtual;
    procedure SendText(Text :String); virtual;
    procedure ErrorOnStatus(Status :Byte);
    function  GetStatus :Byte;
    procedure SendCode(Code :String);
  end;


{ When all settings are set this procedure is called to start printing
  the document(s) }
  procedure StartPrinting;

{***þInitialized PrintSettings variable þ***}
const
  PrintSettings:TPrintSettings =
    (Target   :3;
     FileName :'DEMO.PAP';
     Combo    :QuestionPaper+AnsweringSheet+Memmo;
     CharsPL  :'70';
     LinesPP  :'55';
     Printer  :EpsonPrinter);


Implementation
  uses sGraph, Graph, sProcs, TMData, Dos, Quests, Strings, Printer, sInts;

{****************************************************************************}
{*  TPrintOptionsWin                                                        *}
{****************************************************************************}
constructor TPrintOptionsWin.Init;
  var B :TBounds;
      View :PView;
  const ValidFileChars = [#32..#255] -
                         [';','''','=','+','<','>','|','"','[',']'];
begin
  B.Assign(90, 150, GetMaxX-92, 360);
  inherited Init(B);
  ViewOptions := ViewOptions or voSelectable;
  Lock;
  { Add Output Destination Selection Cluster }
  B.Assign(20, 60, 140, 100);
  Append(New(PCluster, Init(B,
           NewLPString('Afvoer na Lˆer',
           NewLPString('Afoer na drukker',
           nil)), HcClustPrnTarget)));
  { Add FileName InputLine }
  B.Assign(Size.X-200, 60, Size.X-20, 80);
  View := New(PInputLine, Init(B, 79, '', ValidFileChars));
  View^.HelpCtx := HcILinePrnToFile;
  Append(View);
  { Add Output Destination Selection Cluster }
  B.Assign(20, 120, 165, 160);
  Append(New(PCluster, Init(B,
           NewLPString('Druk Vraestel Uit',
           NewLPString('Druk Antwoordblad Uit',
           NewLPString('Druk Memmorandum Uit',
           nil))), HcClustCombo)));
  { Add Buttons }
  B.Assign(20, Size.Y-30, 120, Size.Y-15);
  Append(New(PButton, Init(B, 'Begin Druk', cmStartPrinting, hcButStartPrn)));
  B.Assign(130, Size.Y-30, Size.X-240, Size.Y-15);
  Append(New(PButton, Init(B, 'Bronlˆer', cmLoadSetFile, hcButSourcefile)));
  B.Assign(Size.X-230, Size.Y-30, Size.X-110, Size.Y-15);
  Append(New(PButton, Init(B, 'Konfigurasie', cmPrinterConfig, hcButPrnConfig)));
  B.Assign(Size.X-100, Size.Y-30, Size.X-20, Size.Y-15);
  Append(New(PButton, Init(B, 'Verlaat', cmDonePrnWin, hcButPrnLeave)));
  SelectNext;
  Unlock;
end; { TPrintOptionsWin.Init }

procedure TPrintOptionsWin.Art;
  var P :PBitImage;
begin
  { Frame and title }
  Platform(0, 0, Size.X, Size.Y, $F808);
  Platform(5, 5,  Size.X-5, Size.Y-5, LowerGrey);
  Platform(6, 6,  Size.X-6, 26, $F002);
  WriteStrXY(Size.X shr 1, 12, $1E, 2, 5, JustCenter, False,
    'Uitdruk Opsies vir '+PaperData^.GetTruncFileName);
  { Divider Lines & Titles }
  WriteStrXY(Size.X shr 1, 45, $1F, 0, 1, JustCenter, False,
    'Afvoer Teiken');
  Line3D(10, 50, Size.X-10, 50, $8F);
  WriteStrXY(Size.X shr 1, 105, $1F, 0, 1, JustCenter, False,
    'Vraestel Komponent Kombinasie');
  Line3D(10, 110, Size.X-10, 110, $8F);
  Line3D(10, Size.Y-40, Size.X-10, Size.Y-40, $8F);
  { Filename label }
  WriteStrXY(Size.X-250, 70, $0E, 2, 4, JustLeft+JustCenterY, False,
    'Naam van Lˆer:');
  P := PBitImage(GetResource('Printer'));
  if P <> nil then
  begin
    P^.Put(10, 25, XorPut);
    Dispose(P, Done);
  end;
  P := PBitImage(GetResource('Papers1'));
  if P <> nil then
  begin
    P^.Put(210, 125, XorPut);
    P^.Put(250, 125, XorPut);
    P^.Put(290, 125, XorPut);
    Dispose(P, Done);
  end;
end; { TPrintOptionsWin.Art }

procedure TPrintOptionsWin.GotFocus;
begin
  PutMessage(spCommand, cmStatustext,
    NewStr('Testmaker afvoer modus: Spesifiseer afvoer opsies F1 - Hulp'));
end;


{****************************************************************************}
{*  TPrinterList                                                            *}
{*  This is a scrollable list of available printers                         *}
{****************************************************************************}
type
  PPrinterList = ^TPrinterList;
  TPrinterList = Object(TListScroller)
    constructor Init;
    function    Count :Word; virtual;
    function    DataSize :Word; virtual;
    function    GetString(Index :Word) :String; virtual;
    procedure   Getdata(var Rec); virtual;
    procedure   SetData(var Rec); virtual;
  end;

constructor TPrinterList.Init;
  var B :TBounds;
begin
  B.Assign(20, 125, 240, 165);
  Inherited Init(B, nil);
  HelpCtx := hcPrinterList;
end;

function TPrinterList.Count :Word;
begin
  Count := 5;
end;

function TPrinterList.GetString(Index :Word) :String;
begin
  case Index of
    0 :GetString := 'ASCII Teks drukker';
    1 :GetString := 'Epson en versoenbares';
    2 :GetString := 'Hewlet-Packard LaserJet en versoenbares';
    3 :GetString := 'ADOBE(R) PostScript(R)';
    4 :GetString := 'IBM Drukker';
  end;
end; { TPrinterList.GetString }

procedure TPrinterList.GetData(var Rec);
begin
  Byte(Rec) := CurStr;
end; { TPrinterList.Getdata }

procedure TPrinterList.SetData(var Rec);
begin
  ScrollTo(Byte(Rec));
end; { TPrinterList.SetData  }

function TPrinterList.DataSize :Word;
begin
  DataSize := Sizeof(Byte);
end;

{****************************************************************************}
{*  TPrintConfigWin                                                         *}
{****************************************************************************}
constructor TPrinterConfigwin.Init;
  var B :TBounds;
      View :PView;
begin
  B.Assign(120, 170, 500, 350);
  inherited Init(B);
  ViewOptions := ViewOptions or voSelectable;
  Lock;
  { Characters per line inputline }
  B.Assign(130, 55, 190, 75);
  View := New(PInputLine, Init(B, 3, '', ['0'..'9']));
  View^.HelpCtx := hcColsPerLine;
  Append(View);
  { Lines per page inputline }
  B.Assign(300, 55, 350, 75);
  View := New(PInputLine, Init(B, 2, '', ['0'..'9']));
  View^.HelpCtx := hcLinesPerPage;
  Append(View);
  { Printer List }
  Append(New(PPrinterList, Init));
  { Buttons }
  B.Assign(Size.X-120, Size.Y-60, Size.X-20, Size.Y-45);
  Append(New(PButton, Init(B, 'Aanvaar', cmAcceptPrnCnf, hcButPrnCnfAccept)));
  B.Assign(Size.X-120, Size.Y-35, Size.X-20, Size.Y-20);
  Append(New(PButton, Init(B, 'Kanselleer', cmCancelPrnCnf, hcButPrnCnfCancel)));
  SelectNext;
  Unlock;
end; { TPrinterConfigwin.Init }

procedure TPrinterConfigWin.Art;
begin
  { Frame and title }
  Platform(0, 0, Size.X, Size.Y, $F808);
  Platform(5, 5,  Size.X-5, Size.Y-5, LowerGrey);
  Platform(6, 6,  Size.X-6, 26, $F002);
  WriteStrXY(Size.X shr 1, 12, $1E, 2, 5, JustCenter, False,
    'Drukker konfigurasie');
  { Divider Lines & Titles }
  WriteStrXY(Size.X shr 1, 40, $1F, 0, 1, JustCenter, False, 'Dokument');
  Line3D(10, 45, Size.X-10, 45, $8F);
  WriteStrXY((Size.X-120) shr 1, 95, $1F, 0, 1, JustCenter, False, 'Drukker');
  Line3D(10, 100, Size.X-10, 100, $8F);
  Line3D(Size.X-130, 102, Size.X-130, Size.Y-10, $8F);
  { Labels }
  WriteStrXY(20, 60, $0E, 2, 4, JustLeft, False, 'Karakters per lyn');
  WriteStrXY(200, 60, $0E, 2, 4, JustLeft, False, 'Lyne per bladsy');
  WriteStrXY(20, 110, $0E, 2, 4, JustLeft, False, 'Drukker tipe');
end; { TPrinterConfigWin.Art }

{****************************************************************************}
{*  TPrintTarget                                                            *}
{****************************************************************************}
constructor TPrintTarget.Init(Lines, Cols :Byte);
begin
  Inherited Init;
  LinesPerPage := Lines;
  ColsPerLine := Cols;
end;

procedure TPrintTarget.Advance(Pages, Lines, Cols :Integer);
begin
  Abstract('TPrintTarget.Advance')
end; { TPrintTarget.Advance }

procedure TPrintTarget.SetAttr(Attr :Byte; On :Boolean);
begin
end; { TPrintTarget.SetAttr }

procedure TPrintTarget.SendText(Text :String);
begin
  Abstract('TPrintTarget.SendText')
end; { TPrintTarget.SendText }

procedure TPrintTarget.Error(Code :Integer);
begin
  ErrorValue := Code;
end; { TPrintTarget.Error }

{****************************************************************************}
{*  TFilePrintTarget                                                        *}
{****************************************************************************}
constructor TFilePrintTarget.Init(Lines, Cols :Byte; FileName :String);
begin
  Inherited Init(Lines, Cols);
  Assign(TextFile, FileName);
  {$I-}
  Rewrite(TextFile);
  {$I+}
  if IOResult <> 0 then Error(PrintErr_Init);
end;

destructor TFilePrintTarget.Done;
begin
  {$I-}
  Close(TextFile);
  if IOResult <> 0 then Error(PrintErr_Close);
  {$I+}
  Inherited Done;
end;

{ Anvances the current file page position an certain amount of
  Pages, Lines and/or columns }
procedure TFilePrintTarget.Advance(Pages, Lines, Cols :Integer);
  var I :Byte;
begin
  if ErrorValue <> PrintErr_NoError then Exit;
  {$I-}
  if Pages > 0 then
  begin
    Column := 0;
    for I := 1 to LinesPerPage-LineCount+1 do Writeln(TextFile);
    SendText(SPad('-- Nuwe Bladsy', '-', ColsPerLine));
    Writeln(TextFile);
    Column := 0;
    LineCount := 0;
    Inc(PageCount);
  end; {if}
  if Lines > 0 then
  begin
    for I := 1 to Lines do
    begin
      Inc(LineCount);
      if LineCount >= LinesPerPage then Advance(1, 0, 0)
      else Writeln(TextFile);
    end;
    Column := 0;
  end;
  if Cols > 0 then
    for I := 1 to Cols do
    if Column < ColsPerLine then
    begin
      Write(TextFile, ' ');
      Inc(Column);
    end; {if}
  {$I+}
  if IOResult <> 0 then Error(PrintErr_Write);
end; { TFilePrintTarget.Advance }

procedure TFilePrintTarget.Error(Code :Integer);
  var S :String;
      B :TBounds;
begin
  if ErrorValue <> PrintErr_NoError then Exit;
  ErrorValue := Code;
  case Code of
    1 :S := 'Fout met open van lˆer: '+TextRec(TextFile).Name;
    2 :S := 'Fout met skryf na lˆer: '+TextRec(TextFile).Name;
    3 :S := 'Fout met toemaak van lˆer: '+TextRec(TextFile).Name;
  end;
  B.Assign(125,200,515,300);
  MessageWindow(B, #3+S, mwfError+mwfOk);
end; { TFilePrintTarget.Error }

procedure TFilePrintTarget.SendText(Text :String);
begin
  if ErrorValue <> PrintErr_NoError then Exit;
  {$I-}
  SSetLen(Text, MaxInt(0, MinInt(Length(Text), ColsPerLine-Column)));
  Write(TextFile, Text);
  Inc(Column, Length(Text));
  {$I+}
  if IOResult <> 0 then Error(PrintErr_Write);
end; { TFilePrintTarget.SendText }

{****************************************************************************}
{*  TPrinter                                                                *}
{****************************************************************************}
{ Initializes the Printer by setting the LPT1 Device to raw mode
  and sending the initialization code for the printer.
  If the printer status check fails an error is produced }
constructor TPrinter.Init(Lines, Cols :Byte; AEmulation :Byte);
  var Status :byte;

  { Sets the Device to raw mode using Dos function calls }
  procedure DeviceToRaw(var Device :Text); assembler;
  asm
	    LES   DI, Device
	    MOV   BX, WORD PTR ES:[DI]
	    MOV   AX, 4400H
	    INT   21H
	    TEST  DX, 0080H
 	    JZ    @End
  	  OR    DL, 20H
  	  MOV   DH, DH
  	  MOV   AX, 4401H
	    INT   21H
    @End:
  end;

begin
  Inherited Init(Lines, Cols);
  { Check status }
  Status := GetStatus;
  ErrorOnStatus(Status);
  if Status <> Prn_Ready then
  begin
    Error(PrintErr_NotReady);
    Exit;
  end;
  DeviceToRaw(Lst);
  { Get emulation used }
  Emulation := AEmulation;
  { Send Initialization Code to LPT1 device }
  case Emulation of
    IBMPrinter,
    EpsonPrinter   :
      begin
        SendCode(EpsonInit);
        SendCode(EpsonHQuality);
      end;
    HPLaserPrinter :SendCode(HPInit);
    PostScrPrinter :
      begin
        SendCode(PSInit1); SendCode(PSInit2);
        SendCode(PSStartPage);
      end;
  end; {case}
end; { TPrinter.Init }

destructor TPrinter.Done;
begin
  { Sends code to the printer to indicate a end of print job condition }
  case Emulation of
    ASCIIPrinter   :if LineCount > 0 then SendCode(ASCIIEndPage);
    IBMPrinter     :
      begin
        if LineCount > 0 then SendCode(IBMEndPage);
        SendCode(IBMDone);
      end;
    EpsonPrinter   :
      begin
        if LineCount > 0 then SendCode(EpsonEndPage);
        SendCode(EpsonDone);
      end;
    HPLaserPrinter :
      begin
        if LineCount > 0 then SendCode(HPEndPage);
        SendCode(HPDone);
      end;
    PostScrPrinter :
      begin
        if LineCount > 0 then SendCode(PSEndPage);
        SendCode(PSDone);
      end;
  end; {case}
  inherited Done;
end; { TPrinter.Done }

procedure TPrinter.Advance(Pages, Lines, Cols :Integer);
  var I, PrevAttr :Byte;

  { Sends a Form Feed Instruction to the Printer }
  procedure NewPage;
  begin
    case Emulation of
      ASCIIPrinter,
      EpsonPrinter,
      HPLaserPrinter,
      IBMPrinter     :SendCode(ASCIIEndPage);
      PostScrPrinter :begin SendCode(PSEndPage); SendCode(PSStartPage); end;
    end; {case}
  end;{ sub proc newpage }

  { Sends Line Feed instruction to the Printer }
  procedure NewLine;
  begin
    case Emulation of
      ASCIIPrinter,
      EpsonPrinter,
      HPLaserPrinter,
      IBMPrinter     :SendCode(ASCIIEndLine);
      PostScrPrinter :SendCode(PSEndLine);
    end; {case}
  end; { sub proc NewLine }

begin
  if ErrorValue <> PrintErr_NoError then Exit;
  PrevAttr := TextAttr;
  SetAttr($F, False);
  if Pages > 0 then
  begin
    NewPage;
    Column := 0;
    LineCount := 0;
    Inc(PageCount);
  end; {if}
  if Lines > 0 then
  begin
    for I := 1 to Lines do
    begin
      Inc(LineCount);
      if LineCount >= LinesPerPage then Advance(1, 0, 0)
      else NewLine;
    end; {for}
    Column := 0;
  end; {if}
  if Cols > 0 then SendText(SFill(' ', Cols));
  SetAttr(PrevAttr, True);
end; { TPrinter.Advance }

{ Send codes to the printer to select a text attribute
  such as Bold or Italics }
procedure TPrinter.SetAttr(Attr :Byte; On :Boolean);
  var S: String;

  procedure Underline;
  begin
    case emulation of
      EpsonPrinter   :S := S+EpsonULine;
      HPLaserPrinter :S := S+HPULine;
      IBMPrinter     :S := S+IBMULine;
      PostScrPrinter :S := S+PSULine;
    end;
    TextAttr := TextAttr or Style_UnderLine;
  end; { sub proc Underline }

  procedure NoUnderline;
  begin
    case emulation of
      EpsonPrinter   :S := S+EpsonNoULine;
      HPLaserPrinter :S := S+HPNoULine;
      IBMPrinter     :S := S+IBMNoULine;
      PostScrPrinter :S := S+PSNoULine;
    end; {case}
    TextAttr := TextAttr and not Style_UnderLine;
  end; {NoUnderline}

  procedure Bold;
  begin
    case emulation of
      EpsonPrinter   :S := S+EpsonBold;
      HPLaserPrinter :S := S+HPBold;
      IBMPrinter     :S := S+IBMBold;
      PostScrPrinter :S := S+PSBold;
    end; {case}
    TextAttr := TextAttr or Style_Bold;
  end; { sub proc bold }

  procedure NoBold;
  begin
    case emulation of
      EpsonPrinter   :S := S+EpsonNoBold;
      HPLaserPrinter :S := S+HPNoBold;
      IBMPrinter     :S := S+IBMNoBold;
      PostScrPrinter :S := S+PSNormal;
    end; {case}
    TextAttr := TextAttr and not Style_UnderLine;
  end; { sub proc NoBold }

  procedure Italic;
  begin
    case emulation of
      EpsonPrinter   :S := S+EpsonItalic;
      HPLaserPrinter :S := S+HPItalic;
      IBMPrinter     :S := S+IBMItalic;
      PostScrPrinter :S := S+PSItalic;
    end; {case}
    TextAttr := TextAttr or Style_Italic;
  end; { sub proc Italic }

  procedure NoItalic;
  begin
    case emulation of
      EpsonPrinter   :S := S+EpsonNoItalic;
      HPLaserPrinter :S := S+HPNoItalic;
      IBMPrinter     :S := S+IBMNoItalic;
      PostScrPrinter :S := S+PSNormal;
    end; {case}
    TextAttr := TextAttr and not Style_Italic;
  end; { sub proc NoItalic }

  procedure BoldItalic;
  begin
    if emulation = PostScrPrinter then S := S+PSBoldItalic;
  end; { sub proc BoldItalic }

begin
  S := '';
  if Attr and Style_Underline <> 0 then
    if On then Underline else NoUnderline;
  if Attr and Style_Bold <> 0 then
    if On then Bold else NoBold;
  if Attr and Style_Italic <> 0 then
    if On then Italic else NoItalic;
  if (TextAttr and Style_Italic <> 0) and
     (TextAttr and Style_Bold <> 0) then BoldItalic;
  SendCode(S);
end; { TPrinter.SetAttr }

procedure TPrinter.SendText(Text :String);

 { Strips the most significant bit of each character in text
   and do some conversion to ensure that extended characters is somehow
   printed. }
  procedure StripMSBs;
    var I :Byte;
  begin
    for I := 1 to Length(Text) do
      if Text[I] > #127 then
      case Text[I] of
        'Í'     :Text[I] := '=';
        'Ä'     :Text[I] := '-';
        '‹'     :Text[I] := 'i';
        '„'     :Text[I] := 'a';
        'ˆ','‰' :Text[I] := 'e';
        else     Text[I] := ' ';
      end; {case}
  end; { sub proc StripMSBs }

begin { TPrinter.SendText }
  if ErrorValue <> PrintErr_NoError then Exit;
  ErrorOnStatus(GetStatus);
  {$I-}
  SSetLen(Text, MaxInt(0, MinInt(Length(Text), ColsPerLine-Column)));
  case Emulation of
    IBMPrinter  :;
    else StripMSBs;
  end;
  if ErrorValue = PrintErr_NoError then
  begin
    if Emulation = PostScrPrinter then Write(Lst, PSPreData);
    Write(Lst, Text);
    if Emulation = PostScrPrinter then Write(Lst, PSPostData);
    Inc(Column, Length(Text));
  end;
  {$I+}
  If IOResult <> 0 then Error(PrintErr_Write);
  ErrorOnStatus(GetStatus);
end; { TPrinter.SendText }

{ Called whenever an error occurs. An error dialog will appear. }
procedure TPrinter.Error(Code :Integer);
  var S :String;
      B :TBounds;
begin
  if ErrorValue <> PrintErr_NoError then Exit;
  ErrorValue := Code;
  case Code of
    PrintErr_Init       :S := 'Fout met inisialisering van drukker.';
    PrintErr_Write      :S := 'Fout met afvoer na drukker.';
    PrintErr_OutOfPaper :S := 'Drukker rapporteer fout: Geen papier.';
    PrintErr_Busy       :S := 'Drukker rapporteer besig.';
    PrintErr_NotReady   :S := 'Drukker is nie gereed.';
    else exit;
  end;
  B.Assign(125,200,515,300);
  MessageWindow(B, #3+S, mwfError+mwfOk);
end; { TPrinter.Error }

procedure TPrinter.ErrorOnStatus(Status :Byte);
  var Err :Byte;
begin
  if Status <> Prn_Ready then
  begin
    Err := PrintErr_NoError;
    if Status and Prn_OutOfPaper <> 0 then Err := PrintErr_OutOfPaper
    else if Status and Prn_Selected = 0 then Err := PrintErr_Init
    else if Status and Prn_IOError <> 0 then Err := PrintErr_Write;
    if Err <> PrintErr_NoError then Error(Err);
  end; {if}
end; { TPrinter.ErrorOnStatus }

function TPrinter.GetStatus :Byte; assembler;
asm
  MOV  AH, 02
  MOV  DX, 0
  Int  IntPrinter
  MOV  AL, AH
end; { TPrinter.GetStatus }

procedure TPrinter.SendCode(Code :String);
begin
  if ErrorValue <> PrintErr_NoError then Exit;
  ErrorOnStatus(GetStatus);
  {$I-}
  if ErrorValue = PrintErr_NoError then Write(Lst, Code);
  {$I+}
  If IOResult <> 0 then Error(PrintErr_Write);
  ErrorOnStatus(GetStatus);
end; { TPrinter.SendCode }

{****************************************************************************}
{*  TQuestionPaperPrinter                                                   *}
{*    This object uses the TPrintTarget object as well as the internal      *}
{*    paper data to print a Question Paper                                  *}
{****************************************************************************}
type
  TQuestionPaperPrinter = object
    AfdNum      :Char; { Current "Afdeling" }
    QuestNum    :Byte; { Current question number }
    SubQuestNum :Byte; { Current sub-question number }
    Target      :PPrintTarget; { Printer object }
    constructor PrintAll(Printer :PPrintTarget);
    private
      procedure PrintAfd(Item :PPaperItem_Data);
      procedure PrintColABN(Item :PPaperItem_Data);
      procedure PrintColumnAB(Item :PPaperItem_Data);
      procedure PrintHeader;
      procedure PrintMessage(Item :PPaperItem_Data);
      procedure PrintMonkey(Item :PPaperItem_Data);
      procedure PrintTerm(Item :PPaperItem_Data);
      procedure PrintMarks;
  end;

{ This constructor is called to activate the object and to do all the printing }
constructor TQuestionPaperPrinter.PrintAll(Printer :PPrintTarget);
  { A foreach support sub procedure that will call the correct
    object method for each item in the data list }
  procedure PrintItem(Item :PPaperItem_Data); far;
  begin
    { Each new item starts with a space }
    with Target^ do if LineCount > 0 then Advance(0, 1, 0);
    { Select item }
    case Item^.ItemType of
      TMAfdeling :PrintAfd(Item);
      TMColABN   :PrintColABN(Item);
      TMColumnAB :PrintColumnAB(Item);
      TMMessage  :PrintMessage(Item);
      TMMonkey   :PrintMonkey(Item);
      TMTerms    :PrintTerm(Item);
    end; { case }
  end; { sub-procedure PrintItem }

begin { TQuestionPaperPrinter.PrintAll }
  Target := Printer;
  AfdNum := 'A';
  QuestNum := 1;
  PrintHeader;
  PaperData^.Items^.ForEach(@PrintItem);
  PrintMarks;
end; { TQuestionPaperPrinter.PrintAll }

{ Prints a "Afdeling" Item }
Procedure TQuestionPaperPrinter.PrintAfd(Item :PPaperItem_Data);
  var S :String;
begin
  with Target^ do
  begin
    { Underlined Bold Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String to be printed }
    S := Item^.Signature+' '+AfdNum+' - '+PAfdeling_Data(Item)^.Data;
    { Center the text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 1, 0);
    SetAttr(Style_UnderLine, False);
    SendText(SFill(#196, ColsPerLine));
    { Next Line }
    Advance(0, 1, 0);
    SetAttr($F, False);
  end;
  Inc(AfdNum);
  QuestNum := 1;
end; { TQuestionPaperPrinter.PrintAfd }

{ Prints a Four Column Question Type }
Procedure TQuestionPaperPrinter.PrintColABN(Item :PPaperItem_Data);

  var I :Byte;
      S :String;

  { Adds line drawing characters to the string at the relevant positions
    to create each line of the column }
  procedure AddLines(var S :String; C1, C2, C3 :Char);
  begin
    S[0] := Char(Target^.ColsPerLine);
    S[1] := C1;
    S[Length(S)*2 div 3] := C2;
    S[Length(S)] := C3;
  end;

  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubColABN); far;
    var SW, IW :TWrapper;
  begin
    with Target^ do
    begin
      S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'. ';
      { Assign word wrappers }
      with SubItem^ do
      begin
        SW.AssignStr(#5+S+Statement[1]+' '+StateMent[2],
           ColsPerLine*2 div 3 -4, Length(S));
        IW.AssignStr(#5'A. '+Items[1]+#13#5'B. '+Items[2],
          ColsPerLine-ColsPerline*2 div 3 - 3, 3);
      end;
      { Print Each Line of the current sub question }
      while (not SW.IsDone) or (not IW.IsDone) do
      begin
        S := SFill(' ', ColsPerLine);
        Insert(SW.NextLine, S, 3);
        Insert(IW.NextLine, S, ColsPerline*2 div 3 + 2);
        S[0] := Char(ColsPerLine);
        AddLines(S, '³', '³', '³');
        SendText(S);
        Advance(0, 1, 0);
      end; {while}
      Inc(SubQuestNum);
    end; {with}
  end; { sub-procedure DoSubItem }

begin { TQuestionPaperPrinter.PrintColABN }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Betrekkings kolomme';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    SetAttr($F, False);
    { Print Column Header }
      { First Line }
    S := SFill('Ä', ColsPerLine);
    AddLines(S, 'Ú', 'Â', '¿');
    SendText(S);
    Advance(0, 1, 0);
      { Second Line }
    S := '  Stelling';
    S := SPad(S, ' ', ColsPerLine);
    Insert('Items', S, Length(S)*2 div 3 + 2);
    AddLines(S, '³', '³', '³');
    SendText(S);
    Advance(0, 1, 0);
      { Third Line }
    S := SFill('Ä', ColsPerLine);
    AddLines(S, 'Ã', 'Å', '´');
    SendText(S);
    Advance(0, 1, 0);
    { Print Each Sub Question }
    PColABN_Data(Item)^.List^.ForEach(@DoSubItem);
    { Close Column }
    S := SFill('Ä', ColsPerLine);
    AddLines(S, 'À', 'Á', 'Ù');
    SendText(S);
    Advance(0, 1, 0);
    with PColABN_Data(Item)^  do
    begin
      { Print Marks }
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      SetAttr(Style_Italic+Style_Underline, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($0F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TQuestionPaperPrinter.PrintColABN }

{ Prints a two column question type }
Procedure TQuestionPaperPrinter.PrintColumnAB(Item :PPaperItem_Data);
  var S :String;

  { Adds Column A text to Txt }
  procedure AddColumnA(SubItem :PSubColumnAB; var Txt :PChar;
                       var Size :Word; var Indent :Byte);
    var I      :Byte;
  begin
    if SubItem^.ColumnA[1] = '' then
    begin
      Txt := nil;
      Size := 0;
      Exit;
    end;
    { Calculate Size }
    Size := 10;
    for I := 1 to 4 do Inc(Size, Length(SubItem^.ColumnA[I]+' '));
    { Get Memmory }
    StrGetMem(Txt, Size);
    if SubItem^.ColumnA[1] <> '' then
      StrPCat(Txt, SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'. ');
    Indent := StrLen(Txt);
    for I := 1 to 4 do StrPCat(Txt, #5+SubItem^.ColumnA[I]+' ');
  end; { sub proc AddcolumnA }

  { Adds Column B text to Txt }
  procedure AddColumnB(SubItem :PSubColumnAB; var Txt :PChar; var Size :Word);
    var I :Byte;
  begin
    if SubItem^.ColumnB[1] = '' then
    begin
      Txt := nil;
      Size := 0;
      Exit;
    end;
    { Calculate Size }
    Size := 3;
    for I := 1 to 4 do Inc(Size, Length(SubItem^.ColumnB[I]+' '));
    { Get Memmory }
    StrGetMem(Txt, Size);
    if SubItem^.ColumnB[1] <> '' then
      StrPCat(Txt, Char(Ord(SubQuestNum)+ord('A')-1)+'. ');
    for I := 1 to 4 do StrPCat(Txt, SubItem^.ColumnB[I]+' ');
  end; { AddColumnB }

  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubColumnAB); far;
    var ItemB  :PSubColumnAB;
        SizeA, SizeB :Word;
        TxtA, TxtB :PChar;
        WA, WB :TWrapper;
        IndentA :Byte;
  begin
    with PColumnAB_Data(Item)^ do
      ItemB := List^.At(Ord(Order[Char(SubQuestNum+64)])-65);
    { Get Text and Buffer Sizes }
    AddColumnA(SubItem, TxtA, SizeA, IndentA);
    AddColumnB(ItemB, TxtB, SizeB);
    with Target^ do
    begin
      { Assign Wrappers }
      WA.AssignText(TxtA, ColsPerLine*5 div 8 - 1, IndentA);
      WB.AssignText(TxtB, ColsPerLine*3 div 8 - 1, 3);
      { Print Each Line }
      while (not WA.IsDone) or (not WB.IsDone) do
      begin
        S := WA.NextLine;
        S := SPad(S, ' ', ColsperLine*5 div 8 - 1);
        SSetLen(S, ColsPerLine*5 div 8 - 1);
        S := S+'³ ';
        S := S+WB.NextLine;
        S := SPad(S, ' ', ColsPerLine);
        SSetLen(S, ColsPerLine);
        SendText(S);
        Advance(0, 1, 0);
      end;{while}
      { Add Column Line for empty line }
      S := SFill(' ', ColsPerLine);
      S[ColsperLine*5 div 8] := '³';
      SendText(S);
      Advance(0, 1, 0);
    end;{with}
    { Dispose Text }
    StrFreemem(TxtA, SizeA);
    StrFreemem(TxtB, SizeB);
    Inc(SubQuestNum);
  end; { sub proc DoSubItem }


begin
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Kolom A & B';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    SetAttr($F, False);
    with PColumnAB_Data(Item)^ do
    begin
      { Draw Column Topic and Lines }
      S := 'Kolom A';
      S := SPad(S, ' ', ColsPerLine*5 div 8);
      SSetLen(S, ColsPerLine*5 div 8);
      S := S+' Kolom B';
      S := SPad(S, ' ', ColsPerLine);
      SSetLen(S, ColsPerLine);
      SendText(S);
      Advance(0, 1, 0);
      S := SFill('Ä', ColsPerLine);
      S[ColsperLine*5 div 8] := 'Â';
      SendText(S);
      Advance(0, 1, 0);
      List^.ForEach(@DoSubItem);
      Advance(0, 1, 0);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Italic Text }
      SetAttr(Style_Italic+Style_Underline, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TQuestionPaperPrinter.PrintColumnAB }

{ Prints the Header of the Question Paper }
Procedure TQuestionPaperPrinter.PrintHeader;
  var S :String;
begin
  with Target^ do
  begin
    { Set Bold Style }
    SetAttr(Style_Bold, True);
    { Print a DoubleLine with the word "Vraestel" in center }
    S := SFill(#205, ColsPerLine);
    Insert(' Vraestel ', S, (ColsPerLine-10) shr 1 + 1);
    SendText(S);
    Advance(0, 1, 0); { To Next Line }
    { Write all Header Data in a spesific format }
    with PaperData^.Header do
    begin
      { Write Subject and Paper Number }
      SendText(' '+Subject);
      SendText(' '+Number);
      { Flush Text Right }
      Advance(0, 0, ColsPerLine-Length(Standard+Grade)-Column-2);
      SendText(Standard);
      SendText(' '+Grade);
      { Next Line second column }
      Advance(0, 1, 1);
      SendText(Date);
      { Center Text }
      Advance(0, 0,
       (Column + ColsPerLine-Length(Setter)-21-Length(Time)) shr 1 - Column);
      SendText('Tyd: '+Time);
      { Flush Text Right }
      Advance(0, 0, ColsPerLine-Length(Setter)-Column-16);
      SendText('Opgestel deur: '+Setter);
    end; { PrintHeader }
    { Print a DoubleLine }
    Advance(0, 1, 0);
    SendText(SFill(#205, ColsPerLine));
    { Normal Text }
    Advance(0, 1, 0);
    SetAttr($F, False);
  end; { with }
end; { TQuestionPaperPrinter.PrintHeader }

Procedure TQuestionPaperPrinter.PrintMessage(Item :PPaperItem_Data);
  var I :Byte;
      Text :PChar;
      W :TWrapper;

begin
  { Get memmory to concat all the strings of the TTMessage record }
  StrGetMem(Text, sizeof(TTMessage));
  { Concatenates all the strings returning Text }
  with PMessage_Data(Item)^.Data do
    for I := 1 to 5 do StrPCat(Text, Message[I]+' ');
  with Target^ do
  begin
    { Assign Wrapper }
    W.AssignText(Text, ColsPerLine-2, 0);
    { Bold+Italic Text }
    SetAttr(Style_Bold+Style_Italic, True);
    { Print each line op the wrapper }
    while not W.IsDone do
    begin
      SendText('* '+W.NextLine);
      Advance(0, 1, 0);
    end;
    { Normal Text }
    SetAttr($F, False);
  end;
  StrFreeMem(Text, Sizeof(TTMessage));
end; { TQuestionPaperPrinter.PrintMessage }

{ Prints a Monkey Puzzle Type Question }
Procedure TQuestionPaperPrinter.PrintMonkey(Item :PPaperItem_Data);
  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubMonkey); far;
    var Question, Options :PChar;
        QBufLen, OBufLen :Word;
        I, C :Byte;
        QW, OW :TWrapper; { Question- & Option wrapper }
  begin
    { Detemine buffer lengths needed to store the question and options }
    QBufLen := 8;
    OBufLen := 0;
    for I := 1 to 3 do Inc(QBufLen, Length(SubItem^.Question[I])+1);
    for I := 1 to 5 do Inc(OBufLen, Length(SubItem^.Options[I])+5);
    { Get Memmory for Question & Option Text }
    StrGetMem(Question, QBuflen);
    StrGetMem(Options, OBuflen);
    StrPCat(Question, #5+SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'. ');
    C := StrLen(Question)-1;
    for I := 1 to 3 do StrPCat(Question, SubItem^.Question[I]+' ');
    for I := 1 to 5 do if SubItem^.Options[I] <> '' then
      StrPCat(Options, #13#5+Char(I+64)+'. '+SubItem^.Options[I]);
    with Target^ do
    begin
      { Assign wrappers }
      QW.AssignText(Question, ColsPerLine, C);
      OW.AssignText(Options, ColsPerLine-C, 3);
      { Print Sub-Question }
      while not QW.IsDone do
      begin
        SendText(QW.NextLine);
        Advance(0, 1, 0);
      end;
      Advance(0, 0, C);
      while not OW.IsDone do
      begin
        SendText(OW.NextLine);
        Advance(0, 1, C);
      end;
      Advance(0, 1, 0);
    end; {with}
    { Free Memmory of Question- & Option Text }
    StrFreeMem(Question, QBuflen);
    StrFreeMem(Options, OBuflen);
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

 var S :String;

begin { TQuestionPaperPrinter.PrintMonkey }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' -  Multi Keuse';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    SetAttr($F, False);
    with PMonkeyPuzzle_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Italic Text }
      SetAttr(Style_Italic+Style_Underline, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TQuestionPaperPrinter.PrintMonkey }

{ Prints a Term-type question }
Procedure TQuestionPaperPrinter.PrintTerm(Item :PPaperItem_Data);

  { Prints a Sub Item }
  procedure DoSubItem(SubItem :PSubTerm); far;
    var I :Byte;
        BufLen :Word;
        Text :PChar;
        W :TWrapper;
        NumLen :Byte;
  begin
    { Calculate Text Buffer Length }
    BufLen := 10;
    for I := 1 to 3 do Inc(BufLen, Length(SubItem^.Question[I])+1);
    { Get Memmory }
    StrGetMem(Text, BufLen);
    { Get Text }
    StrPCat(Text, #5+SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'. ');
    NumLen := StrLen(Text)-1;
    for I := 1 to 3 do StrPCat(Text, SubItem^.Question[I]+' ');
    with Target^ do
    begin
      { Assign Wrapper Text }
      W.AssignText(Text, ColsPerLine, NumLen);
      { Print Wrapper Lines }
      while not W.IsDone do
      begin
        SendText(W.NextLine);
        Advance(0, 1, 0);
      end;
    end; {with}
    StrFreeMem(Text, BufLen);
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

  var S :String;

begin { TQuestionPaperPrinter.PrintTerm }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Terme vir Omskrywings';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    SetAttr($F, False);
    with PTerm_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      Advance(0, 1, 0);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Italic Text }
      SetAttr(Style_Italic+Style_Underline, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TQuestionPaperPrinter.PrintTerm }

procedure TQuestionPaperPrinter.PrintMarks;
begin
  with Target^ do
  begin
    Advance(0, 1, 0);
    SendText(SFill(#196, ColsPerLine));
    Advance(0, 1, 0);
 end; {with}
end; { TQuestionPaperPrinter.PrintMarks }

{****************************************************************************}
{*  TAnsweringSheetPrinter                                                  *}
{*    This object uses the TPrintTarget object as well as the internal      *}
{*    paper data to print a Answering Sheet                                 *}
{****************************************************************************}
type
  TAnsweringSheetPrinter = Object
    AfdNum      :Char; { Current "Afdeling" }
    QuestNum    :Byte; { Current question number }
    SubQuestNum :Byte; { Current sub-question number }
    Target      :PPrintTarget; { Printer object }
    procedure PrintAll(ATarget :PPrintTarget);
    private
      procedure PrintAfd(Item :PPaperItem_Data);
      procedure PrintColABN(Item :PPaperItem_Data);
      procedure PrintColumnAB(Item :PPaperItem_Data);
      procedure PrintHeader;
      procedure PrintMonkey(Item :PPaperItem_Data);
      procedure PrintTerm(Item :PPaperItem_Data);
  end;

{ this procedure is called to Print all the items on a answering sheet }
procedure TAnsweringSheetPrinter.PrintAll(ATarget :PPrintTarget);
  { A foreach support sub procedure that will call the correct
    object method for each item in the data list }
  procedure PrintItem(Item :PPaperItem_Data); far;
  begin
    { Select item }
    case Item^.ItemType of
      TMAfdeling :PrintAfd(Item);
      TMColABN  :PrintColABN(Item);
      TMColumnAB :PrintColumnAB(Item);
      TMMonkey   :PrintMonkey(Item);
      TMTerms    :PrintTerm(Item);
      else Exit;
    end; { case }
    with Target^ do if LineCount > 0 then Advance(0, 1, 0);
  end; { sub-procedure PrintItem }
begin
  Target := ATarget;
  AfdNum := 'A';
  QuestNum := 1;
  PrintHeader;
  PaperData^.Items^.ForEach(@PrintItem);
end; { TAnsweringSheetPrinter.PrintAll }

{ Prints a "Afdeling" indicator on the target }
procedure TAnsweringSheetPrinter.PrintAfd(Item :PPaperItem_Data);
  var S :String;
begin
  with Target^ do
  begin
    { Underlined Bold Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String to be printed }
    S := Item^.Signature+' '+AfdNum+' - '+PAfdeling_Data(Item)^.Data;
    { Center the text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    { Draw Line }
    Advance(0, 1, 0);
    SetAttr(Style_UnderLine, False);
    SendText(SFill('Ä', ColsPerLine));
    { Normal Text }
    SetAttr($F, False);
    { Next Line }
    Advance(0, 1, 0);
  end; {with}
  Inc(AfdNum);
  QuestNum := 1;
end; { TAnsweringSheetPrinter.PrintAfd }

procedure TAnsweringSheetPrinter.PrintColABN(Item :PPaperItem_Data);
  var I :Byte;
      S :String;

  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubColABN); far;
  begin
    with Target^ do
    begin
      S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.    ';
      S := S+'A    B    Beide    Geen';
      SendText(S);
      Advance(0, 1, 0);
    end; {with}
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

begin { TQuestionPaperPrinter.PrintColABN }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Betrekkings kolomme';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PColABN_Data(Item)^  do
    begin
      { Print Each Sub Question }
      List^.ForEach(@DoSubItem);
      { Print Marks }
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end; {with}
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end; {with}
  Inc(QuestNum);
end; { TAnsweringSheetPrinter.PrintColABN }

procedure TAnsweringSheetPrinter.PrintColumnAB(Item :PPaperItem_Data);
  var S :String;

  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubColumnAB); far;
  begin
    { Get Number }
    S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.  ';
    S := S+SFill('_', 4);
    with Target^ do
    begin
      SendText(S);
      Advance(0, 1, 0);
    end;
    Inc(SubQuestNum);
  end; { Sub-procedure DoSubItem }

begin { TAnsweringSheetPrinter.PrintColumnAB }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Kolom A & B';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PColumnAB_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TAnsweringSheetPrinter.PrintColumnAB }

procedure TAnsweringSheetPrinter.PrintHeader;
  var S :String;
begin
  with Target^ do
  begin
    { Set Bold Style }
    SetAttr(Style_Bold, True);
    { Print a DoubleLine with the word "Vraestel" in center }
    S := SFill(#205, ColsPerLine);
    Insert(' Antwoordblad ', S, (ColsPerLine-10) shr 1 + 1);
    SendText(S);
    Advance(0, 1, 0); { To Next Line }
    { Normal Text }
    SetAttr($F, False);
    { Write all Header Data in a spesific format }
    with PaperData^.Header do
    begin
      { Write Subject and Paper Number }
      SendText(' '+Subject);
      SendText(' '+Number);
      { Flush Text Right }
      Advance(0, 0, ColsPerLine-Length(Standard+Grade)-Column-2);
      SendText(Standard);
      SendText(' '+Grade);
      { Next Line second column }
      Advance(0, 1, 1);
      SendText(Date);
      { Center Text }
      Advance(0, 0,
       (Column + ColsPerLine-Length(Setter)-21-Length(Time)) shr 1 - Column);
      SendText('Tyd: '+Time);
      { Flush Text Right }
      Advance(0, 0, ColsPerLine-Length(Setter)-Column-16);
      SendText('Opgestel deur: '+Setter);
    end; {with}
    { Print a DoubleLine }
    Advance(0, 1, 0);
    SendText(SFill(#205, ColsPerLine));
    Advance(0, 1, 0);
    { Normal Text }
    SetAttr($F, False);
  end; {with}
end; { TAnsweringSheetPrinter.PrintHeader }

{ Prints the text neccersary }
procedure TAnsweringSheetPrinter.PrintMonkey(Item :PPaperItem_Data);
  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubMonkey); far;
    var I :Byte;
        S :String;
  begin
    S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.   ';
    for I := 1 to 5 do
      if SubItem^.Options[I] <> '' then S := S+Char(I+Ord('A')-1)+'   ';
    with Target^ do
    begin
      SendText(S);
      Advance(0, 1, 0);
    end; {with}
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

 var S :String;

begin { TQuestionPaperPrinter.PrintMonkey }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' -  Multi Keuse';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PMonkeyPuzzle_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TAnsweringSheetPrinter.PrintMonkey }

procedure TAnsweringSheetPrinter.PrintTerm(Item :PPaperItem_Data);
  var S :String;

  { Prints a Sub Item }
  procedure DoSubItem(SubItem :PSubTerm); far;
    var I :Byte;
  begin
    { Get Number }
    S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.  ';
    S := S+SFill('_', 30);
    with Target^ do
    begin
      SendText(S);
      Advance(0, 1, 0);
    end; {with}
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

begin { TQuestionPaperPrinter.PrintTerm }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Terme vir Omskrywings';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PTerm_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end; {with}
    { Normal Text }
    SetAttr($0F, False);
    Advance(0, 1, 0);
  end; {with}
  Inc(QuestNum);
end; { TAnsweringSheetPrinter.PrintTerm }

{****************************************************************************}
{*  TMemmoPrinter                                                           *}
{*    This object uses the TPrintTarget object as well as the internal      *}
{*    paper data to print a Memmo                                           *}
{****************************************************************************}
type
  TMemmoPrinter = Object
    AfdNum      :Char; { Current "Afdeling" }
    QuestNum    :Byte; { Current question number }
    SubQuestNum :Byte; { Current sub-question number }
    Target      :PPrintTarget; { Printer object }
    procedure PrintAll(ATarget :PPrintTarget);
    private
      procedure PrintAfd(Item :PPaperItem_Data);
      procedure PrintColABN(Item :PPaperItem_Data);
      procedure PrintColumnAB(Item :PPaperItem_Data);
      procedure PrintHeader;
      procedure PrintMonkey(Item :PPaperItem_Data);
      procedure PrintTerm(Item :PPaperItem_Data);
  end;

{ this procedure is called to Print all the items on a answering sheet }
procedure TMemmoPrinter.PrintAll(ATarget :PPrintTarget);
  { A foreach support sub procedure that will call the correct
    object method for each item in the data list }
  procedure PrintItem(Item :PPaperItem_Data); far;
  begin
    { Select item }
    case Item^.ItemType of
      TMAfdeling :PrintAfd(Item);
      TMColABN   :PrintColABN(Item);
      TMColumnAB :PrintColumnAB(Item);
      TMMonkey   :PrintMonkey(Item);
      TMTerms    :PrintTerm(Item);
      else Exit;
    end; { case }
    with Target^ do if LineCount > 0 then Advance(0, 1, 0);
  end; { sub-procedure PrintItem }

begin { TMemmoPrinter.PrintAll }
  Target := ATarget;
  AfdNum := 'A';
  QuestNum := 1;
  PrintHeader;
  PaperData^.Items^.ForEach(@PrintItem);
end; { TMemmoPrinter.PrintAll }

{ Prints a "Afdeling" indicator on the target }
procedure TMemmoPrinter.PrintAfd(Item :PPaperItem_Data);
  var S :String;
begin
  with Target^ do
  begin
    { Underlined Bold Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String to be printed }
    S := Item^.Signature+' '+AfdNum+' - '+PAfdeling_Data(Item)^.Data;
    { Center the text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
    SendText(SFill(#196, ColsPerLine));
    { Normal Text }
    SetAttr($F, False);
    { Next Line }
    Advance(0, 1, 0);
  end;
  Inc(AfdNum);
  QuestNum := 1;
end; { TMemmoPrinter.PrintAfd }

procedure TMemmoPrinter.PrintColABN(Item :PPaperItem_Data);
  var I :Byte;
      S :String;

  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubColABN); far;
  begin
    with Target^ do
    begin
      S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.  ';
      with SubItem^ do
      begin
        if Answer = 0 then S := S+'Geen'
        else if Answer and 1 = Answer then S := S+'A'
        else if Answer and 2 = Answer then S := S+'B'
        else if Answer and 3 = Answer then S := S+'Beide';
      end;
      SendText(S);
      Advance(0, 1, 0);
    end; {with}
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

begin { TMemmoPrinter.PrintColABN }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Betrekkings kolomme';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PColABN_Data(Item)^  do
    begin
      { Print Each Sub Question }
      List^.ForEach(@DoSubItem);
      { Print Marks }
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
      { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($0F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TMemmoPrinter.PrintColABN }

procedure TMemmoPrinter.PrintColumnAB(Item :PPaperItem_Data);
  var S :String;

  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubColumnAB); far;
  begin
    { Get Number }
    S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.  ';
    with PColumnAB_Data(Item)^ do
      S := S+Order[char(SubQuestNum+ord('A')-1)];
    with Target^ do
    begin
      SendText(S);
      Advance(0, 1, 0);
    end;
    Inc(SubQuestNum);
  end; { Sub-procedure DoSubItem }

begin { TMemmoPrinter.PrintColumnAB }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Kolom A & B';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PColumnAB_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
     { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end;
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end;
  Inc(QuestNum);
end; { TMemmoPrinter.PrintColumnAB }

procedure TMemmoPrinter.PrintHeader;
  var S :String;
begin
  with Target^ do
  begin
    { Set Bold Style }
    SetAttr(Style_Bold, True);
    { Print a DoubleLine with the word "Vraestel" in center }
    S := SFill(#205, ColsPerLine);
    Insert(' Memmorandum ', S, (ColsPerLine-10) shr 1 + 1);
    SendText(S);
    Advance(0, 1, 0); { To Next Line }
    { Write all Header Data in a spesific format }
    with PaperData^.Header do
    begin
      { Write Subject and Paper Number }
      SendText(' '+Subject);
      SendText(' '+Number);
      { Flush Text Right }
      Advance(0, 0, ColsPerLine-Length(Standard+Grade)-Column-2);
      SendText(Standard);
      SendText(' '+Grade);
      { Next Line second column }
      Advance(0, 1, 1);
      SendText(Date);
      { Center Text }
      Advance(0, 0,
       (Column + ColsPerLine-Length(Setter)-21-Length(Time)) shr 1 - Column);
      SendText('Tyd: '+Time);
      { Flush Text Right }
      Advance(0, 0, ColsPerLine-Length(Setter)-Column-16);
      SendText('Opgestel deur: '+Setter);
    end; { PrintHeader }
    { Print a DoubleLine }
    Advance(0, 1, 0);
    SendText(SFill(#205, ColsPerLine));
    { Normal Text }
    Advance(0, 2, 0);
    SetAttr($0F, False);
  end; { with }
end; { TMemmoPrinter.PrintHeader. }

{ Prints the text neccersary }
procedure TMemmoPrinter.PrintMonkey(Item :PPaperItem_Data);
  var S :String;

  { Prints each sub item }
  procedure DoSubItem(SubItem :PSubMonkey); far;
    var I :Byte;
       procedure AddAnswer(Bit :Byte);
       begin
         if S <> '' then S := S+' en/of ';
         S := S+Char(Bit + Ord('A'));
       end;
  begin
    S := '';
    for I := 0 to 5 do
      if (1 shl  I) and SubItem^.Answer <> 0 then AddAnswer(I);
    S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.  ' + S;
    with Target^ do
    begin
      SendText(S);
      Advance(0, 1, 0);
    end; {with}
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

begin { TMemmoPrinter.PrintMonkey }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' -  Multi Keuse';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PMonkeyPuzzle_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
     { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end; {with}
    { Normal Text }
    SetAttr($F, False);
    Advance(0, 1, 0);
  end; {with}
  Inc(QuestNum);
end; { TMemmoPrinter.PrintMonkey }

procedure TMemmoPrinter.PrintTerm(Item :PPaperItem_Data);
  var S :String;

  { Prints a Sub Item }
  procedure DoSubItem(SubItem :PSubTerm); far;
    var I, Indent :Byte;
        W :TWrapper;

  begin
    { Get Number }
    S := SInt(QuestNum, 0)+'.'+SInt(SubQuestNum, 0)+'.  ';
    Indent := Length(S);
    { Get Items }
    with SubItem^ do
    begin
      S := S+Terms[1];
      if (Terms[1] <> '') and (Terms[2] <> '') then S := S+' of ';
      S := S+Terms[2];
    end; {with}
    with Target^ do
    begin
      W.AssignStr(S, ColsPerLine, Indent);
      while not W.IsDone do
      begin
        SendText(W.NextLine);
        Advance(0, 1, 0);
      end; {while}
    end; {with}
    Inc(SubQuestNum);
  end; { sub-procedure DoSubItem }

begin { TMemmoPrinter.PrintTerm }
  SubQuestNum := 1;
  with Target^ do
  begin
    { Bold+Underline Text }
    SetAttr(Style_Bold+Style_UnderLine, True);
    { Fetch String }
    S := 'Vraag '+SInt(QuestNum, 0)+' - '+'Terme vir Omskrywings';
    { Center Text }
    Advance(0, 0, (ColsPerLine-Length(S)) shr 1 + 1);
    SendText(S);
    Advance(0, 2, 0);
    { Normal Text }
    SetAttr($F, False);
    with PTerm_Data(Item)^ do
    begin
      List^.ForEach(@DoSubItem);
      S := 'Punte :('+Mark+'x'+SInt(List^.Count, 0)+
           ' = '+SInt((Ord(Mark)-48)*List^.Count, 0)+')';
      { Flush Right }
      Advance(0, 0, ColsPerLine-Length(S));
     { Underline+Italic Text }
      SetAttr(Style_UnderLine+Style_Italic, True);
      SendText(S);
    end; {with}
    { Normal Text }
    SetAttr($0F, False);
    Advance(0, 1, 0);
  end; {with}
  Inc(QuestNum);
end; { TMemmoPrinter.PrintTerm }

{****************************************************************************}
{*  Routines                                                                *}
{****************************************************************************}
{ Called to print the Question Paper }
procedure PrintQuestionPaper(Target :PPrintTarget);
  var Printer :TQuestionPaperPrinter;
begin
  Printer.PrintAll(Target);
end;

{ Called to print the answering sheet }
procedure PrintAnsweringSheet(Target :PPrintTarget);
  var Printer :TAnsweringSheetPrinter;
begin
  Printer.PrintAll(Target);
end;

{ Called to print the Memmo }
procedure PrintMemmo(Target :PPrintTarget);
  var Printer :TMemmoPrinter;
begin
  Printer.PrintAll(Target);
end;


{ Prints all the chosen papers(as spesified in PrintSettings.Combo)
  to the PrintTarget ATarget }
procedure PrintPapers(ATarget :PPrintTarget);
  var B :TBounds;

  { Advances to the next page on the target, ensuring first
    that the current page is not a new page }
  procedure NextPage;
  begin
    with ATarget^ do
      if LineCount > 0 then Advance(1, 0, 0);
  end;

begin
  { if No Paper Component is selected }
  if PrintSettings.Combo = 0 then
  begin
    B.Assign(125,200,515,300);
    MessageWindow(B, #3'Geen vraestel komponent is gekies vir uitdruk nie',
      mwfError+mwfOk);
    exit;
  end; {if}
  if not (ATarget^.ColsPerLine in [40..250]) then
  begin
    B.Assign(125,200,515,300);
    MessageWindow(B, #3'Ongeldige waarde vir Karakters per lyn (40..250)',
      mwfError+mwfOk);
    exit;
  end; {if}
  if not (ATarget^.LinesPerPage > 2) then
  begin
    B.Assign(125,200,515,300);
    MessageWindow(B, #3'Ongeldige waarde vir Lyne per badsy (2..99)',
      mwfError+mwfOk);
    exit;
  end; {if}
  with PrintSettings do
  begin
    if Combo and QuestionPaper <> 0 then PrintQuestionPaper(ATarget);
    if Combo and AnsweringSheet <> 0 then
    begin
      NextPage;
      PrintAnsweringsheet(ATarget);
    end;
    if Combo and Memmo <> 0 then
    begin
      NextPage;
      PrintMemmo(ATarget);
    end;{if}
  end; {with}
end; { procedure PrintPapers }

procedure StartPrinting;
  var P :PPrintTarget;
      B1, B2 :Word; Err :Integer;
      B :TBounds;
begin
  with PrintSettings do
  begin
    if Target = 0 then
    begin
      B.Assign(125,200,515,300);
      MessageWindow(B, #3'Geen Teiken is vir afvoer.', mwfError+mwfOk);
      exit;
    end; {if}
    Val(LinesPP, B1, Err);
    Val(CharsPL, B2, Err);
    if B2 > 250 then B2 := 0;
    if Target and PrintTarget_File <> 0 then
    begin
      P := New(PFilePrintTarget, Init(B1, B2, FileName));
      PrintPapers(P);
      Dispose(P, Done);
    end; {if}
    if Target and PrintTarget_Printer <> 0 then
    begin
      P := New(PPrinter, Init(B1, B2, Printer));
      PrintPapers(P);
      Dispose(P, Done);
    end;{if}
  end; {with}
end; { StartPrinting }

end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{*                                                                          *}
{* Implementation of the following important objects                        *}
{*   þ Layout Selection List                                                *}
{*   þ Data objects for each paper item                                     *}
{*   þ View objects for each paper item                                     *}
{****************************************************************************}
Unit Quests;
  {$F-,O-,Q-,R-,S-}

Interface
  uses Objects, sBasic, sView, sTypes, STDViews;

{ This unit implements all the views, transfer objects and routines
  neccesary for the Question Items of the Edit Mode.
}

{****************************************************************************}
{* Basic Items                                                              *}
{****************************************************************************}

{***þ Abstract Paper-Item View þ***}
type
  PPaperItem_View = ^TPaperItem_View;
  TPaperItem_View = Object(TViewGroup)
    constructor Init(B :TBounds);
    function    GetCaption :String; virtual;
    procedure   Art; virtual;
  end;

{***þ Counter View þ***}
type
  PCounterView = ^TCounterView;
  TCounterView = Object(TView)
    Current :Word;
    Amount  :Word;
    procedure   Art; virtual;
    procedure   GetData(var Rec); virtual;
    procedure   SetData(var Rec); virtual;
    function    DataSize :Word; virtual;
  end;

{***þ Question-Paper-Item View þ***}
type
  PQuestionItem_View = ^TQuestionItem_View;
  TQuestionItem_View = Object(TPaperItem_View)
    constructor Init(B :TBounds);
    procedure   Art; virtual;
  end;

{***þ Abstract Paper-Item Data Object þ***}
type
  PPaperItem_Data = ^TPaperItem_Data;
  TPaperItem_Data = Object(TObject)
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
    procedure   SetViewData(View :PPaperItem_View); virtual;
    procedure   GetViewData(View :PPaperItem_View); virtual;
    function    Itemtype :Byte; virtual;
    function    Signature :String;
  end;

{***þ Question-Paper-Item Data Object þ***}
type
  PQuestionItem_Data = ^TQuestionItem_Data;
  TQuestionItem_Data = Object(TPaperItem_Data)
    Current :Word;
    List    :PCollection;
    Mark    :Char;
    constructor Init;
    destructor  Done; virtual;
    procedure   FreeList;
    function    GetNew :PObject; virtual;
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
    procedure   Changed; virtual;
  end;

{***þ LayOutList þ***}
type
  PLayoutList = ^TLayoutList;
  TLayoutList = Object(TListScroller)
    TypeSelect :Boolean;
    PrevPos    :Word;
    constructor Init(var B :TBounds);
    function    GetString(Index :Word) :String; virtual;
    function    Count :Word; virtual;
    procedure   InsertItem;
    procedure   AppendItem;
    procedure   Selected(Index :Word); virtual;
    procedure   Delete;
    procedure   BarChanged; virtual;
  end;

  { Returns a name for the spesific question paper item}
  function Get_PaperItem_Signature(Itemtype :Byte) :String;
  { Constructs a new PaperItem View Object. The object type
    is determined by the itemtype parameter }
  function New_PaperItem_View(Itemtype :Byte) :PPaperItem_View;
  { Constructs a new PaperItem Data Object. The derived object type
    is determined by the itemtype parameter }
  function New_PaperItem_Data(Itemtype :Byte) :PPaperItem_Data;
  { Returns true if the givven view object is a descendant of
    PQuestionItem_Data }
  function IsQuestionView(View :PView) :Boolean;


{****************************************************************************}
{* Afdeling Item deritaves                                                  *}
{****************************************************************************}
type
  TTAfdeling = string[30];

type
  PAfdeling_View = ^TAfdeling_View;
  TAfdeling_View = Object(TPaperItem_View)
    constructor Init;
    procedure   Art; virtual;
    function    ID :Word; virtual;
  end;

type
  PAfdeling_Data = ^TAfdeling_Data;
  TAfdeling_Data = Object(TPaperItem_Data)
    Data :TTAfdeling;
    function  Itemtype :Byte; virtual;
    procedure SetViewData(View :PPaperItem_View); virtual;
    procedure GetViewData(View :PPaperItem_View); virtual;
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
  end;

{****************************************************************************}
{* Column A & B & None Item                                                 *}
{****************************************************************************}
type
  PTColABN = ^TTColABN;
  TTColABN = record
    tCurrent   :Word;
    tAmount    :Word;
    tPoints    :String[1];
    tStatement :Array[1..2] of String[60];
    tItems     :Array[1..2] of String[20];
    tAnswer    :Byte;
  end;

type
  PSubColABN = ^TSubColABN;
  TSubColABN = Object(TObject)
    Statement :Array[1..2] of String[60];
    Items     :Array[1..2] of String[20];
    Answer    :Byte;
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
  end;

type
  PColABN_View = ^TColABN_View;
  TColABN_View = Object(TQuestionItem_View)
    constructor Init;
    function    GetListedName :String; virtual;
    function    ID :Word; virtual;
    procedure   Art; virtual;
  end;

type
  PColABN_Data = ^TColABN_Data;
  TColABN_Data = Object(TQuestionItem_Data)
    function  Itemtype :Byte; virtual;
    procedure SetViewData(View :PPaperItem_View); virtual;
    procedure GetViewData(View :PPaperItem_View); virtual;
    function  GetNew :PObject; virtual;
  end;

{****************************************************************************}
{* Column A & B Item                                                        *}
{****************************************************************************}
type
  PTColumnAB = ^TTColumnAB;
  TTColumnAB = record
    tCurrent  :Word;
    tAmount   :Word;
    tPoints   :String[1];
    tQuestion :Array[1..4] of String[80];
    tAnswer   :Array[1..4] of String[80];
  end;

type
  PSubColumnAB = ^TSubColumnAB;
  TSubColumnAB = Object(TObject)
    ColumnA  :Array[1..4] of String[80];
    ColumnB  :Array[1..4] of String[80];
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
  end;

type
  PColumnAB_View = ^TColumnAB_View;
  TColumnAB_View = Object(TQuestionItem_View)
    constructor Init;
    function    GetListedName :String; virtual;
    function    ID :Word; virtual;
    procedure   Art; virtual;
  end;

type
  PColumnAB_Data = ^TColumnAB_Data;
  TColumnAB_Data = Object(TQuestionItem_Data)
    Order :Array['A'..'Z'] of Char;
    constructor Init;
    function  Itemtype :Byte; virtual;
    procedure SetViewData(View :PPaperItem_View); virtual;
    procedure GetViewData(View :PPaperItem_View); virtual;
    function  GetNew :PObject; virtual;
    procedure Changed; virtual;
    procedure NewOrder;
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
  end;

{****************************************************************************}
{* Message Item                                                             *}
{****************************************************************************}
type
  TTMessage = record
    Message :Array[1..5] of String[60];
  end;

type
  PMessage_View = ^TMessage_View;
  TMessage_View = Object(TPaperItem_View)
    constructor Init;
    function    ID :Word; virtual;
    procedure   Art; virtual;
  end;

type
  PMessage_Data = ^TMessage_Data;
  TMessage_Data = Object(TPaperItem_Data)
    Data :TTMessage;
    function  Itemtype :Byte; virtual;
    procedure SetViewData(View :PPaperItem_View); virtual;
    procedure GetViewData(View :PPaperItem_View); virtual;
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
  end;

{****************************************************************************}
{* Monkey Puzzle Item                                                           *}
{****************************************************************************}
type
  TTMonkeyPuzzle = record
    tCurrent  :Word;
    tAmount   :Word;
    tPoints   :String[1];
    tQuestion :Array[1..3] of String[80];
    tOptions  :Array[1..5] of String[80];
    tAnswer   :Byte;
  end;

type
  PSubMonkey = ^TSubMonkey;
  TSubMonkey = Object(TObject)
    Question :Array[1..3] of String[80];
    Options  :Array[1..5] of String[80];
    Answer   :Byte;
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
  end;

type
  PMonkeyPuzzle_View = ^TMonkeyPuzzle_View;
  TMonkeyPuzzle_View = Object(TQuestionItem_View)
    constructor Init;
    destructor  Done; virtual;
    function    ID :Word; virtual;
    procedure   Art; virtual;
  end;

type
  PMonkeyPuzzle_Data = ^TMonkeyPuzzle_Data;
  TMonkeyPuzzle_Data = Object(TQuestionItem_Data)
    function  Itemtype :Byte; virtual;
    procedure SetViewData(View :PPaperItem_View); virtual;
    procedure GetViewData(View :PPaperItem_View); virtual;
    function  GetNew :PObject; virtual;
  end;

{****************************************************************************}
{* Term Question Item                                                          *}
{****************************************************************************}
type
  PTTerm = ^TTTerm;
  TTTerm = record
    tCurrent  :Word;
    tAmount   :Word;
    tPoints   :String[1];
    tQuestion :Array[1..3] of String[80];
    tTerms    :Array[1..2] of String[25];
  end;

type
  PSubTerm = ^TSubTerm;
  TSubTerm = Object(TObject)
    Question :Array[1..3] of String[80];
    Terms    :Array[1..2] of String[25];
    constructor Load(var S: TStream);
    procedure   Store(var S: TStream); virtual;
  end;

type
  PTerm_View = ^TTerm_View;
  TTerm_View = Object(TQuestionItem_View)
    constructor Init;
    function    GetListedName :String; virtual;
    function    ID :Word; virtual;
    procedure   Art; virtual;
  end;

type
  PTerm_Data = ^TTerm_Data;
  TTerm_Data = Object(TQuestionItem_Data)
    function  Itemtype :Byte; virtual;
    procedure SetViewData(View :PPaperItem_View); virtual;
    procedure GetViewData(View :PPaperItem_View); virtual;
    function  GetNew :PObject; virtual;
  end;


Implementation
  uses Consts, sInput, TMData, sGraph, graph, sProcs, Main;

{****************************************************************************}
{*  Stream Registration records                                             *}
{****************************************************************************}
const
  RPaperItem_Data :TStreamRec = (
    ObjType: 1000;
    VmtLink: Ofs(TypeOf(TPaperItem_Data)^);
    Load: @TPaperItem_Data.Load;
    Store: @TPaperItem_Data.Store);

  RQuestionItem_Data :TStreamRec = (
    ObjType: 1001;
    VmtLink: Ofs(TypeOf(TQuestionItem_Data)^);
    Load: @TQuestionItem_Data.Load;
    Store: @TQuestionItem_Data.Store);

  RAfdeling_Data :TStreamRec = (
    ObjType: 1002;
    VmtLink: Ofs(TypeOf(TAfdeling_Data)^);
    Load: @TAfdeling_Data.Load;
    Store: @TAfdeling_Data.Store);

  RSubColABN :TStreamRec = (
    ObjType: 1003;
    VmtLink: Ofs(TypeOf(TSubColABN)^);
    Load: @TSubColABN.Load;
    Store: @TSubColABN.Store);

  RColABN_Data :TStreamRec = (
    ObjType: 1004;
    VmtLink: Ofs(TypeOf(TColABN_Data)^);
    Load: @TColABN_Data.Load;
    Store: @TColABN_Data.Store);

  RSubColumnAB :TStreamRec = (
    ObjType: 1005;
    VmtLink: Ofs(TypeOf(TSubColumnAB)^);
    Load: @TSubColumnAB.Load;
    Store: @TSubColumnAB.Store);

  RColumnAB_Data :TStreamRec = (
    ObjType: 1006;
    VmtLink: Ofs(TypeOf(TColumnAB_Data)^);
    Load: @TColumnAB_Data.Load;
    Store: @TColumnAB_Data.Store);

  RSubMonkey :TStreamRec = (
    ObjType: 1007;
    VmtLink: Ofs(TypeOf(TSubMonkey)^);
    Load: @TSubMonkey.Load;
    Store: @TSubMonkey.Store);

  RMonkeyPuzzle_Data :TStreamRec = (
    ObjType: 1008;
    VmtLink: Ofs(TypeOf(TMonkeyPuzzle_Data)^);
    Load: @TMonkeyPuzzle_Data.Load;
    Store: @TMonkeyPuzzle_Data.Store);

  RMessage_Data :TStreamRec = (
    ObjType: 1009;
    VmtLink: Ofs(TypeOf(TMessage_Data)^);
    Load: @TMessage_Data.Load;
    Store: @TMessage_Data.Store);

  RSubTerm :TStreamRec = (
    ObjType: 1010;
    VmtLink: Ofs(TypeOf(TSubTerm)^);
    Load: @TSubTerm.Load;
    Store: @TSubTerm.Store);

  RTerm_Data :TStreamRec = (
    ObjType: 1011;
    VmtLink: Ofs(TypeOf(TTerm_Data)^);
    Load: @TTerm_Data.Load;
    Store: @TTerm_Data.Store);


{****************************************************************************}
{*  TPaperItem_View                                                         *}
{****************************************************************************}
constructor TPaperItem_View.Init(B :TBounds);
begin
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable or voFirstClick;
end; { TPaperItem_View.Init }

{ Retuns the Name accociated with the ID of the paper item }
function TPaperItem_View.GetCaption :String;
begin
  GetCaption := Get_PaperItem_Signature(ID);
end; { TPaperItem_View.GetCaption }

procedure TPaperItem_View.Art;
begin
  Platform(0, 0, Size.X, Size.Y,  $F008);
  Platform(5, 5, Size.X-5, Size.Y-5,  $0F07);
  Platform(6, 6, Size.X-6, 26,  $F001);
  WriteStrXY(Size.X shr 1, 13, $1E, 2, 5, JustCenter, False, GetCaption);
end; { TPaperItem_View.Art }

{****************************************************************************}
{*  TQuestionItem_View                                                      *}
{****************************************************************************}
procedure TCounterView.Art;
begin
  Platform(0, 0, Size.X, Size.Y, $0F09);
  WriteStrXY(Size.X shr 1, Size.Y shr 1-1, $F, 2, 4, JustCenter, False,
    SInt(Current, 0)+' van '+SInt(Amount, 0));
end; { TCounterView.Art }

procedure TCounterView.GetData(var Rec);
  type TTCount = record
         tCurrent, tAmount :Word;
       end;
begin
  with TTCount(Rec) do
  begin
    tCurrent := Current;
    tAmount  := Amount;
  end;
end; { TCounterView.GetData }

procedure TCounterView.SetData(var Rec);
  type TTCount = record
         tCurrent, tAmount :Word;
       end;
begin
  with TTCount(Rec) do
  begin
    Current := tCurrent;
    Amount  := tAmount;
  end;
  Draw;
end; { TCounterView.SetData }

function TCounterView.DataSize :Word;
begin
  DataSize := Sizeof(Word) shl 1;
end; { TCounterView.DataSize }

{****************************************************************************}
{*  TQuestionItem_View                                                      *}
{****************************************************************************}
constructor TQuestionItem_View.Init(B :TBounds);
begin
  Inherited Init(B);
  Lock;
  B.Assign(Size.X-100, 10, Size.X-10, 22);
  Append(New(PCounterView, Init(B)));
  { Control Buttons }
  B.Assign(10, Size.Y-25, 80, Size.Y-10);
  Append(New(PButton, Init(B, 'Vorige', cmQuestPrev, 0)));
  B.Assign(90, Size.Y-25, 170, Size.Y-10);
  Append(New(PButton, Init(B, 'Volgende', cmQuestNext, 0)));
  B.Assign(180, Size.Y-25, 240, Size.Y-10);
  Append(New(PButton, Init(B, 'Begin', cmQuestBegin, 0)));
  B.Assign(250, Size.Y-25, 310, Size.Y-10);
  Append(New(PButton, Init(B, 'Einde', cmQuestEnd, 0)));
  B.Assign(320, Size.Y-25, 390, Size.Y-10);
  Append(New(PButton, Init(B, 'Nuwe Na', cmQuestNewAfter, 0)));
  B.Assign(400, Size.Y-25, 490, Size.Y-10);
  Append(New(PButton, Init(B, 'Nuwe Voor', cmQuestNewAt, 0)));
  B.Assign(500, Size.Y-25, 580, Size.Y-10);
  Append(New(PButton, Init(B, 'Verwyder', cmQuestDelete, 0)));
  { Amount-for-each-question Line}
  B.Assign(53, 68, 98, 88);
  Append(New(PInputLine, Init(B, 1, '1', ['1'..'9'])));
  Unlock;
end; { TQuestionItem_View.Init }

procedure TQuestionItem_View.Art;
begin
  Inherited Art;
  Level(10, 35, 140, 115, Lowergrey);
  Level(15, 40, 135, 110, Raisegrey);
  WriteStrXY(35, 45, $0, 2, 4, JustLeft+JustTop, False, 'Punte Toegeken');
  WriteStrXY(35, 105, $0, 2, 4, JustLeft+Justbottom, False, 'Aan Elke Vraag');
  Line3D(10, Size.Y-35, Size.X-10, Size.Y-35, $8F);
end; { TQuestionItem_View.Art }

{****************************************************************************}
{*  TPaperItem_Data                                                             *}
{****************************************************************************}
procedure TPaperItem_Data.SetViewData(View :PPaperItem_View);
begin
  {$IFNDEF FinalVersion}
  Abstract('TPaperItem_Data.SetViewData');
  {$EndIf}
end; { TPaperItem_Data.SetViewData }

procedure TPaperItem_Data.GetViewData(View :PPaperItem_View);
begin
  PaperData^.Modified := True;
end; { TPaperItem_Data.GetViewData }

function TPaperItem_Data.Itemtype :Byte;
begin
  {$IFNDEF FinalVersion}
  Abstract('TPaperItem_Data.Itemtype');
  {$EndIf}
end; { TPaperItem_Data.ItemType }

function TPaperItem_Data.Signature :String;
begin
  Signature := Get_PaperItem_Signature(ItemType);
end; { TPaperItem_Data.Signature }

constructor TPaperItem_Data.Load(var S: TStream);
begin
  {$IFNDEF FinalVersion}
  Abstract('TPaperItem_Data.Load');
  {$EndIf}
end; { TPaperItem_Data.Load }

procedure TPaperItem_Data.Store(var S: TStream);
begin
  {$IFNDEF FinalVersion}
  Abstract('TPaperItem_Data.Store');
  {$EndIf}
end; { TPaperItem_Data.Store }

{****************************************************************************}
{*  TQuestionItem_Data                                                      *}
{****************************************************************************}
constructor TQuestionItem_Data.Init;
begin
  Inherited Init;
  System.New(List, Init(1, 1));
  List^.Insert(GetNew);
  Mark := '3';
end; { TQuestionItem_Data.Init }

destructor TQuestionItem_Data.Done;
begin
  FreeList;
  Inherited Done;
end; { TQuestionItem_Data.Done }

procedure TQuestionItem_Data.FreeList;
begin
  if List <> nil then Dispose(List, Done);
  List := nil;
end; { TQuestionItem_Data.FreeList }

{ constructs a new question object }
function TQuestionItem_Data.GetNew :PObject;
begin
  {$IFNDEF FinalVersion}
  Abstract('TQuestionItem_Data.GetNew');
  {$EndIf}
end; { TQuestionItem_Data.GetNew }

{ Loads the question from the Stream S }
constructor TQuestionItem_Data.Load(var S: TStream);
begin
  Current := 0;
  S.Read(Mark, Sizeof(Mark));
  List := PCollection(S.Get);
end; { TQuestionItem_Data.Load }

{ Stores the question to the Stream S }
procedure TQuestionItem_Data.Store(var S: TStream);
begin
  S.Write(Mark, Sizeof(Mark));
  S.Put(List);
end; { TQuestionItem_Data.Store }

procedure TQuestionItem_Data.Changed;
begin
end;

{****************************************************************************}
{*  TLayOutList                                                             *}
{****************************************************************************}
constructor TLayOutList.Init(var B :TBounds);
begin
  Inherited Init(B, nil);
  TypeSelect := False;
end; { TLayOutList.Init }

function TLayOutList.GetString(Index :Word) :String;
begin
  if TypeSelect then GetString := Get_PaperItem_Signature(Index+tmAfdeling)
  else
    if PaperData^.Items^.Count > 0 then
      GetString := PPaperItem_Data(PaperData^.Items^.At(Index))^.Signature
    else GetString := '';
end; { TLayOutList.GetString }

function TLayoutList.Count :Word;
begin
  if TypeSelect then Count := 6 else Count := PaperData^.Items^.Count;
end; { TLayOutList.Count }

procedure TLayoutList.Selected(Index :Word);
begin
  if TypeSelect then
  begin
    TypeSelect := False;
    PaperData^.Items^.AtInsert(PrevPos, New_PaperItem_Data(Index+tmAfdeling));
    Lock;
    Reset;
    Unlock;
    Message(Owner, spCommand, cmShowButtons, nil);
  end
  else PutMessage(spCommand, cmExeItem, PaperData^.Items^.At(CurStr));
end; { TLayOutList.Selected }

procedure TLayOutList.InsertItem;
begin
  if TypeSelect then Exit;
  PrevPos := CurStr;
  TypeSelect := True;
  Lock;
  Select;
  Reset;
  Unlock;
  Message(Owner, spCommand, cmHideButtons, nil);
  PaperData^.Modified := True;
end; { TLayOutList.InsertItem }

procedure TLayOutList.AppendItem;
begin
  if TypeSelect then Exit;
  PrevPos := Count;
  TypeSelect := True;
  Lock;
  Select;
  Reset;
  Unlock;
  Message(Owner, spCommand, cmHideButtons, nil);
  PaperData^.Modified := True;
end; { TLayOutList.AppendItem }

procedure TLayOutList.Delete;
begin
  if TypeSelect then Exit;
  if Count > 0 then PaperData^.Items^.AtFree(CurStr);
  Reset;
  PaperData^.Modified := True;
end; { TLayOutList.Delete }

procedure TLayOutList.BarChanged;
begin
  CurrentItem := CurStr;
end; { TLayOutList.BarChanged }

{****************************************************************************}
{* Afdeling Item                                                            *}
{****************************************************************************}
constructor TAfdeling_View.Init;
  var B :TBounds;
      I :Integer;
begin
  B.Assign(70, 90, 570, 195);
  Inherited Init(B);
  Lock;
  B.Assign(200, 35, 475, 55);
  Append(New(PInputLine, Init(B, 30, '', [#32..#255])));
  B.Assign(20, Size.Y-25, 100, Size.Y-10);
  Append(New(PButton, Init(B, 'Aanvaar', cmAcceptItem, 0)));
  B.Assign(385, Size.Y-25, 475, Size.Y-10);
  Append(New(PButton, Init(B, 'Kanselleer', cmCancelItem, 0)));
  SelectNext;
  Unlock;
end;

function TAfdeling_View.ID :Word;
begin
  ID := IAfdeling;
end;

procedure TAfdeling_View.Art;
begin
  Inherited Art;
  WriteStrXY(20, 32, $16, 1, 1, JustLeft+JustTop, False, 'Meer Beskrywend');
  Line3D(10, Size.Y-35, 485, Size.Y-35, $8F);
end;

function TAfdeling_Data.Itemtype :Byte;
begin
  Itemtype := tmAfdeling;
end;

procedure TAfdeling_Data.SetViewData(View :PPaperItem_View);
begin
  View^.SetData(Data);
end;

procedure TAfdeling_Data.GetViewData(View :PPaperItem_View);
begin
  inherited GetViewData(View);
  View^.GetData(Data);
end;

constructor TAfdeling_Data.Load(var S: TStream);
begin
  S.Read(Data, Sizeof(Data));
end;

procedure TAfdeling_Data.Store(var S: TStream);
begin
  S.Write(Data, Sizeof(Data));
end;

{****************************************************************************}
{* Column A & B & None Item                                                 *}
{****************************************************************************}
constructor TColABN_View.Init;
  var B :TBounds;
      i :Byte;
      Ans :PCluster;
begin
  B.Assign(25, 65, 615, 270);
  Inherited Init(B);
  Lock;
  { Statement }
  for I := 0 to 1 do
  begin
    B.Assign(150, 65+I*20, 470, 85+I*20);
    Append(New(PInputLine, Init(B, 60, '', [#32..#255])));
  end;
  { Items }
  B.Assign(90, 135, 285, 155);
  Append(New(PInputLine, Init(B, 20, '', [#32..#255])));
  B.Assign(380, 135, 575, 155);
  Append(New(PInputLine, Init(B, 20, '', [#32..#255])));
  { Answer Cluster }
  B.Assign(505, 72, 565, 100);
  Ans := New(PCluster, Init(B,
                         NewLPString('Item 1',
                         NewLPstring('Item 2',
                         nil)),
                        HcClust4TermAns));
  Append(Ans);
  Ans^.Value := 0;
  for I := 1 to 7 do SelectNext;
  Unlock;
end;

function TColABN_View.GetListedName :String;
begin
  GetListedName := 'Term Betrekking';
end;

function TColABN_View.ID :Word;
begin
  ID := IColABN;
end;

procedure TColABN_View.Art;
begin
  Inherited Art;
  WriteStrXY(15, 130, $16, 1, 1, JustLeft+JustTop, False, 'Item 1');
  WriteStrXY(305, 130, $16, 1, 1, JustLeft+JustTop, False, 'Item 2');
  WriteStrXY(250, 50, $16, 1, 1, JustLeft+JustBottom, False, 'Stelling');
  WriteStrXY(535, 40, $16, 1, 1, JustCenter, False, 'Antwoord');
  Level(495, 65, 572, 105, LowerGrey);
end;

{* Data Objects *}
constructor TSubColABN.Load(var S: TStream);
begin
  S.Read(Statement, sizeof(StateMent));
  S.Read(Items, sizeof(Items));
  S.Read(Answer, sizeof(Answer));
end;

procedure TSubColABN.Store(var S: TStream);
begin
  S.Write(Statement, sizeof(StateMent));
  S.Write(Items, sizeof(Items));
  S.Write(Answer, sizeof(Answer));
end;

function TColABN_Data.Itemtype :Byte;
begin
  Itemtype := tmColABN;
end;

procedure TColABN_Data.SetViewData(View :PPaperItem_View);
  var Data :TTColABN;
begin
  with Data do
    with PSubColABN(List^.At(Current))^ do
    begin
      tPoints    := Mark;
      tCurrent   := Current+1;
      tAmount    := List^.Count;
      tAnswer    := Answer;
      Move(Statement, tStatement, Sizeof(tStatement));
      Move(Items, tItems, Sizeof(tItems));
    end; {with}
  View^.SetData(Data);
end;

procedure TColABN_Data.GetViewData(View :PPaperItem_View);
  var Data :TTColABN;
begin
  inherited GetViewData(View);
  View^.GetData(Data);
  with Data do
    with PSubColABN(List^.At(Current))^ do
    begin
      Mark := tPoints[1];
      Answer := tAnswer;
      Move(tStatement, Statement, Sizeof(Statement));
      Move(tItems, Items, Sizeof(Items));
    end; {with}
end;

function TColABN_Data.GetNew :PObject;
begin
  GetNew := New(PSubColABN, Init);
end;

{****************************************************************************}
{* Column A & B Item                                                        *}
{****************************************************************************}
constructor TColumnAB_View.Init;
  var B :TBounds;
      I :Byte;
begin
  B.Assign(25, 65, 615, 315);
  Inherited Init(B);
  Lock;
  { Question }
  for I := 0 to 3 do
  begin
    B.Assign(170, 35+I*20, 580, 55+I*20);
    Append(New(PInputLine, Init(B, 80, '', [#32..#255])));
  end;
  { Answer }
  for I := 0 to 3 do
  begin
    B.Assign(170, 130+I*20, 580, 150+I*20);
    Append(New(PInputLine, Init(B, 80, '', [#32..#255])));
  end;
  for I := 1 to 7 do SelectNext;
  Unlock
end; {Init}

function TColumnAB_View.GetListedName :String;
begin
  GetListedName := 'Kolom A - Kolom B';
end;

function TColumnAB_View.ID :Word;
begin
  ID := IColumnAB;
end;

procedure TColumnAB_View.Art;
begin
  Inherited Art;
  WriteStrXY(140, 110, $16, 1, 1, JustLeft+JustBottom, True, 'Kolom A');
  WriteStrXY(35, 120, $16, 1, 1, JustLeft+JustTop, False, 'Betrokke');
  WriteStrXY(45, 150, $16, 1, 1, JustLeft+JustTop, False, 'Kolom');
  WriteStrXY(65, 180, $16, 1, 1, JustLeft+JustTop, False, 'B');
  WriteStrXY(140, 190, $16, 1, 1, JustLeft+JustBottom, True, 'Opsie');
end;

{* Data Objects *}
constructor TSubColumnAB.Load(var S: TStream);
begin
  S.Read(ColumnA, sizeof(ColumnA));
  S.Read(ColumnB, sizeof(ColumnB));
end;

procedure TSubColumnAB.Store(var S: TStream);
begin
  S.Write(ColumnA, sizeof(ColumnA));
  S.Write(ColumnB, sizeof(ColumnB));
end;

constructor TColumnAB_Data.Init;
begin
  Inherited Init;
  { Shuffle Order }
  Order['A'] := 'A';
end;

function TColumnAB_Data.Itemtype :Byte;
begin
  Itemtype := tmColumnAB;
end;

procedure TColumnAB_Data.SetViewData(View :PPaperItem_View);
  var Data :TTColumnAB;
begin
  with Data do
    with PSubColumnAB(List^.At(Current))^ do
    begin
      tPoints  := Mark;
      tCurrent := Current+1;
      tAmount  := List^.Count;
      Move(ColumnA, tQuestion, Sizeof(tQuestion));
      Move(ColumnB, tAnswer, Sizeof(tAnswer));
    end;
  View^.SetData(Data);
end;

procedure TColumnAB_Data.GetViewData(View :PPaperItem_View);
  var Data :TTColumnAB;
begin
  inherited GetViewData(View);
  View^.GetData(Data);
  with Data do
    with PSubColumnAB(List^.At(Current))^ do
    begin
      Mark := tPoints[1];
      Move(tQuestion, ColumnA, Sizeof(ColumnA));
      Move(tAnswer, ColumnB, Sizeof(ColumnB));
    end;
end;

function TColumnAB_Data.GetNew :PObject;
begin
  GetNew := New(PSubColumnAB, Init);
end;

constructor TColumnAB_Data.Load(var S: TStream);
begin
  inherited Load(S);
  S.Read(Order, Sizeof(Order));
end;

procedure TColumnAB_Data.Store(var S: TStream);
begin
  inherited Store(S);
  S.Write(Order, Sizeof(Order));
end;

procedure TColumnAB_Data.Changed;
begin
  NewOrder;
end;

{ Shuffles the column B items }
procedure TColumnAB_Data.NewOrder;
  var I :Char;

  function Valid(Ch :Char) :Boolean;
    var J :Char;
  begin
    Valid := True;
    for J := 'A' to Pred(I) do if Order[J] = Ch then Valid := False;
    if Ch = #0 then Valid := False;
  end;

begin
  Randomize;
  for I := 'A' to Char(List^.Count-1+Ord('A')) do
  begin
    Order[I] := #0;
    while not Valid(Order[I]) do
      Order[I] := Char(Random(List^.Count)+Ord('A'));
  end;
end;

{****************************************************************************}
{* Message Item                                                             *}
{****************************************************************************}
constructor TMessage_View.Init;
  var B :TBounds;
      I :Byte;
begin
  B.Assign(25, 65, 500, 260);
  Inherited Init(B);
  Lock;
  for I := 0 to 4 do
  begin
    B.Assign(20, 50+I*20, 450, 70+I*20);
    Append(New(PInputLine, Init(B, 60, '', [#32..#255])));
  end;
  B.Assign(20, Size.Y-25, 100, Size.Y-10);
  Append(New(PButton, Init(B, 'Aanvaar', cmAcceptItem, 0)));
  B.Assign(360, Size.Y-25, 450, Size.Y-10);
  Append(New(PButton, Init(B, 'Kanselleer', cmCancelItem, 0)));
  SelectNext;
  Unlock;
end; { TMessage_View.Init }

function TMessage_View.ID :Word;
begin
  ID := IMessage;
end;

procedure TMessage_View.Art;
begin
  inherited Art;
  WriteStrXY(20, 20, $06, 5, 1, JustLeft+JustTop, False, 'Boodskap :');
  Line3D(10, 160, Size.X-10, 160, $8F);
end;

{* Data Object *}
function TMessage_Data.Itemtype :Byte;
begin
  Itemtype := tmMessage;
end;

procedure TMessage_Data.SetViewData(View :PPaperItem_View);
begin
  View^.SetData(Data);
end;

procedure TMessage_Data.GetViewData(View :PPaperItem_View);
begin
  inherited GetViewData(View);
  View^.GetData(Data);
end;

constructor TMessage_Data.Load(var S: TStream);
begin
  S.Read(Data, Sizeof(Data));
end;

procedure TMessage_Data.Store(var S: TStream);
begin
  S.Write(Data, Sizeof(Data));
end;

{****************************************************************************}
{* Monkey Puzzle Item                                                           *}
{****************************************************************************}
constructor TMonkeyPuzzle_View.Init;
  var B :TBounds;
      I :Byte;
      Ans :PCluster;
begin
  B.Assign(25, 65, 615, 315);
  Inherited Init(B);
  Lock;
  { Question Lines }
  for I := 0 to 2 do
  begin
    B.Assign(170, 35+I*20, 580, 55+I*20);
    Append(New(PInputLine, Init(B, 80, '', [#32..#255])));
  end;
  { Option Lines }
  for I := 0 to 4 do
  begin
    B.Assign(170, 110+I*20, 580, 130+I*20);
    Append(New(PInputLine, Init(B, 80, '', [#32..#255])));
  end;
  { Answer Cluster }
  B.Assign(90, 140, 130, 200);
  Ans := New(PCluster, Init(B,
                         NewLPString('A.',
                         NewLPstring('B.',
                         NewLPstring('C.',
                         NewLPstring('D.',
                         NewLPstring('E.',
                         nil))))
                        ), HcClustMonkAns));
  Append(Ans);
  Ans^.Value := 0;
  for I := 1 to 7 do SelectNext;
  Unlock;
end; { TMonkeyPuzzle_View.Init }

destructor TMonkeyPuzzle_View.Done;
begin
  Inherited Done;
end;

function TMonkeyPuzzle_View.ID :Word;
begin
  ID := IMonkey;
end;

procedure TMonkeyPuzzle_View.Art;
begin
  Inherited Art;
  WriteStrXY(140, 90, $16, 1, 1, JustLeft+JustBottom, True, 'Vraag');
  WriteStrXY(140, 180, $16, 1, 1, JustLeft+JustBottom, True, 'Opsies');
  WriteStrXY(20, 115, $16, 1, 1, JustLeft+JustTop, False, 'Antwoorde');
end;


{* Data Objects *}
constructor TSubMonkey.Load(var S: TStream);
begin
  S.Read(Question, sizeof(Question));
  S.Read(Options, sizeof(Options));
  S.Read(Answer, sizeof(Answer));
end;

procedure TSubMonkey.Store(var S: TStream);
begin
  S.Write(Question, sizeof(Question));
  S.Write(Options, sizeof(Options));
  S.Write(Answer, sizeof(Answer));
end;

function TMonkeyPuzzle_Data.Itemtype :Byte;
begin
  Itemtype := tmMonkey;
end;

procedure TMonkeyPuzzle_Data.SetViewData(View :PPaperItem_View);
  var Data :TTMonkeyPuzzle;
begin
  with Data do
    with PSubMonkey(List^.At(Current))^ do
    begin
      tPoints  := Mark;
      tCurrent := Current+1;
      tAmount  := List^.Count;
      tAnswer  := Answer;
      Move(Question, tQuestion, Sizeof(tQuestion));
      Move(Options, tOptions, Sizeof(tOptions));
    end;
  View^.SetData(Data);
end;

procedure TMonkeyPuzzle_Data.GetViewData(View :PPaperItem_View);
  var Data :TTMonkeyPuzzle;
begin
  inherited GetViewData(View);
  View^.GetData(Data);
  with Data do
    with PSubMonkey(List^.At(Current))^ do
    begin
      Mark := tPoints[1];
      Answer := tAnswer;
      Move(tQuestion, Question, Sizeof(Question));
      Move(tOptions, Options, Sizeof(Options));
    end;
end;

function TMonkeyPuzzle_Data.GetNew :PObject;
begin
  GetNew := New(PSubMonkey, Init);
end;

{****************************************************************************}
{* Term Question Item                                                          *}
{****************************************************************************}
constructor TTerm_View.Init;
  var B :TBounds;
      I :Byte;
begin
  B.Assign(25, 65, 615, 300);
  Inherited Init(B);
  Lock;
  { Question Lines }
  for I := 0 to 2 do
  begin
    B.Assign(160, 55+I*20, 570, 75+I*20);
    Append(New(PInputLine, Init(B, 80, '', [#32..#255])));
  end;
  { Posible-answer Lines}
  B.Assign(15, 135, 250, 155);
  Append(New(PInputLine, Init(B, 25, '', [#32..#255])));
  B.Assign(15, 165, 250, 185);
  Append(New(PInputLine, Init(B, 25, '', [#32..#255])));
  for I := 1 to 7 do SelectNext;
  Unlock;
end;

function TTerm_View.GetListedName :String;
begin
  GetListedName := 'Terme';
end;

function TTerm_View.ID :Word;
begin
  ID := ITerms;
end;

procedure TTerm_View.Art;
begin
  Inherited Art;
  WriteStrXY(365, 35, $16, 1, 1, JustCenter, False, 'Omskrywing');
  WriteStrXY(390, 140, $16, 1, 1, JustCenter, False, 'Moontlike');
  WriteStrXY(390, 170, $16, 1, 1, JustCenter, False, 'Antwoorde');
end;

{* Data Objects *}
constructor TSubTerm.Load(var S: TStream);
begin
  S.Read(Question, sizeof(Question));
  S.Read(Terms, sizeof(Terms));
end;

procedure TSubTerm.Store(var S: TStream);
begin
  S.Write(Question, sizeof(Question));
  S.Write(Terms, sizeof(Terms));
end;

function TTerm_Data.Itemtype :Byte;
begin
  Itemtype := tmTerms;
end;

procedure TTerm_Data.SetViewData(View :PPaperItem_View);
  var Data :TTTerm;
begin
  with Data do
    with PSubTerm(List^.At(Current))^ do
    begin
      tPoints  := Mark;
      tCurrent := Current+1;
      tAmount  := List^.Count;
      Move(Question, tQuestion, Sizeof(tQuestion));
      Move(Terms, tTerms, Sizeof(tTerms));
    end;
  View^.SetData(Data);
end;

procedure TTerm_Data.GetViewData(View :PPaperItem_View);
  var Data :TTTerm;
begin
  inherited GetViewData(View);
  View^.GetData(Data);
  with Data do
    with PSubTerm(List^.At(Current))^ do
    begin
      Mark := tPoints[1];
      Move(tQuestion, Question, Sizeof(Question));
      Move(tTerms, Terms, Sizeof(Terms));
    end;
end;

function TTerm_Data.GetNew :PObject;
begin
  GetNew := New(PSubTerm, Init);
end;


{****************************************************************************}
{*  Public Routines                                                         *}
{****************************************************************************}

{ Returns a string signature for the givven itemtype }
function Get_PaperItem_Signature(Itemtype :Byte) :String;
begin
  case Itemtype of
    tmAfdeling :Get_PaperItem_Signature := 'Afdeling';
    tmMonkey   :Get_PaperItem_Signature := 'Multi Keuse';
    tmColumnAB :Get_PaperItem_Signature := 'Kolom A & B';
    tmColABN   :Get_PaperItem_Signature := 'BetrekkingsTerme';
    tmTerms    :Get_PaperItem_Signature := 'Terme en Omskrywings';
    tmMessage  :Get_PaperItem_Signature := 'Boodskap';
    {$IFNDEF FinalVersion}
    else Abort('Invalid Paper Item Type -- Get_PaperItem_Signature');
    {$EndIf}
  end;
end; { Get_PaperItem_Signature }

{ Constructs a new PaperItem View object depending on the Itemtype var }
function New_PaperItem_View(Itemtype :Byte) :PPaperItem_View;
begin
  case Itemtype of
    tmAfdeling :New_PaperItem_View := New(PAfdeling_View, Init);
    tmMonkey   :New_PaperItem_View := New(PMonkeyPuzzle_View, Init);
    tmColumnAB :New_PaperItem_View := New(PColumnAB_View, Init);
    tmColABN   :New_PaperItem_View := New(PColABN_View, Init);
    tmTerms    :New_PaperItem_View := New(PTerm_View, Init);
    tmMessage  :New_PaperItem_View := New(PMessage_View, Init);
    {$IFNDEF FinalVersion}
    else Abort('Invalid Paper Item Type -- Get_PaperItem_View');
    {$EndIf}
  end;
end; { New_PaperItem_View }

{ Constructs a new PaperItem Data object depending on the Itemtype var }
function New_PaperItem_Data(Itemtype :Byte) :PPaperItem_Data;
begin
  case Itemtype of
    tmAfdeling :New_PaperItem_Data := New(PAfdeling_Data, Init);
    tmMonkey   :New_PaperItem_Data := New(PMonkeyPuzzle_Data, Init);
    tmColumnAB :New_PaperItem_Data := New(PColumnAB_Data, Init);
    tmColABN   :New_PaperItem_Data := New(PColABN_Data, Init);
    tmTerms    :New_PaperItem_Data := New(PTerm_Data, Init);
    tmMessage  :New_PaperItem_Data := New(PMessage_Data, Init);
    {$IFNDEF FinalVersion}
    else Abort('Invalid Paper Item Type -- Get_PaperItem_View');
    {$EndIf}
  end;
end; { New_PaperItem_Data }

{ Returns true if the view View is a descendant of TQuestionItem_View }
function IsQuestionView(View :PView) :Boolean;
  var P :Pointer;
begin
  IsQuestionView := False;
  if View = nil then Exit;
  P := Typeof(View^);
  IsQuestionView := (P = typeof(TMonkeyPuzzle_View)) or
                    (P = typeof(TColABN_View)) or
                    (P = typeof(TColumnAB_View)) or
                    (P = typeof(TTerm_View));
end; { IsQuestionView }


begin
  { Stream Registration }
  RegisterType(RPaperItem_Data);
  RegisterType(RQuestionItem_Data);
  RegisterType(RAfdeling_Data);
  RegisterType(RSubColABN);
  RegisterType(RColABN_Data);
  RegisterType(RSubColumnAB);
  RegisterType(RColumnAB_Data);
  RegisterType(RSubMonkey);
  RegisterType(RMonkeyPuzzle_Data);
  RegisterType(RMessage_Data);
  RegisterType(RSubTerm);
  RegisterType(RTerm_Data);
end. { Unit }{****************************************************************************}
{*  TestMaker Test Paper Creating Tool                                      *}
{*    Edit by Hannes de Jager 1996 & 1997                                   *}
{*  Basic object types                                                      *}
{*                                                                          *}
{* Implementation of the following objects                                  *}
{*   þ TBounds for screen coordinates                                       *}
{*   þ TFileCollection  : A collection of files                             *}
{*   þ TDriveCollection : A collection of drives                            *}
{****************************************************************************}
Unit sBasic;
  {$F-,O-,Q-,R-,S-}

interface
  uses Objects, sTypes;

{***þ TBounds object þ***}
type
  TBounds = object(TRect)
    function  WithIn(P :TPoint) :Boolean;
    function  Width  :Integer;
    function  Height :Integer;
  end;

{***þ File Collection þ***}
type
  PFileItem = ^TFileItem;
  TFileItem = record
    Attr :Byte;
    Time :Longint;
    Size :Longint;
    Name :TFileStr;
  end;

  PFileCollection = ^TFileCollection;
  TFileCollection = Object(TCollection)
    procedure FreeItem(Item: Pointer); virtual;
  end;

{***þ Drive Collection þ***}
type
  PDriveItem = ^TDriveItem;
  TDriveItem = record
    Drive  :Char;
    Volume :String[11];
    Size   :LongInt;
    Free   :LongInt;
  end;

  PDriveCollection = ^TDriveCollection;
  TDriveCollection = Object(TCollection)
    procedure FreeItem(Item: Pointer); virtual;
  end;



implementation

{ Returns true if the given point resides within then bounding rectangle
  represented by the object }
function TBounds.WithIn(P :TPoint) :Boolean;
begin
  WithIn := (P.X >= A.X) and (P.X <= B.X) and
            (P.Y >= A.Y) and (P.Y <= B.Y);
end;

{ Returns the width of the bounding rectangle }
function TBounds.Width :Integer;
begin
  Width := B.X-A.X;
end;

{ Returns the width of the height of the bounding rectangle }
function TBounds.Height :Integer;
begin
  Height := B.Y-A.Y;
end;

{****************************************************************************}
{*  TFileCollection                                                              *}
{****************************************************************************}
procedure TFileCollection.FreeItem(Item :Pointer);
begin
  Dispose(PFileItem(Item));
end;

{****************************************************************************}
{*  TDriveCollection                                                              *}
{****************************************************************************}
procedure TDriveCollection.FreeItem(Item :Pointer);
begin
  Dispose(PDriveItem(Item));
end;



end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{*                                                                          *}
{* Implementation of the following objects                                  *}
{*   þ Password input window                                                *}
{*   þ File load and save window                                            *}
{*   þ Main Menu Mode Selector                                              *}
{****************************************************************************}
Unit Selector;
  {$F+,O+,Q-,R-,S-}

Interface
  uses Objects, sBasic, sView, sGraph, sInput, STDViews, sTypes, Dos,
       consts;

{***þ The Popup password window þ***}
type
  ttPassword = String[30];

type
  PPasswordWin  = ^TPasswordWin;
  TPasswordWin = Object(TViewGroup)
    Password :PString;
    constructor Init(PW :String);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   Listen(var Speech :TSpeech); virtual;
  end;

{***þ Data transfer record for TInfoPane þ***}
type
  TTInfoPane = record
    tMask      :String[12];
    tDirectory :String[79];
  end;

{***þ INFO PANE þ***}
type
  PInfoPane = ^TInfoPane;
  TInfoPane = Object(TView)
    Mask, Directory :PString;
    constructor Init;
    destructor  Done; virtual;
    procedure   Art; virtual;
    function    DataSize :Word; virtual;
    procedure   SetData(var Data); virtual;
  end;

{***þ FILE LISTER þ***}
type
  PFileLister = ^TFileLister;
  TFileLister = Object(TListscroller)
    Mask :PString;
    constructor Init;
    destructor  Done; virtual;
    procedure   BarChanged; virtual;
    function    GetString(Index :Word) :String; virtual;
    procedure   Selected(Index :Word); virtual;
    procedure   Update;
  end;

{***þ DIRECTORY LISTER þ***}
type
  PDirLister = ^TDirLister;
  TDirLister = Object(TListScroller)
    constructor Init;
    function    GetString(Index :Word) :String; virtual;
    procedure   Selected(Index :Word); virtual;
    procedure   Update;
  end;

{***þ DRIVELISTER þ***}
  PDriveLister = ^TDriveLister;
  TDriveLister = Object(TListScroller)
    MaxHeight :Integer;
    constructor Init;
    function    GetString(Index :Word) :String; virtual;
    procedure   Selected(Index :Word); virtual;
    procedure   Update;
  end;

{***þ File, Directory and Drive LISTER þ***}
type
  PSetLister = ^TSetLister;
  TSetLister = Object(TViewGroup)
    PrevPath  :PString;
    DriveList :PDriveLister;
    DirList   :PDirLister;
    FileList  :PFileLister;
    NameLine  :PInputline;
    InfoPane  :PInfoPane;
    LoadMode  :Boolean;
    constructor Init(InLoadMode :Boolean);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   Listen(var Speech :TSpeech); virtual;
    function    SetFileName(Name :String) :boolean;
  end;

{***þ Mode Selector þ***}
type
  PModeSelector = ^TModeSelector;
  TModeSelector = Object(TViewGroup)
    constructor Init;
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    procedure   GotFocus; virtual;
  end;

{***þ Routines þ***}
  function GetFiles(Mask :TFileName) :PFileCollection;
  function GetDirs :PFileCollection;
  function GetDrives :PDriveCollection;

Implementation
  uses Graph, Main, sProcs, sMsg, TMData;

constructor TPasswordWin.Init(PW :String);
  var B :TBounds;
begin
  { Center }
  B.Assign(GetMaxX shr 1 - 170, GetMaxY shr 1 - 50,
           GetMaxX shr 1+ 170, GetMaxY shr 1 + 50);
  inherited Init(B);
  Lock;
  B.Assign(90, 35, Size.X-15, 55);
  Append(New(PInputLine, Init(B, 30, '', [#32..#255])));
  B.Assign(20, 70, Size.X-20, 85);
  Append(New(PButton, Init(B, 'Aanvaar', cmAccept, hcNoContext)));
  SelectNext;
  Unlock;
  Password := NewStr(PW);
end; { TPasswordWin.Init }

destructor TPasswordWin.Done;
begin
  DisposeStr(Password);
  inherited Done;
end; { TPasswordWin.Done }

procedure TPasswordwin.Art;
begin
  Platform(0, 0, Size.X, Size.Y, $F008);
  Platform(5, 5, Size.X-5, Size.Y-5, $8B09);
  { Draw Caption }
  Platform(6, 6, Size.X-6, 26,  $F805);
  WriteStrXY(Size.X shr 1, 13, $0E, 2, 5, JustCenter,
    False, 'Testmaker Wagwoord Proteksie');
  WriteStrXY(20, 38, $0E, 2, 4, JustLeft, False, 'Wagwoord :');
end; { TPasswordWin.Art }

procedure TPasswordWin.Listen(var Speech :TSpeech);
  var Tf :ttPassword;
begin
  if Speech.Tone = spCommand then
    if Speech.What = cmAccept then
    begin
      GetData(Tf);
      if SUpper(TF) = SUpper(Password^) then
        EndModal(cmYes) else EndModal(cmNo);
    end;
end;

{****************************************************************************}
{*  TInfopane                                                               *}
{*  The infopane is a view displaying the current directory and file mask   *}
{****************************************************************************}
constructor TInfoPane.Init;
  var B :TBounds;
      S :String;
begin
  B.Assign(30, 160, 420, 170);
  inherited Init(B);
  Mask := NewStr('*.TMS');
  GetDir(0, S);
  Directory := NewStr(S);
end; { TInfoPane.Init }

destructor TInfoPane.Done;
begin
  inherited done;
end; { TInfoPane.Done }

procedure TInfoPane.Art;
begin
  Platform(0, 0, Size.X, Size.Y, $7707);
  Platform(Size.X-80, 0, Size.X, Size.Y, $0F09);
  Platform(0, 0, Size.X-85, Size.Y, $0F09);
  WriteStrXY(Size.X-40, 4, $F, 2, 4, JustCenter, False, Mask^);
  SetTextJustify(LeftText, CenterText);
  OutTextXY(8, 4, Directory^);
end; { TInfoPane.Art }

function TInfoPane.DataSize :Word;
begin
  DataSize := 79+12;
end; { TInfoPane.DataSize }

procedure TInfoPane.SetData(var Data);
begin
  { Free previous values }
  if Mask <> nil then DisposeStr(Mask);
  if Mask <> nil then DisposeStr(Directory);
  with TTInfoPane(Data) do
  begin
    Mask := NewStr(tMask);
    Directory := NewStr(tDirectory);
  end;
  Draw;
end; { TInfoPane.SetData }

{****************************************************************************}
{*  TFileLister                                                             *}
{*  The FileLister Object is a view object providing a scrollable list of   *}
{*  file names obtained from the current directory                          *}
{****************************************************************************}
constructor TFileLister.Init;
  var B :TBounds;
begin
  B.Assign(30, 50, 150, 140);
  inherited Init(B, GetFiles('*.TMS'));
  Mask := NewStr('*.TMS');
end; { TFileLister.Init }

destructor TFileLister.Done;
begin
  if Mask <> nil then DisposeStr(Mask);
  Inherited Done;
end; { TFileLister.Done }

{ Called whenever the current directory have changed.
  It sets up a new list of the files in the current directory by calling
  NewItems and then notifies the owner of the object }
procedure TFileLister.Update;
begin
  NewItems(GetFiles(Mask^));
  Message(Owner, spNotify, msgFileChanged, nil);
end; { TFileLister.Update }

function TFileLister.GetString(Index :Word) :String;
  var P :PFileItem;
begin
  P := PFileItem(ItemPtr(Index));
  if P <> nil then GetString := P^.Name else GetString := '';
end; { TFileLister.GetString }

Procedure TFileLister.Selected(Index :Word);
begin
  Message(Owner, spCommand, cmAccept, nil);
end; { TFileLister.Selected }

procedure TFileLister.BarChanged;
begin
  Message(Owner, spNotify, msgFileChanged, nil);
end; { TFileLister.BarChanged }

{****************************************************************************}
{*  TDirLister                                                              *}
{*  The DirLister Object is a view object providing a scrollable list of    *}
{*  directory names obtained from the current directory                     *}
{****************************************************************************}
constructor TDirLister.Init;
 var B :TBounds;
begin
  B.Assign(160, 50, 280, 140);
  inherited Init(B, GetDirs);
end; { TDirLister.Init }

{ Called whenever the current path has changed. Constructs a new list
  of Items and then notifies the owner of the List object }
procedure TDirLister.Update;
begin
  NewItems(GetDirs);
  Message(Owner, spNotify, msgDirChanged, nil);
end; { TDirLister.Update }

function TDirLister.GetString(Index :Word) :String;
  var P :PFileItem;
begin
  P := PFileItem(ItemPtr(Index));
  if P <> nil then GetString := P^.Name else GetString := '';
end; { TDirLister.Getstring }

procedure TDirLister.Selected(Index :Word);
  var Dir :TDirStr;
      B :TBounds;
begin
  { Change to newly selected directory }
  Dir := GetString(Index);
  if Dir = 'No Sub-Dirs' then exit;
  {$I-}
  ChDir(Dir);
  { Display error Message if Error }
  if (IOResult <> 0) then
  begin
    B.Assign(125,200,515,300);
    MessageWindow(B, #3'Gids ongeldig of aandrywer nie gereed',
                  mwfError+mwfOk);
  end
  { Update if no error }
  else Update;
  {$I+}
end; { TDirLister.Selected }

{****************************************************************************}
{*  TDriveLister                                                            *}
{*  The DriveLister Object is a view object providing a scrollable list of  *}
{*  all the valid drives on the computer, as well as their volume labels    *}
{****************************************************************************}
constructor TDriveLister.Init;
  var B :TBounds;
begin
  B.Assign(290, 50, 420, 140);
  inherited Init(B, GetDrives);
end; { TDriveLister.Init }

{ Updates the scrollers list by calling Update.
  Then it notifies the owner of the View object }
procedure TDriveLister.Update;
begin
  NewItems(GetDrives);
  Message(Owner, spNotify, msgDriveChanged, nil);
end; { TDriveLister.Update }

function TDriveLister.GetString(Index :Word) :string;
begin
  with PDriveItem(ItemPtr(Index))^ do
    GetString := Drive + ': ' + Volume;
end; { TDriveLister.GetString }

procedure TDriveLister.Selected(Index :Word);
  var Drive :Char;
      B :TBounds;
begin
  if Count > 0 then Drive := PDriveItem(Items^.At(Index))^.Drive;
  if Drivevalid(Drive) then
  begin
    {$I-}

    ChDir(Drive+':');
    {$I+}
    { Display error Message on error }
    if (IOResult <> 0) or (DiskSize(ord(Drive)-64) < 1) then
    begin
      B.Assign(125,200,515,300);
      MessageWindow(B, #3'Aandrywer ongeldig of nie gereed',  mwfError+mwfOk)
    end
    { Update if no error }
    else Update;
  end;
end; { TDriveLister.Selected }

{****************************************************************************}
{*  TSetLister                                                              *}
{*  The SetLister Object is a view group using all of the above views to    *}
{*  implement a Open file toolbox.                                          *}
{****************************************************************************}
constructor TSetLister.Init(InLoadMode :Boolean);
  var B :TBounds;
      S :String[80];
  const ValidFileChars = [#32..#255] -
                         [';','''','=','+','<','>','|','"','[',']','\'];
begin
  B.Assign(20, 100, GetMaxX-22, 280);
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable;
  GetDir(0, S);
  PrevPath := NewStr(S);
  LoadMode := InLoadMode;
  Lock;
  { Lists }
  New(FileList, Init);
  New(DirList, Init);
  New(DriveList, Init);
  Append(FileList);
  Append(DirList);
  Append(DriveList);
  { NameLine }
  B.Assign(440, 50, Size.X-30, 70);
  NameLine := New(PInputLine, Init(B, 12,
                  FileList^.GetString(FileList^.CurStr), ValidFileChars));
  Append(NameLine);
  { Buttons }
  B.Assign(440, 80, Size.X-30, 110);
  if LoadMode then S := 'Laai Lˆer' else S := 'Stoor Lˆer';
  Append(New(PButton, Init(B, S, cmAccept, 0)));
  B.Assign(440, 120, Size.X-30, 140);
  Append(New(PButton, Init(B, 'Kanselleer', cmCancel, 0)));
  B.Assign(440, 120, Size.X-30, 140);
  InfoPane := New(PInfoPane, Init);
  Append(InfoPane);
  SelectNext;
  { update the object self }
  Message(@Self, spNotify, msgFileChanged, nil);
  Unlock;
end; { TSetLister.Init }

destructor TSetLister.Done;
begin
  {$I-}
  ChDir(PrevPath^);
  If IOResult <> 0 then
    Abort('Fatal Error :Disk not Ready --- TSetLister.Done');
  {$I+}
  DisposeStr(PrevPath);
  inherited done;
end; { TSetLister.Done }

procedure TSetLister.Art;
  var C :Byte; S:String[20];
      P :PBitImage;
begin
  if LoadMode then
  begin
    C := $0C;
    S := 'TestMaker Lˆer Open';
  end
  else
  begin
    C := $09;
    S := 'TestMaker Leˆr Stoor';
  end;
  Platform(0, 0, Size.X, Size.Y, $F808);
  Platform(5, 5,  Size.X-5, Size.Y-5, LowerGrey);
  Platform(6, 6,  Size.X-6, 26, $F000+C);
  WriteStrXY(Size.X shr 1, 12, $1E, 2, 5, JustCenter, False, S);
  { Tags }
  WriteStrXY(90, 45, ShadowWhite, 1, 1, JustCenterX+JustBottom, False, 'Leˆrs:');
  WriteStrXY(230, 45, ShadowWhite, 1, 1, JustCenterX+JustBottom, False, 'Dirs:');
  WriteStrXY(360, 45, ShadowWhite, 1, 1, JustCenterX+JustBottom, False, 'Aandrywers:');
  WriteStrXY(490, 45, ShadowWhite, 1, 1, JustCenterX+JustBottom, False, 'Naam:');
  P := PBitImage(GetResource('Papers1'));
  if P <> nil then
  begin
    P^.Put(445, 142, XorPut);
    P^.Put(475, 142, XorPut);
    P^.Put(505, 142, XorPut);
    P^.Put(535, 142, XorPut);
    Dispose(P, Done);
  end;
end; { TSetLister.Art }

procedure TSetLister.Listen(var Speech :TSpeech);

    { Updates the FileName Input Line }
    procedure UpdateNameLine;
      var S :String[12];
    begin
      S := SRemoveCh(FileList^.GetString(FileList^.CurStr), ' ');
      NameLine^.SetData(S);
    end;

    { Updates the FileList and Info Pane on a directory change }
    procedure UpdateDirChange;
      var Info :TTinfoPane;
          S :String;
    begin
      FileList^.Update;
      with info do
      begin
        tMask := SUpper(FileList^.Mask^);
        GetDir(0, S);
        tDirectory := S;
      end;
      InfoPane^.SetData(Info);
    end;

    { Called when the user chooses a certain filename to be opened }
    Procedure AcceptFile;
      var S :String[12];
          S2 :String[79];
    begin
      NameLine^.GetData(S);
      if S = '' then Exit;
      if (SFScan(S, '*') > 0) or (SFScan(S, '?') > 0) then
      begin
        with FileList^ do
        begin
          if Mask <> nil then DisposeStr(Mask);
          Mask := NewStr(S);
        end;
        UpdateDirChange;
      end
      else
      begin
        GetDir(0, S2);
        if S2[Length(S2)] = '\' then Dec(S2[0]);
        if SetFileName(S2+'\'+S) then EndModal(cmAccept);
      end;
    end;

begin { TSetLister.Listen }
  Case Speech.Tone of
    spCommand :
      case Speech.What of
        cmAccept :AcceptFile;
        cmCancel :EndModal(cmCancel);
        else begin inherited Listen(Speech); exit; end;
      end;
    spNotify :
      case Speech.What of
        msgFileChanged  :UpdateNameLine;
        msgDirChanged   :UpdateDirChange;
        msgDriveChanged :DirList^.Update;
        else begin inherited Listen(Speech); exit; end;
      end;
  end;
  SpeechHeard(Speech);
end; { TSetLister.Listen }

function TSetLister.SetFileName(Name :String) :boolean;
  var f :File;
      B :TBounds;
begin
  SetFileName := True;
  { Add a .TMS extention if none exists }
  if SFScan(Name, '.') = 0 then Name := Name+'.TMS';
  if LoadMode then
  begin
    { Display error if no such file exists }
    if not FileExists(Name) then
    begin
      B.Assign(125,200,515,300);
      MessageWindow(B, #3'Lˆer kon nie gevind word nie', mwfError+mwfOk);
      SetFileName := False;
      Name := '';
      NameLine^.SetData(Name);
      Exit;
    end;
  end {if}
  else
  begin
    { Confirm Overwrite }
    if FileExists(Name) then
    begin
      B.Assign(125,200,515,300);
      if MessageWindow(B, #3'Herskryf '+GetFileNameOnly(Name)+' ?',
                       mwfConfirmation+mwfYes+mwfNo) = cmNo then
      begin
        SetFileName := False;
        Exit;
      end;
    end;{if}
  end;{else}
  { Do not set global filename if not valid }
  if not PaperData^.ValidFilename(Name) then
  begin
    SetFileName := False;
    PaperData^.NotifyOfError;
  end {if}
  else
  begin
    SetFilename := True;
    if LoadMode then
    begin
      Dispose(PaperData, Done);
      New(PaperData, Init(Name));
    end
    else
    begin
      DisposeStr(PaperData^.FileName);
      PaperData^.FileName := NewStr(Name);
    end;
  end; {else}
end; { TSetLister.SetFileName }


{****************************************************************************}
{*  TModeSelector                                                           *}
{*  The Modeselector is a menu view object providing scrollable buttons for *}
{*  the main menu options, producing a command by means of the buttons when *}
{*  a option is chosen.                                                     *}
{****************************************************************************}
constructor TModeSelector.Init;
  var B :TBounds;
begin
  B.Assign(20, 130, GetMaxX-22, 400);
  Inherited Init(B);
  ViewOptions := ViewOptions or voSelectable;
  { Add Buttons }
  Lock;
  B.Assign(25, 30, 240, 90);
  Append(New(PButton, Init(B, 'Stel ''n Toets Op', cmEditMenu, HcButOpstel)));
  B.Assign(25, 105, 240, 165);
  Append(New(PButton, Init(B, 'Maak ''n Uitdruk', cmPrintMenu, HcButPrint)));
  B.Assign(25, Size.Y-90, 240, Size.Y-30);
  Append(New(PButton, Init(B, 'Verlaat TestMaker', cmQuit, HcButVerlaat)));
  SelectNext;
  Unlock;
end; { TModeSelector.Init }

destructor TModeSelector.Done;
begin
  Inherited Done;
end; { TModeSelector.Done }

procedure TModeSelector.Art;
  var P :PBitImage;
begin
  Platform(0, 0, Size.X, Size.Y, RaiseGrey);
  Level(260, 15, Size.X-15, Size.Y-15, RaiseGrey);
  Platform(15, 15, 250, Size.Y-15, LowerGrey+$80);
  P := PBitImage(GetResource('IntroLogo'));
  if P <> nil then
  begin
    P^.Put(265, 20, NormalPut);
    Dispose(P, Done);
  end;
end; { TModeSelector.Art }

procedure TModeSelector.KeybordInput(var Input :TKeybordInput);
begin
  inherited KeybordInput(Input);
  case Input.Keycode of
    kbUp   :SelectPrevious;
    kbDown :SelectNext;
  end;
end; { TModeSelector.KeybordInput }

procedure TModeSelector.GotFocus;
begin
  PutMessage(spCommand, cmStatustext, NewStr('Testmaker Hoofmenu : Kies asseblief ''n modus'));
end;

{****************************************************************************}
{*  Routines                                                                *}
{****************************************************************************}

{ GetFiles obtain a list of all the files in the current directory
  and save it in a PFileCollection type }
function GetFiles(Mask :TFileName) :PFileCollection;
  var Files    :PFileCollection;
      FileInfo :SearchRec;
      FileItem :PFileItem;

    { Insert spaces into the filename, ensuring it is 12 characters wide }
    procedure PadName(var FileItem :TFileItem);
      var S :TFileStr;
          DotPos :Byte;
    begin
      S := FileItem.Name;
      DotPos := SFScan(S, '.');
      if DotPos = 0 then Exit;
      SSetLen(FileItem.Name, DotPos - 1);
      System.Delete(S, 1, DotPos-1);
      FileItem.Name := SPad(FileItem.Name, ' ', 8);
      FileItem.Name := Concat(FileItem.Name, S);
    end;

    { Copies FileRec into FileItem }
    procedure Transfer(FileRec :SearchRec; var FileItem :TFileItem); assembler;
      const Size = Sizeof(TFileItem);
    asm
      PUSH DS
      LDS  SI, FileRec
      LES  DI, FileItem
      ADD  SI, 21            { Set Pointer to Attr field of FileRec }
      MOV  CX, Size
      REP  MOVSB             { Copy }
      POP  DS
    end;

begin
  { construct List }
  New(Files, Init(20, 5));
  { Fill List }
  FindFirst(Mask, Hidden+Archive, FileInfo);
  while DosError = 0 do
  begin
    New(FileItem);
    Transfer(FileInfo, FileItem^);
    PadName(FileItem^);
    Files^.Insert(FileItem);
    FindNext(FileInfo);
  end;
  { Return Value }
  GetFiles := Files;
end; { procedure GetFiles }

{ GetDirs obtains the names of the sub-directories in the current directory
  and sets up a list. }
function GetDirs :PFileCollection;
  var DirInfo :SearchRec;
      DirItem :PFileItem;
      Dirs    :PFileCollection;
      S       :String;

    { Insert spaces into the filename, ensuring it is 12 characters wide }
    procedure PadName(var FileItem :TFileItem);
      var S :TFileStr;
          DotPos :Byte;
    begin
      S := FileItem.Name;
      DotPos := SFScan(S, '.');
      if (DotPos = 0) or (DotPos = 1) then Exit;
      SSetLen(FileItem.Name, DotPos - 1);
      System.Delete(S, 1, DotPos-1);
      FileItem.Name := SPad(FileItem.Name, ' ', 8);
      FileItem.Name := Concat(FileItem.Name, S);
    end;

    { Copies FileRec into FileItem }
    procedure Transfer(FileRec :SearchRec; var FileItem :TFileItem); assembler;
      const Size = Sizeof(TFileItem);
    asm
      PUSH DS
      LDS  SI, FileRec
      LES  DI, FileItem
      ADD  SI, 21            { Set Pointer to Attr field of FileRec }
      MOV  CX, Size
      REP  MOVSB             { Copy }
      POP  DS
    end;

begin
  { construct list }
  New(Dirs, Init(10, 2));
  { Fill List }
  FindFirst('*.*', Directory, DirInfo);
  while DosError = 0 do
  begin
    with DirInfo do
      if (Name <> '.') and (Attr = Directory) then
      begin
        New(DirItem);
        Transfer(DirInfo, DirItem^);
        PadName(DirItem^);
        Dirs^.Insert(DirItem);
      end;
    FindNext(DirInfo);
  end;
  GetDirs := Dirs;
end; { Getdirs }

{ Fills a List with the names and volumes of all the valid drives
  on the computer. }

function GetDrives :PDriveCollection;
  var I :Char;
      DriveItem :PDriveItem;
      Drives    :PDriveCollection;
      VolInfo   :SearchRec;
begin
  New(Drives, Init(3, 1));
  for I := 'A' to 'Z' do
  if PhysDriveValid(I) then
  begin
    FindFirst(I+':\*.*', VolumeID, VolInfo);
    if Doserror = 0 then VolInfo.Name := SRemoveCh(VolInfo.Name, '.')
    else VolInfo.Name := 'Geen Volume';
    { set record }
    New(DriveItem);
    with DriveItem^ do
    begin
      Drive  := I;
      Size   := DiskSize(ord(I)-64);
      if Size > 0 then
      begin
        Volume := VolInfo.Name;
        Free   := DiskFree(ord(I)-64)
      end
      else
      begin
        Free := 0;
        Volume := 'Nie Gereed';
      end;
    end;
    Drives^.Insert(DriveItem);
  end;
  GetDrives := Drives;
end; { GetDrives }


end. { Unit }{****************************************************************************}
{*  TestMaker Test Paper Creating Tool                                      *}
{*    Edit by Hannes de Jager 1996 & 1997                                   *}
{*  Screen graphics support                                                 *}
{****************************************************************************}
Unit SGraph;
  {$F-,O-,Q-,R-,S-}

Interface
  uses Objects, SProcs, sInput;

{***þ Level Change Colors þ***}
const
  RaiseBlack   = $7800;
  LowerBlack   = $8700;
  RaiseBlue    = $F109;
  LowerBlue    = $1F09;
  RaiseGreen   = $F20A;
  LowerGreen   = $2F0A;
  RaiseCyan    = $B803;
  LowerCyan    = $8B03;
  RaiseRed     = $F40C;
  LowerRed     = $4F0C;
  RaiseMagenta = $F50D;
  LowerMagenta = $5F0D;
  RaiseGrey    = $F807;
  LowerGrey    = $8F07;
  RaiseYellow  = $F60E;
  LowerYellow  = $6F0E;

{***þ Shadow Write Colors þ***}
const
  ShadowBlue    = $29;
  ShadowGreen   = $3A;
  ShadowCyan    = $4B;
  ShadowRed     = $5C;
  ShadowMagenta = $6D;
  ShadowGrey    = $97;
  ShadowYellow  = $7E;
  ShadowWhite   = $1F;

{***þ Justification þ***}
const
  JustLeft    =  $01;
  JustRight   =  $02;
  JustTop     =  $04;
  JustBottom  =  $08;
  JustCenterX =  $10;
  JustCenterY =  $10;
  JustCenter  =  $30;

{***þ Bit Image Put Modes þ***}
const
  imgpmNormal = 0;
  imgpmCopy   = 0;
  imgpmXor    = 1;
  imgpmOr     = 2;
  imgpmAnd    = 3;
  imgpmNot    = 4;

{***þ Draw Settings Masks þ***}
const
  dsDrawColor      = $01;
  dsBGColor        = $02;
  dsFillColor      = $04;
  dsFillPattern    = $08;
  dsLineStyle      = $10;
  dsLinePattern    = $20;
  dsLineThickness  = $40;
  dsColor          = $03;
  dsFill           = $0C;
  dsLine           = $70;
  dsAll            = $FF;

{***þ Text Settings Masks þ***}
const
  tsFont        = $01;
  tsDirection   = $02;
  tsCharSize    = $04;
  tsXJustify    = $10;
  tsYJustify    = $20;
  tsJustify     = $30;
  tsAll         = $FF;

{***þ Color type þ***}
type
  TColor = Word;

{***þ BitMap Type þ***}
type
  PBitmap = ^TBitmap;
  TBitmap = record
    Width    :Word;
    Height   :Word;
    Reserved :Word;
    Image    :record end;
  end;

{***þ BitMap Image object þ***}
type
  PBitImage = ^TBitImage;
  TBitImage = Object(TObject)
    Bitmap  :PBitmap;
    constructor Init(X1, Y1, X2, Y2 :Integer);
    destructor  Done; virtual;
    constructor Load(var S :TStream);
    function    Height :Word;
    procedure   Put(X, Y :Integer; PutMode :Byte);
    function    Size   :Word;
    procedure   Store(var S: TStream);
    function    Width  :Word;
  end;


{***þ ViewPort Type þ***}
type
 PViewPort = ^TViewPort;
 TViewPort = Object(TObject)
   Origin :TPoint;
   Size   :TPoint;
   Clip   :Boolean;
   constructor GetActive;
   constructor Assign(X1, X2, Y1, Y2 :Integer; ClipIt :Boolean);
   destructor  Done; virtual;
   procedure   AbsPoint(var P :TPoint);
   procedure   SetActive;
   procedure   FullScreen;
 end;

{***þ Draw Settings type þ***}
type
  PDrawSettings = ^TDrawSettings;
  TDrawSettings = Object(TObject)
    DrawColor     :TColor;
    BGColor       :TColor;
    FillColor     :TColor;
    FillPattern   :Word;
    LineStyle     :Word;
    LinePattern   :Word;
    LineThickness :Word;
    constructor GetActive;
    constructor Assign(DCol, BGCol, FillCol :TColor; FPat, LStyle, LPat, LThick :Word);
    procedure   SetActive(Which :Word);
    procedure   Defaults;
  end;

{***þ Text Settings type þ***}
type
  PTextSettings = ^TTextSettings;
  TTextSettings = Object(TObject)
    Font      :Byte;
    Vertical  :Boolean;
    CharSize  :Word;
    Just      :Byte;
    constructor GetActive;
    constructor Assign(fnt :Byte; Vert :Boolean; ChSize :Word; AJust :Byte);
    procedure   SetActive(Which :Word);
    procedure   Defaults;
  end;

{***þ Settings type for Save and restore of Settings þ***}
type
  PSettings = ^TSettings;
  TSettings = Record
    ViewPort :TViewPort;
    Draw     :TDrawSettings;
    Text     :TTextSettings;
  end;

{***þ Drawing þ***}

  { WriteStrXY draws a string at Position (X, Y) Colors in Colors,
    the font Font, the givven Character Size, justification and String S.
    If Vert is true the text are displayed vertically.
    Two digit hexadecimal format are used for the colors. The least
    significant digit represents the foreground color whereas the other digit
    represents the color of the shadow. The Most significant digit is
    zero if no shadow is added, else the color value+1.
    Thus to display White Text with a black shadow, the color parameter would
    be $1F }
  procedure WriteStrXY(X, Y :Integer; Colors :Byte; Font, ChrSize,
                       Just :Word; Vert :Boolean;  S :String);

  { Works the same way as WriteStrXY, but does a Integer to String conversion
    with a certain width at first }
  procedure WriteIntXY(X, Y :Integer; Colors :Byte; Font, ChrSize,
                       Just :Word; Vert :Boolean; Num :Word; Width :Byte);

  { Displays a 3-dimentional platform using a 4-digit hexadecimal
    representation for the color values. If $ABCD is a color value then :
     A = Left & top frame Line color of the Platform.
     B = Bottom & right frame Line color of the Platform.
     C = Fill style+1
     D = Fill Color }
  procedure PlatForm(X1, Y1, X2, Y2 :Integer; Colors :Word);

  { Level works the same way as Platform exept that it does not fill the
    inner part.}
  procedure Level(X1, Y1, X2, Y2 :Integer; Colors :Word);

  { LevelColors is a 4-digit hex color value used for procedure Platform
    and -Level. SwapLevel will swap the level of the platform. In other words
    if the color value ($2002) made the platform appear raised when passed to
    Platform it will now make it appear Lowered($0202) }
  function  SwapLevel(LevelColors :Word) :Word;

  { Draws a circle. (X, Y) is the center, R is the radius and C the colors }
  { A 2-digit hex format is used for the color representation. In $XY
    X = Fill Style value +1
    Y = Color }
  procedure DrawCircle(X, Y, R :Integer; C :Word);

  { Draws a 3D Line in the Colors C (3 colors = 3 hex digits) }
  procedure Line3D(X1, Y1, X2, Y2 :Integer; C :Word);

{ Initialization & Cleanup }
  { Initializes the graphics driver }
  procedure InitGraphics;

  { Shuts down the graphics driver }
  procedure DoneGraphics;


{***þ Stream Registration Record þ***}
const
  RBitImage :TStreamRec = (
    ObjType: 10000;
    VmtLink: Ofs(TypeOf(TBitImage)^);
    Load: @TBitImage.Load;
    Store: @TBitImage.Store);


Implementation
  uses Graph, stypes, GrDrivs;

{****************************************************************************}
{*  Bit Image                                                               *}
{****************************************************************************}
{ Initializes the object and gets the image from the screen }
constructor TBitImage.Init(X1, Y1, X2, Y2 :Integer);
begin
  Inherited Init;
  GetMem(BitMap, ImageSize(X1, Y1, X2, Y2));
  GetImage(X1, Y1, X2, Y2, BitMap^);
end;

{ Free Memmory used by the object }
destructor TBitImage.Done;
begin
  if BitMap <> nil then FreeMem(Bitmap, Size);
  Inherited Done;
end;

{ Loads the object from the Stream S }
constructor TBitImage.Load(var S :TStream);
  var W, H :Word;
begin
  TObject.Init;
  S.Read(W, sizeof(Word));
  S.Read(H, sizeof(Word));
  GetMem(BitMap, ImageSize(0, 0, W, H));
  with BitMap^ do
  begin
    Width := W;
    Height := H;
    S.Read(Reserved, ImageSize(0, 0, W, H) - 2*sizeof(Word));
  end; {with}
end;

{ Returns the Height of the image in Pixels }
function TBitImage.Height :Word;
begin
  if BitMap <> nil then Height := Bitmap^.Height else Height := 0;
end;

{ Displays the image at (X,Y) using the asm instruction PutMode }
procedure TBitImage.Put(X, Y :Integer; PutMode :Byte);
begin
  if Bitmap <> nil then PutImage(X, Y, Bitmap^, PutMode);
end;

{ Returns the Size of the Image in Bytes }
function TBitImage.Size :Word;
begin
  Size := ImageSize(0, 0, Width, Height);
end;

{ Stores the Object to the Stream S }
procedure TBitImage.Store(var S: TStream);
begin
  if Bitmap <> nil then S.Write(Bitmap^, Size);
end;

{ Returns the width of the view in Pixels }
function TBitImage.Width :Word;
begin
  if BitMap <> nil then Width := Bitmap^.Width else Width := 0;
end;

{****************************************************************************}
{*  View Port                                                              *}
{****************************************************************************}
{ Sets the viewport to the givven values }
constructor TViewPort.Assign(X1, X2, Y1, Y2 :Integer; ClipIt :Boolean);
begin
  Inherited Init;
  Origin.X := X1;
  Origin.Y := Y1;
  Size.X := X2-X1;
  Size.Y := Y2-Y1;
  Clip := ClipIt;
  SetViewPort(X1, X2, Y1, Y2, ClipIt);
end; { TViewPort.Assign }

{ Set the object fields to the values of the current viewport }
constructor TViewPort.GetActive;
  var Port :ViewPortType;
begin
  GetViewsettings(Port);
  with Port do
  begin
    Origin.X := X1;
    Origin.Y := X2;
    Size.X := X2-X1;
    Size.Y := Y2-Y1;
    Self.Clip := Clip;
  end;
end; { TViewPort.GetActive }

{ destructs the object and set the viewport of the screen to fullsize }
destructor TViewPort.Done;
begin
  FullScreen;
  inherited Done;
end; { TViewPort.Done }

{ converts the Point P to absolute screen coordinates }
procedure TViewPort.AbsPoint(var P :TPoint);
begin
  P.X := Origin.X+P.X;
  P.Y := Origin.Y+P.Y;
end; { TViewPort.AbsPoint }

{ Sets the screen viewport to the values of the object }
procedure TViewPort.SetActive;
begin
  SetViewPort(Origin.X, Origin.Y, Origin.X+Size.X,
              Origin.X+Size.X, Clip);
end; { TViewPort.SetActive }

{ Sets the Viewport to FullScreen }
procedure TViewPort.FullScreen;
begin
  SetViewPort(0, 0, GetMaxX, GetMaxY, ClipOn);
end; { TViewPort.FullScreen }

{****************************************************************************}
{*  Draw Settings Object                                                   *}
{****************************************************************************}
{ Obtains all the current Drawing settings and stores it in the object }
constructor TDrawSettings.GetActive;
  var Fill :FillSettingsType;
      Line :LineSettingsType;
begin
  inherited Init;
  DrawColor := GetColor;
  BGColor := GetBkColor;
  GetFillSettings(Fill);
  FillColor := Fill.Color;
  FillPattern := Fill.Pattern;
  GetLineSettings(Line);
  LineStyle := Line.LineStyle;
  LinePattern := Line.Pattern;
  LineThickness := Line.ThickNess;
end; { TDrawSettings.GetActive }

{ Assigns certain values to the object field }
constructor TDrawSettings.Assign(DCol, BGCol, FillCol :TColor; FPat, LStyle, LPat, LThick :Word);
begin
  Inherited Init;
  DrawColor     := DCol;
  BGColor       := BGCol;
  FillColor     := FillCol;
  FillPattern   := FPat;
  LineStyle     := LStyle;
  LinePattern   := LPat;
  LineThickNess := LThick;
end; { TDrawSettings.Assign }

{ Set the active drawing settings to those described in Which
 Which is a combination of the dsXXXX constants }
procedure TDrawSettings.SetActive(Which :Word);
  var Fill :FillSettingsType;
      Line :LineSettingsType;
begin
  if Which and dsDrawColor  <> 0 then SetColor(DrawColor);
  if Which and dsBGColor    <> 0 then SetBkColor(BGColor);
  if Which and dsFill <> 0 then
  begin
    if Which and dsFill <> dsFill then
    begin
      GetFillSettings(Fill);
      if Which and dsFillColor <> 0 then SetFillStyle(Fill.Pattern, FillColor)
      else SetFillStyle(FillPattern, Fill.Color)
    end {if}
    else SetFillStyle(FillPattern, FillColor);
  end; {if}
  if Which and dsLine <> 0 then
  begin
    if Which and dsLine <> dsLine then
    begin
      GetLineSettings(Line);
      if Which and dsLineStyle <> 0 then Line.LineStyle := LineStyle;
      if Which and dsLinePattern <> 0 then Line.Pattern := LinePattern;
      if Which and dsLineThickness <> 0 then Line.Thickness := Linethickness;
      with Line do SetLineStyle(LineStyle, LinePattern, Linethickness);
    end
    else SetLineStyle(LineStyle, LinePattern, Linethickness);
  end; {if}
end; { TDrawSettings.SetActive }

{ Sets the Fields of the object to the default drawing settings }
procedure TDrawSettings.Defaults;
begin
  DrawColor   := White;
  BGColor     := LightGray;
  FillColor   := White;
  FillPattern := SolidFill;
  LineStyle   := Solidln;
  LinePattern := 0;
  LineThickNess := NormWidth;
end; { TDrawSettings.Defualts }

{****************************************************************************}
{*  Test Settings                                                          *}
{****************************************************************************}
{ Retrieves the active settings for text writing and stores it within the
  object fields }
constructor TTextSettings.GetActive;
  var TextSet :TextSettingsType;
begin
  inherited Init;
  GetTextSettings(TextSet);
  with TextSet do
  begin
    Self.Font := Font;
    Self.CharSize := CharSize;
    Vertical := Direction = VertDir;
    Case Horiz of
      LeftText   :Just := JustLeft;
      RightText  :Just := JustRight;
      CenterText :Just := JustCenterX;
    end;
    Case Vert of
      TopText    :Just := Just + JustLeft;
      BottomText :Just := Just + JustBottom;
      CenterText :Just := Just + JustCenterY;
    end; {case}
  end; {with}
end; { TTextSettings.GetActive }

{ Assigns certain values to the object fields }
constructor TTextSettings.Assign
  (fnt :Byte; Vert :Boolean; ChSize :Word; AJust :Byte);
begin
  Inherited Init;
  Font := fnt;
  Vertical := Vert;
  CharSize := ChSize;
  Just := AJust;
end; { TTextSettings.Assign }

{ Sets the active text writing settings to the values within the object fields }
procedure TTextSettings.SetActive(Which :Word);
  var TextSet :TextSettingsType;
begin
  GetTextSettings(TextSet);
  with TextSet do
  begin
    if Which and tsfont <> 0 then Font := Self.Font;
    if Which and tsDirection <> 0 then
      if Vertical then Direction := VertDir else Direction := HorizDir;
    if Which and tsCharSize <> 0 then CharSize := Self.CharSize;
    if Just and JustRight   <> 0 then Horiz := RightText else
      if Just and JustCenterX <> 0 then Horiz := CenterText else
        Horiz := LeftText;
    if Just and JustBottom  <> 0 then Vert := BottomText else
      if Just and JustCenterY <> 0 then Vert := CenterText else
        Vert := TopText;
    SetTextstyle(Font, Direction, Charsize);
    SetTextJustify(Horiz, Vert);
  end; {with}
end; { TTextSettings.SetActive }

{ Set the Fields of the object to the default text write settings }
procedure TtextSettings.Defaults;
begin
  Font     := DefaultFont;
  Vertical := False;
  CharSize := 1;
  Just     := JustLeft+JustTop;
end; { TTextSettings.Defaults }


{****************************************************************************}
{*  Routines                                                               *}
{****************************************************************************}
{ function described in interface }
Procedure WriteStrXY
  (X, Y :Integer; Colors :Byte; Font, ChrSize, Just :Word;
   Vert :Boolean; S :String);
  var TS :TTextSettings;
begin
  TS.Assign(font, Vert, ChrSize, Just);
  TS.SetActive(tsAll);
  if not (Colors in [0..$F]) then
  begin
    Dec(Colors, $10);
    SetColor(Colors div 16);
    MoveTo(X+ChrSize, Y+ChrSize);
    OutText(S);
  end; {if}
  SetColor(Colors mod 16);
  MoveTo(X, Y);
  OutText(S);
end; { WriteStrXY }

{ function described in interface }
Procedure WriteIntXY
  (X, Y :Integer; Colors :Byte; Font, ChrSize, Just :Word;
   Vert :Boolean; Num :Word; Width :Byte);
  var TS :TTextSettings;
      S  :String;
begin
  TS.Assign(font, Vert, ChrSize, Just);
  TS.SetActive(tsAll);
  S := SInt(Num, Width);
  if not (Colors in [0..$F]) then
  begin
    if Colors = ShadowWhite then SetColor(0) else SetColor(Colors div 16);
    MoveTo(X+6-ChrSize, Y+6-ChrSize);
    OutText(S);
  end; {if}
  SetColor(Colors mod 16);
  MoveTo(X, Y);
  OutText(S);
end; { WriteIntXY }

{ function described in interface }
procedure Level(X1, Y1, X2, Y2 :Integer; Colors :Word);
begin
  SetColor(Hi(Colors) div 16);
  Line(X1, Y1, X2, Y1); Line(X1, Y1, X1, Y2);
  SetColor(Hi(Colors) mod 16);
  Line(X2, Y1, X2, Y2); Line(X1+1, Y2, X2, Y2);
end; { Level }

{ function described in interface }
function SwapLevel(LevelColors :Word) :Word;
begin
  SwapLevel := (Hi(LevelColors) div 16 + Hi(LevelColors) mod 16*16) shl 8
               + Lo(LevelColors);
end; { SwapLevel }

{ function described in interface }
procedure PlatForm(X1, Y1, X2, Y2 :Integer; Colors :Word);
begin
  SetFillStyle(Lo(Colors) div 16+1, Lo(Colors) mod 16);
  Bar(X1, Y1, X2, Y2);
  if Colors > $FF then Level(X1, Y1, X2, Y2, Colors);
end; { Platform }

{ function described in interface }
procedure SwapColors(var Colors :Byte);
begin
  Colors := Colors div 16 + Colors Mod 16 * 16;
end; { SwapColors }

{ function described in interface }
procedure DrawCircle(X, Y, R :Integer; C :Word);
begin
  SetColor(Lo(C) mod 16);
  Circle(X, Y, R);
  if C > $F then
  begin
    SetFillStyle(Lo(C) div 16+1, Hi(C) mod 16);
    FillEllipse(X, Y, R, R);
  end; {if}
end; { DrawCircle }

{ function described in interface }
procedure Line3D(X1, Y1, X2, Y2 :Integer; C :Word);
begin
  Setcolor(Lo(C) div 16);
  Line(X1, Y1, X2, Y2);
  if Y1 = Y2 then Line(X1, Y1+2, X2, Y2+2) else Line(X1+2, Y1, X2+2, Y2);
  Setcolor(Lo(C) mod 16);
  if Y1 = Y2 then Line(X1, Y1+1, X2, Y2+1) else Line(X1+1, Y1, X2+1, Y2);
end; { Line3D }

{ function described in interface }
procedure InitGraphics;
  Var Gd,Gm:Integer;

  procedure Error(Msg :String);
  begin
    Writeln(Msg);
    Halt(1);
  end; {sub proc Error}

Begin
  { Register EGA/VGA Driver }
  if RegisterBGIdriver(@Data_EGAVGADriver) < 0 then
    Error('Grafika Fout: EGA/VGA Aandrywer kon nie gelaai word nie!');
  if (RegisterBGIfont(@Data_GothicFont) < 0) or
     (RegisterBGIfont(@Data_SansSerifFont) < 0) or
     (RegisterBGIfont(@Data_SmallFont) < 0) or
     (RegisterBGIfont(@Data_TriplexFont) < 0) then
    Error('Grafika Fout: Kon nie font laai nie !');
  Gd := Detect;
  InitGraph(Gd, Gm, '');
  If GraphResult <> GrOk then Error('Grafika Inisialiserings Fout !');
end; { InitGraphics }

{ function described in interface }
Procedure DoneGraphics;
begin
  CloseGraph;
  RestoreCrtMode;
end; { DoneGraphics }

begin
  RegisterType(RBitImage);
end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* Support for Keybord and Mouse event handling                             *}
{****************************************************************************}
Unit SInput;
  {$F-,O-,Q-,R-,S-}

Interface
	Uses Objects, sBasic, sInts, sTypes;

{**þ KEYBORD MANAGER þ***************************************************** }

{ ***þ Keybord key record for typecasting þ*** }
type
	TKbKey = record
		Case Integer of
			0 : (KeyCode :Word);
			1 : (CharCode :Char;
					 ScanCode :Byte);
	end;

{***þ Keybord Event Flag  þ***}
const
	inKeyDown         = $0100;     { Key was pressed  }
	inKeyUp           = $0200;     { Key was released }
	inkbStateChanged  = $0400;     { Keybord state changed }

{***þ Extended Keybord Codes þ***}
const
	kbNoKey     = $0000;

	kbUp        = $4800;
	kbDown      = $5000;
	kbLeft      = $4B00;  kbCtrlLeft  = $7300;
	kbRight     = $4D00;  kbCtrlRight = $7400;

	kbIns       = $5200;
	kbDel       = $5300;
	kbHome      = $4700;  kbCtrlHome  = $7700;
	kbEnd       = $4F00;  kbCtrlEnd   = $7500;
	kbPgUp      = $4900;  kbCtrlPgUp  = $8400;
	kbPgDn      = $5100;  kbCtrlPgDn  = $7600;

	kbEsc       = $011B;
	kbTab       = $0F09;
	kbBack      = $0E08;  kbCtrlBack  = $0E7F;
	kbSpace     = $3920;
	kbEnter     = $1C0D;  kbCtrlEnter = $1C0A;

	kbGrayMinus = $4A2D;
	kbGreyMul   = $372A;
	kbGrayPlus  = $4E2B;

												 { Function Keys }
	kbF1    = $3B00;  kbAltF1  = $6800;  kbCtrlF1  = $5E00; kbShiftF1  = $5400;
	kbF2    = $3C00;  kbAltF2  = $6900;  kbCtrlF2  = $5F00; kbShiftF2  = $5500;
	kbF3    = $3D00;  kbAltF3  = $6A00;  kbCtrlF3  = $6000; kbShiftF3  = $5600;
	kbF4    = $3E00;  kbAltF4  = $6B00;  kbCtrlF4  = $6100; kbShiftF4  = $5700;
	kbF5    = $3F00;  kbAltF5  = $6C00;  kbCtrlF5  = $6200; kbShiftF5  = $5800;
	kbF6    = $4000;  kbAltF6  = $6D00;  kbCtrlF6  = $6300; kbShiftF6  = $5900;
	kbF7    = $4100;  kbAltF7  = $6E00;  kbCtrlF7  = $6400; kbShiftF7  = $5A00;
	kbF8    = $4200;  kbAltF8  = $6F00;  kbCtrlF8  = $6500; kbShiftF8  = $5B00;
	kbF9    = $4300;  kbAltF9  = $7000;  kbCtrlF9  = $6600; kbShiftF9  = $5C00;
	kbF10   = $4400;  kbAltF10 = $7100;  kbCtrlF10 = $6700; kbShiftF10 = $5D00;

	kbAlt1  = $7800;
	kbAlt2  = $7900;
	kbAlt3  = $7A00;
	kbAlt4  = $7B00;
	kbAlt5  = $7C00;
	kbAlt6  = $7D00;
	kbAlt7  = $7E00;
	kbAlt8  = $7F00;
	kbAlt9  = $8000;
	kbAlt0  = $8100;

	kbAltA  = $1E00;  kbCtrlA  = $1E01;
	kbAltB  = $3000;  kbCtrlB  = $3002;
	kbAltC  = $2E00;  kbCtrlC  = $2E03;
	kbAltD  = $2000;  kbCtrlD  = $2004;
	kbAltE  = $1200;  kbCtrlE  = $1205;
	kbAltF  = $2100;  kbCtrlF  = $2106;
	kbAltG  = $2200;  kbCtrlG  = $2207;
	kbAltH  = $2300;  kbCtrlH  = $2308;
	kbAltI  = $1700;  kbCtrlI  = $1709;
	kbAltJ  = $2400;  kbCtrlJ  = $240A;
	kbAltK  = $2500;  kbCtrlK  = $250B;
	kbAltL  = $2600;  kbCtrlL  = $260C;
	kbAltM  = $3200;  kbCtrlM  = $320D;
	kbAltN  = $3100;  kbCtrlN  = $310E;
	kbAltO  = $1800;  kbCtrlO  = $180F;
	kbAltP  = $1900;  kbCtrlP  = $1910;
	kbAltQ  = $1000;  kbCtrlQ  = $1011;
	kbAltR  = $1300;  kbCtrlR  = $1312;
	kbAltS  = $1F00;  kbCtrlS  = $1F13;
	kbAltT  = $1400;  kbCtrlT  = $1414;
	kbAltU  = $1600;  kbCtrlU  = $1615;
	kbAltV  = $2F00;  kbCtrlV  = $2F16;
	kbAltW  = $1100;  kbCtrlW  = $1117;
	kbAltX  = $2D00;  kbCtrlX  = $2D18;
	kbAltY  = $1500;  kbCtrlY  = $1519;
	kbAltZ  = $2C00;  kbCtrlZ  = $2C1A;

	kbAltEqual = $8300; kbAltMinus  = $8200;

	kbShiftTab  = $0F00;
	kbPrintScr  = $FE00;
	kbCtrlBreak = $FF00;
	kbCtrlPrtSc = $7200;

{***þ Keybord Shift State Flags þ***}
	ksNone      = $00;
	ksRShift    = $01;
	ksLShift    = $02;
	ksShift     = $03;
	ksCtrl      = $04;
	ksAlt       = $08;
	ksScroll    = $10;
	ksNum       = $20;
	ksCaps      = $40;
	ksInsert    = $80;
	ksAllShifts = $0F;
	ksAllStates = $F0;
	ksAll       = $FF;

{***þ Keybord Object controller þ***}
type
	TKeybord = Object(TObject)
		constructor Init;
		destructor Done; virtual;
		function   ReadKey :Word;
		function   WaitKey :Word;
		function   ReadUpCase :Word;
		function   WaitUpCase :Word;
		function   ReadLegal(Legal :TCharSet) :Word;
		function   WaitLegal(Legal :TCharSet) :Word;
		function   Pressed :Boolean;
		function   StatesOn(Flags :Byte) :Boolean;
		function   StateOn(Flags :Byte) :Boolean;
		function   GetState :Byte;
		procedure  SetState(Flags :Byte; On :Boolean);
		procedure  ClearBuf;
		procedure  PushKey(Key :Word);
		procedure  SetTypeRate(Rate, Delay :Byte);
		procedure  ToggleState(Flags :Byte);
	end;

{ ***þ The keybord controlller þ*** }
var
	Keybord :TKeybord;

{ ***þ Status of the keybord þ*** }
var
	KeybState :Byte absolute $0000:$0417;


{**þ MOUSE MANAGER þ******************************************************* }

{***þ Mouse Button State Masks  þ***}
const
	mbLeft   = $01;  { Left   Button is down }
	mbRight  = $02;  { Right  Button is down }
	mbCenter = $04;  { Center Button is down }

{***þ Mouse Input Masks  þ***}
	inMouseMove   = $0001;  { Mouse Movement }
	inMouseLD     = $0002;  { Left   Button was pressed  }
	inMouseLU     = $0004;  { Left   Button was released }
	inMouseRD     = $0008;  { Right  Button was pressed  }
	inMouseRU     = $0010;  { Left   Button was released }
	inMouseCD     = $0020;  { Center Button was pressed  }
	inMouseCU     = $0030;  { Center Button was released }
	inMouseDown   = $002A;  { A Button was pressed  }
	inMouseUp     = $0054;  { A Button was released }
	inMouseButton = $007E;  { A button was pressed or released }

{***þ Initialized variables þ***}
const
	MouseAvail   :Boolean = False;    { Indicate if a mouse is available   }
	MouseBCount  :Byte = 0;           { The amount of buttons on the mouse }
	MouseReverse :Boolean = False;    { Switch button 1 and button 3       }
	MouseDDelay  :Word = 6;           { Double-Click time interval         }

{***þ Mouse Status variables þ***}
var
	MouseWhere   :TPoint;    { Position of the Mouse Pointer               }
	MouseButtons :Byte;      { Tells which buttons is depressed            }
	MouseEvent   :Word;      { The kind of interrupt that occured          }
	MouseDouble  :Boolean;   { Indicates if a double click occurred or not }
	MouseIntFlag :Boolean;   { Set to true if a mouse event occurred       }

{***þ Mouse control Routines  þ***}

  { Initializes the mouse driver by enabling the mouse interrupt handler
    and showing the mouse pointer. }
	procedure InitMouse;
  { Terminates the Mouse driver by disabling the mouse interrupt handler and
    hiding the mouse }
	procedure DoneMouse;
  { Shows the Mouse Pointer }
	procedure ShowMouse;
  { Hides the Mouse Pointer }
	procedure HideMouse;
  { Move the Mouse Pointer to the specified Location }
	procedure SetMousePos(X, Y :Integer);


{**þ INPUT MANAGER þ*********************************************************}

{***þ Input Interrupt Masks þ***}
const
	inNothing = $0000; { No Input }
	inMouse   = $00FF; { Mouse Input }
	inKeybord = $0F00; { Keybord Input }

{***þ Keybord Input transfer record þ***}
type
	TKeybordInput = record
		What :Word;
		Case Word of
			inNothing :(HandledBy :Pointer);
			inKeybord :(
				ShiftState :Byte;
				Case Integer of
					0 : (KeyCode :Word);
					1 : (CharCode :Char;
							 ScanCode :Byte)
      );
	end;

{***þ Mouse Input transfer record þ***}
type
  TMouseInput = record
    What :Word;
    Case Word of
      inNothing :(HandledBy :Pointer);
      inMouse   :(
        Where   :TPoint;
        Buttons :Byte;
        Double  :Boolean;
      );
  end;

{***þ Routines þ***}
  { Initializes the Input Manager }
	procedure InitInput;
  { Shuts down the Input Manager }
	procedure DoneInput;
  { Obtains keybord Input, returning the result in Input
    If wait is true the procedure waits until a key becomes available.
    If Upcase is true, the CharCode field of Input is converted to Uppercase }
	procedure GetKeyInput(var Input :TKeybordInput; Wait, Upcase :Boolean);
  { Same as GetKeyInput, but ignoring input which Charcode is not contained
    in Legal }
	procedure GetLegalKeyInput(var Input :TKeybordInput; Wait, Upcase :Boolean;
                             Legal :TCharSet);
  { Obtaines the Current Mouse State as Input }
	procedure GetMouseInput(var Input :TMouseInput);
  { Does the same as GetMouseInput then returns true if Mask match
    Input.What }
	function  MouseInputMatch(var Input :TMouseInput; Mask :Word) :Boolean;
  { Does the same as MouseInputMatch, but to return true, the Mouse Pointer
    has to be within the area Bounds }
  function  MouseInputMatchIn(var Input :TMouseInput; Mask :Word;
                         Bounds :TBounds) :Boolean;


Implementation

{**þ KEYBORD þ***************************************************************}

{ The Previous state of the Control-Break Flag in Dos }
var
	LastDosCBreak :Boolean;

{__Keybord Interrupt Handlers________________________________________________}
procedure Push_PrintScr_Key;
begin
	Keybord.PushKey(kbPrintScr);
end;

procedure Push_CtrlBreak_Key;
begin
	Keybord.PushKey(kbCtrlBreak);
end;

	{ Print Screen Interrupt Handler }
procedure IHPrintScreen; assembler;
asm
	{ Save Registers to be Modified }
	PUSH  DS
	PUSH  AX
	PUSH  CX
	{ Push kbPrintScr on the keybord data stream }
	MOV   BX, SEG @DATA
	MOV   DS, BX
	CALL  Push_PrintScr_Key;
	{ Restore Registers }
	POP   CX
	POP   AX
	POP   DS
	{ Return from interrupt }
	IRET
end; { IHPrintScreeen }

 { Control-Break Interrupt Handler }
Procedure IHCtrlBreak; assembler;
asm
	{ Save Registers to Modify }
	PUSH  DS
	PUSH  AX
	PUSH  BX
	{ Push kbCtrlBreak on the keybord data stream }
	MOV   BX, SEG @DATA
	MOV   DS, BX
	CALL  Push_CtrlBreak_Key
	{ Restore Rgisters }
	POP   BX
	POP   AX
	POP   DS
	{ Return from interrupt }
	IRET
end; { IHCtrlBreak }

	{ Control-C Interrupt Handler }
Procedure IHCtrlC; assembler;
asm
	IRET      { Does nothing - Program does not terminate however }
end; { IHCtrlC }

{***þ Constants for Installing and removing interrupt handlers þ***}
const
	HPrintScreen :TIntHandler =
    (Vector :vecPrintScr; Address :@IHPrintScreen);
	HCtrlBreak :TIntHandler =
    (Vector :vecCtrlBreak; Address :@IHCtrlBreak);
	HCtrlC :TIntHandler =
    (Vector :vecCtrlC; Address :@IHCtrlC);

{__TKeybord Implementation___________________________________________________}
constructor TKeybord.Init;
begin
	Inherited Init;
	{ Install Interrupt Handlers }
{	InitHandler(HPrintScreen);}
	InitHandler(HCtrlBreak);
	InitHandler(HCtrlC);
	{ Set the Dos Break flag to off }
	LastDosCBreak := GetDosCBreak;
	SetDosCBreak(False);
	{ Clear the keybord buffer }
	ClearBuf;
end; { TKeybord.Init }

destructor TKeybord.Done;
begin
	{ Uninstall Interrupt handlers }
	DoneHandler(HCtrlC);
	DoneHandler(HCtrlBreak);
	DoneHandler(HPrintScreen);
	{ Set original Dos Break State }
	SetDosCBreak(LastDosCBreak);
	{ Clear the keybord buffer }
	ClearBuf;
	inherited done;
end; { TKeybord.Done }

	{ Reads input from the keybord - If a key has been pressed, it is
		returned as result. Otherwise, kbNoKey is returned  }
function TKeybord.ReadKey :Word; assembler;
asm
	{ Check keybord status }
	MOV   AH, 01H
	INT   IntKeybord
	{ If Zero flag is set then no key was available }
	JZ    @NoKey
	{ Get the key that was available }
	MOV   AH, 00H
	INT   IntKeybord
	JMP   @End
	{ Result is kbNoKey }
@NoKey:
	MOV   AX, kbNokey
@End:
end; { TKeybord.ReadKey }

	{ Waits for key to be pressed on the keybord and return it as result }
function TKeybord.WaitKey :Word; assembler;
asm
	{ Get Keybord key  }
	MOV   AH, 00H
	INT   IntKeybord
end; { TKeybord.WaitKey }

  { Calls ReadKey and then ensures a uppercase Charcode }
function TKeybord.ReadUpCase :Word;
	var Key :Word;
begin
	Key := ReadKey;
	TKbKey(Key).CharCode := Upcase(TKbKey(Key).CharCode);
	ReadUpCase := Key;
end; { TKeybord.ReadUpCase }

 { Wait for a key then does the same as ReadUpCase }
function TKeybord.WaitUpCase :Word;
	var Key :Word;
begin
	Key := WaitKey;
	TKbKey(Key).CharCode := Upcase(TKbKey(Key).CharCode);
	WaitUpCase := Key;
end; { TKeybord.WaitUpCase }

 { Reads a Key from the keybord, ignoring those not having a
   charcode contained in Legal }
function TKeybord.ReadLegal(Legal :TCharSet) :Word;
	var Key :Word;
begin
	Key	:= ReadKey;
	if not (TKbKey(Key).CharCode in Legal) then ReadLegal := kbNoKey
	else ReadLegal := Key;
end; { TKeybord.ReadLegal }

  { Same effect as ReadLegal, Only waits for the Key }
function TKeybord.WaitLegal(Legal :TCharSet) :Word;
	var Key :Word;
begin
	Repeat
		Key	:= WaitKey;
	Until TKbKey(Key).CharCode in Legal;
end; { TKeybord.WaitLegal }

	{ Pushes a keybord keycode on the keybord data stream.
		The same result is achieved as when a key was pressed on the keybord }
procedure TKeybord.PushKey(Key :Word); assembler;
asm
	{ Push key on keybord data stream }
	MOV   AH, 05H
	MOV   CX, Key
	Int   IntKeybord
end; { TKeybord.PushKey }

 {  Returns true if a key has been pressed on the keyboard. }
function TKeybord.Pressed :Boolean; assembler;
asm
	MOV   AH, 01H      { Check keybord status - Int 16h function 01h }
	INT   IntKeybord
	JZ    @NoKey       { If Zero flag is set then no key was available }
	MOV   AL, True
	JMP   @End
@NoKey:
	MOV   AL, False
@End:
end; { TKeybord.Pressed }

	{ Clears the keyboard buffer }
procedure TKeybord.ClearBuf;
begin
	while Pressed do WaitKey;
end;

	{ Sets the typematic rate and delay of the keybord }
procedure TKeybord.SetTypeRate(Rate, Delay :Byte);
begin
	Rate := Abs(Rate-$1F);  { Reverse order of rate - 0 = 31; 31 = 0 etc. }
	asm
		MOV   AH, 03h         { function 03H             }
		MOV   AL, 05h         { Required extra parameter }
		MOV   BH, Delay
		MOV   BL, Rate
		CMP   BH, 3           { Delay must not exceed 3 }
		JBE   @1
		MOV   BH, 3
	@1:
		CMP   BL, 1Fh         { Rate must not exceed 1FH (31) }
		JBE   @2
		MOV   BL, 1Fh
	@2:
		INT   IntKeybord      { Excecute Interrupt 16H }
	end;
end; { TKeybord.SetTypeRate }

	{ Checks whether or not all the bits in Flags are present in
		the keybord status byte at adress $0000:$0417, thus telling
		if a keybord shift state is on or off                     	}
function TKeybord.StatesOn(Flags :Byte) :Boolean; assembler;
asm
	MOV   AH, 02H           { Get Keybord flags - Int 16H function 02H }
	INT   IntKeybord
	AND   AL, Flags         { Remove bits that do not match flags }
	CMP   AL, Flags         { Check if all the flags is present   }
	JE    @1
	MOV   AL, False         { kbShiftOn = false if all is not present }
	JMP   @End
@1:
	MOV   AL, True          { kbShiftOn = true if all is present }
@End:
end; { TKeybord.StatesOn }

function TKeybord.StateOn(Flags :Byte) :Boolean; assembler;
asm
	MOV   AH, 02H           { Get Keybord flags - Int 16H function 02H }
	INT   IntKeybord
	AND   AL, Flags         { Remove bits that do not match flags  }
	CMP   AL, 0             { Check if any of the flags is present }
	JA    @1
	MOV   AL, False         { kbShiftOn = false if all is not present }
	JMP   @End
@1:
	MOV   AL, True          { kbShiftOn = true if all is present }
@End:
end; { TKeybord.StateOn }

function TKeybord.GetState :Byte; assembler;
asm
	{ Get Keybord flags }
	MOV   AH, 02H
	INT   IntKeybord
end; { TKeybord.GetState }

	{ Sets the keybord shift state contained in Flags according to On }
procedure TKeybord.SetState(Flags :Byte; On :Boolean);
begin
	if On then KeybState := KeybState or Flags
	else KeybState := Keybstate - (KeybState and Flags);
end;

	{ Sets the keybord shift state contained in flags to its current opposite }
procedure TKeybord.ToggleState(Flags :Byte);
begin
	KeybState := KeybState xor Flags;
end;


{**þ MOUSE þ*****************************************************************}
var
	LastClock :LongInt; { The number of clock counts since midnight since
  											the last mouse button have been pressed }

 { Check if a double-click occured on the mouse }
function IsDouble :Boolean; near;
	var ClockNow :LongInt;
begin
	asm
		MOV  AH, 00h              { Get number of clock tics since midnight }
		INT  IntClock
		MOV  ClockNow.Word, DX    { Save that number as ClockNow }
		MOV  ClockNow.Word+2, CX
	end;
	IsDouble := (ClockNow - LastClock) <= MouseDDelay;
		{ A double-click occured if the number of clock tics that occurred
			since the last button was down <= MouseDDelay }
	LastClock := ClockNow;
end; { IsDouble }

	{ The Input Manager's Mouse Interrupt Handler }
procedure IHMouseEvent; assembler;
asm
	PUSH  DS                                   { Save Registers         }
  PUSHF
	PUSH  AX

	MOV  AX, SEG @Data                         { Obtain Data Segment    }
	MOV  DS, AX

	POP   AX                                   { Restore AX }

	MOV  DS:MouseIntflag, True
	CMP  DS:MouseReverse, False                { Check if MouseReverse is set }
	JE   @2
	MOV  AL, BL                                { Switch bit 0 and bit 1 }
	AND  AL, 01                                {        if true         }
	AND  BL, 02
	SHL  AL, 1
	SHR  BL, 1
	OR   BL, AL
@2:

	MOV   DS:MouseButtons, BL                   { Set MouseButtons value }
	MOV   Word Ptr DS:[MouseWhere].TPoint.X, CX { Set Mouse Location     }
	MOV   Word Ptr DS:[MouseWhere].TPoint.Y, DX
	MOV   DS:MouseEvent, AX                     { Set up the Event flags }
	PUSH  AX
	PUSH  DX
	POP   DX
	POP   AX

	CMP   DS:MouseButtons, 0                   { Do not Check for Double-   }
	JE    @3                                   { click if no button is down }
	PUSH  AX
	PUSH  DX
	PUSH  CX
	CALL  IsDouble                             { Check for a double-click  }
	MOV   MouseDouble, AL                      { Save Value in MouseDouble }
	POP   AX
	POP   DX
	POP   CX
@3:
  POPF
	POP  DS                                    { Restore Data Segment (DS) }
end; { IHMouseEvent }

	{ Initializes the Mouse Manager and shows the mouse pointer in the
		upper left corner of the screen }
procedure InitMouse; assembler;
asm
	XOR   AX, AX                  { Function 00h - Reset Mouse & get Status }
	INT   IntMouse                { Execute Int 33h(51) - Mouse Interrupt   }
	CMP   AX, 0                   { AX = Mouse Available?                   }
	JE    @End                    { Do not Initialize Handler               }
																{   if no Mouse is available              }

	MOV   MouseAvail, True        { Set Variable MouseAvail to True         }
	MOV   MouseBCount, BL         { Set the number of buttons on the mouse  }

	MOV   AX, 000Ch               { Function 0Ch(12) - Set User defined     }
																{                    Mouse Event Handler  }
	MOV   CX, 007Fh               { Set EventMask of Mouse Interrupts       }
	MOV   DX, SEG IHMouseEvent    { Set Address of Mouse Interrupt Handler  }
	MOV   ES, DX
	MOV   DX, OFFSET IHMouseEvent
	INT   IntMouse                { Execute Interrupt 33h(51)               }

	MOV   AX, 01h                 { Function 01h(1) - Show Mouse Pointer    }
	INT   IntMouse                { Execute Interrupt 33h                   }

  MOV  AX, 0004h                { Move the mouse pointer to the upper    }
	MOV  CX, 0                    { Left corner using Int 33H function 04H }
	MOV  DX, 0
	INT  IntMouse

@End:
end; { InitMouse }

	{ Disables the Mouse Manager and hides the mouse pointer }
procedure DoneMouse; assembler;
asm
	MOV   MouseAvail, False   { Set variable - no mouse is available         }
	MOV   MouseBCount, 0      { Mouse has no buttons for no mouse is enabled }
	MOV   AX, 0021h           { Function 21h(33) - Reset Mouse Driver        }
	INT   IntMouse            { Execute Interrupt 33h(51)                    }
end; { DoneMouse }

	{ Hides the mouse pointer - The mouse device driver still
															tracks the pointer }
procedure HideMouse; assembler;
asm
	MOV   AX, 0002h
	INT   IntMouse
end; { HideMouse }

	{ Shows the Mouse Pointer on the screen }
procedure ShowMouse; assembler;
asm
	MOV   AX, 0001h           { function 01h(1) - Show mouse pointer }
	INT   IntMouse            { Execute Interrupt 33h(51)            }
end; { ShowMouse }


	{ Moves the mouse pointer to a certain location on the screen }
Procedure SetMousePos(X, Y :Integer); assembler;
asm
	MOV  AX, 0004h            { function 04h(4) - Move mouse pointer }
	MOV  CX, X                { Set Horizontal position              }
	MOV  DX, Y                { Set Vertical position                }
  INT  IntMouse             { Execute Interrupt 33h(51)            }
	MOV  AX, 0003
  INT  IntMouse
  MOV  Word Ptr MouseWhere, CX
	MOV  Word Ptr MouseWhere+2, DX
end; { SetMousePos }


{**þ INPUT MANAGER þ*********************************************************}
procedure GetKeyInput(var Input :TKeybordInput; Wait, Upcase :Boolean);
begin
	with Input do
	begin
		if Wait then
			if Upcase then KeyCode := Keybord.WaitUpcase
      else KeyCode := Keybord.WaitKey
    else
      if Upcase then KeyCode := Keybord.ReadUpcase
      else KeyCode := Keybord.ReadKey;
    if KeyCode <> kbNokey then What := inKeybord
    else What := inNothing;
    ShiftState := Keybord.GetState;
  end;
end; { GetKeyInput }

procedure GetLegalKeyInput
  (var Input :TKeybordInput; Wait, Upcase :Boolean; Legal :TCharSet);
begin
  GetKeyInput(Input, Wait, UpCase);
	With Input do
    if not (Charcode in Legal) then What := kbNoKey;
end; { GetLegalKeyIput }

procedure GetMouseInput(var Input :TMouseInput);
begin
  if MouseIntFlag then
  with input do
  begin
    What    := MouseEvent;
    Buttons := MouseButtons;
    Where   := MouseWhere;
    Double  := MouseDouble;
	end else
  with input do
  begin
    What    := inNothing;
    Double  := False;
	end;
  MouseIntFlag := False;
end; { GetMouseInput }

function MouseInputMatch(var Input :TMouseInput; Mask :Word) :Boolean;
begin
  GetMouseInput(Input);
	MouseInputMatch := Mask and Input.What <> 0;
end; { MouseInputMatch }

function MouseInputMatchIn
  (var Input :TMouseInput; Mask :Word; Bounds :TBounds) :Boolean;
begin
  MouseInputMatchIn := MouseInputMatch(Input, Mask) and
                       (Bounds.Within(Input.Where));
end; { MouseInputMatchIn }

procedure InitInput;
begin
  Keybord.Init;
  InitMouse;
end; { InitInput }

procedure DoneInput;
begin
  DoneMouse;
  Keybord.Done;
end; { DoneInput }

end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* Support for Interrupt Handlers                                           *}
{****************************************************************************}
Unit SInts;
  {$F-,O-,Q-,R-,S-}

Interface

{***þ Values of Interrupt Services þ***}
const
	intClock     = $1A;
	intKeybord   = $16;
	intMouse     = $33;
	intMSDos     = $21;
  intPrinter   = $17;
	intVideo     = $10;
  vecCtrlC     = $23;
  vecCritical  = $24;
  vecCtrlBreak = $1B;
  vecPrintScr  = $05;

{***þ Handler swap record  þ***}
type
	PIntHandler = ^TIntHandler;
	TIntHandler = record
		Vector    :Byte;
		Address   :Pointer;
	end;

{***þ Routines þ***}

 { Returns the address stored in a specified interrupt vector.}
	function  GetIntVector (IntNo :Byte) :Pointer;
 { Sets a specified interrupt vector to a specified address. }
	procedure SetIntVector (IntNo :Byte; Adress :Pointer);
 { Installs the Interrupt Handler Handler.Address at the Vector Handler.Vector}
	procedure InitHandler  (var Handler :TIntHandler);
 { Swaps the current handler at vector Handler.Vector with the givven one }
	procedure DoneHandler  (var Handler :TIntHandler);
 { Returns the current state of Break Flag in Dos }
	function  GetDosCBreak :Boolean;
 { Sets the state of the Break-Flag in Dos  }
	procedure SetDosCBreak (On :Boolean);


Implementation

{ Returns the address stored in a spesified software interrupt vector }
function GetIntVector(IntNo :Byte) :Pointer; assembler;
asm
	MOV  AH, 35H
	MOV  AL, IntNo
	Int  intMSDos
	MOV  DX, ES
	MOV  AX, BX
end;

{ Sets a spesified software interrupt vector to a spesified address }
procedure SetIntVector(IntNo :Byte; Adress :Pointer); assembler;
asm
	PUSH  DS
	LDS   DX, Adress
	MOV   AL, IntNo
	MOV   AH, 25H
	Int   intMSDos
	POP   DS
end;

	{ Installs an Interrupt Handler }
procedure InitHandler(var Handler :TIntHandler);
	var P :Pointer;
begin
	with Handler do
	begin
		if Address = nil then exit;
		{ Swap Handler.Adress with the vector address }
		P := GetIntVector(Vector);
		SetIntVector(Vector, Address);
		Address := P;
	end;
end;

	{ Removes an Interrupt Handler - Replacing the original }
Procedure DoneHandler(var Handler :TIntHandler);
begin
	InitHandler(Handler);
end;

	{ Returns the state of the DOS Break Flag }
function GetDosCBreak :Boolean; assembler;
asm
	MOV	   AX, 3300H
	INT	   intMsDos
	MOV    AL, DL
end;

	{ Sets the state of the DOS Break Flag }
procedure SetDosCBreak(On :Boolean); assembler;
asm
	MOV  DL, On
	MOV  AX, 3301H
	INT  intMsDos
end;


end.  { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* Routines for general use                                                 *}
{****************************************************************************}
Unit SProcs;
  {$F-,O-,Q-,R-,S-}

Interface
   Uses sTypes;

{***þ Error trapping routines þ***}
  procedure Abort(S :String);
  procedure Abstract(Method :String);

{ ***þ Bounding routines þ*** }
  function BoundByte (x, Lox, Hix :Byte) :Byte;
  function MaxByte   (x, y :Byte)        :Byte;
  function MaxInt    (x, y :Integer)     :Integer;
  function MinByte   (x, y :Byte)        :Byte;
  function MinInt    (x, y :Integer)     :Integer;
  function SubSmallW (x, y :Word)        :Word;

{ ***þ Bit & Memmory routines þ*** }
  procedure ClearMem  (var Rec; Size :Word);
  function  EnoughMem (Size :Word) :Boolean;
  function  CompMem   (var Source, Dest; Len :Word) :Boolean;
  procedure MoveMem   (var Source, Dest; Count :Word);

{***þ Disk & File relative routines þ***}
  function DirExists(Path :TExtrFile) :Boolean;
  function DriveValid(Drive: Char): Boolean;
  function FileExists(Name :TExtrFile) :Boolean;
  function GetCurPath :String;
  function GetCurrentDrive :Char;
  function GetExeDir  :String;
  function PhysDriveValid(Drive :Char) :Boolean;

{***þ Linking þ***}
  procedure FreeLPString(var Item :PLPString);
  function  NewLPString(Val :String; NextLink :PLPString) :PLPString;

{***þ Returns the Minimum value of the two in Word format þ***}
function MinWord(x, y :Word) :Word; inline(
  $58/     { POP AX }
  $5B/     { POP BX }
  $39/$D8/ { CMP AX, BX  - Compare AX to BX          }
  $76/$02/ { JBE 2 bytes - Jump two bytes if AX < BX }
  $89/$D8  { MOV AX, BX  - Put BX in AX              }
); { end MinWord }

  {***þ Returns the Maximum value of the two in Word format þ***}
function MaxWord(x, y :Word) :Word; inline(
  $58/     { POP AX }
  $5B/     { POP BX }
  $39/$D8/ { CMP AX, BX  - Compare AX to BX           }
  $73/$02/ { JBE 2 bytes - Jump two bytes if AX >= BX }
  $89/$D8  { MOV AX, BX  - Put BX in AX               }
); { end MaxWord }

{***þ Ensures x is within the bounds Lox..Hix else returning Lox or Hix þ***}
function BoundWord(x, Lox, Hix :Word) :Word; inline(
  $59/     { POP CX }
  $5B/     { POP BX }
  $58/     { POP AX }
  $39/$D8/ { CMP AX, BX  - Compare AX to BX           }
  $73/$02/ { JAE 2 bytes - Jump two bytes if AX >= BX }
  $89/$D8/ { MOV AX, BX  - Put BX in AX               }
  $39/$C8/ { CMP AX, CX  - Compare AX to CX           }
  $76/$02/ { JBE 2 bytes - Jump two bytes if AX <= CX }
  $89/$C8  { MOV AX, CX }
); { End BoundWord }

{***þ String handling routines þ***}
  function  SInt       (Num :LongInt; Width :Byte) :String;
  function  SUpper     (Str :String) :String;
  function  SFill      (Ch :Char; Len :Byte)   :String;
  function  SRemoveCh  (Str :String; ch :Char) :String;
  function  SPad       (Str :String; Ch :Char; Len :Byte) :String;
  function  SFScan     (Str :String; Ch :Char) :Byte;
  { Sets the length of a string }
  procedure SSetLen    (Str :String; Len :Byte);
    inline($58/  { POP AX }
           $5F/  { POP DI }
           $07/  { POP ES }
           $AA   { STOSB  }
    );{ Str[0] := Char(Len) }

{***þ PChar type routines þ***}
  procedure StrFreeMem(var P :PChar; StrLen :Word);
  procedure StrGetMem(var P :PChar; StrLen :Word);
  function  StrRemoveCh  (Str :PChar; Ch :Char) :PChar;
  procedure StrPCat(Dest :PChar; Source :String);

{***þ PString type routines þ***}
  function  NewStr     (Str: String): PString;
  function  GetStr     (Size :Byte) :PString;
  procedure DisposeStr (Str :PString);

{***þ Control Characters used by the TWrapper Object þ***}
const
  Wrapper_Left     = #2;
  Wrapper_Center   = #3;
  Wrapper_Right    = #4;
  Wrapper_Indent   = #5;
  Wrapper_CR       = #13;

{***þ TWrapper Object þ***
 This object is used to return wrapped text out of a continuous string. }
type
  TWrapper = Object
    Text       :PChar;
    Width      :Word;
    IndentSize :Byte;
    LineCount  :Byte;
    procedure AssignText(AText :PChar; AWidth, AIndent :Byte);
    procedure AssignStr(S :String; AWidth, AIndent :Byte);
    function  NextLine :String;
    function  IsDone :Boolean;
    private
      Dyanamic   :Boolean;
      Position   :PChar;
      Allignment :Char;
      Indent     :Boolean;
  end;



Implementation
  Uses Dos, Graph, Crt, strings;

{ Aborts the program displaying an error message. Used for program debugging }
procedure Abort(S :String);
begin
  RestoreCrtMode;
  TextAttr := $07;
  Writeln(' Program Aborted : '+S);
  Readln;
  Halt(1);
end; { Abort }

{ Called whenever a call was made to a abstract method }
procedure Abstract(Method :String);
begin
  Abort('Abstract Method Called --- '+Method);
end;


	{***þ Returns the Minimum value of the two in Byte format þ***}
function MinByte(x, y :Byte) :Byte; assembler;
asm
	MOV   AL, x  { Put x in the result register (AL for a Byte function) }
  CMP   AL, y  { Compare x and y                                       }
  JBE   @End   { if x <= y then goto end                               }
  MOV   AL, y  { Result register := y                                  }
@End:
end; { Minbyte }

  {***þ Returns the Maximum value of the two in Byte format þ***}
function MaxByte(x, y :Byte) :Byte; assembler;
asm
	MOV   AL, x    { Put x in the result register (AL for a Byte function) }
  CMP   AL, y    { Compare x and y                                       }
  JAE   @End     { if x >= y then goto end                               }
  MOV   AL, y    { else set y the result                                 }
@End:
end; { MaxByte }

  {***þ Ensures x is within the bounds Lox..Hix else returning Lox or Hix þ***}
function BoundByte(x, Lox, Hix :Byte) :Byte; assembler;
asm
	MOV   AL, x     { Saves x in Result Register      }
  CMP   AL, Lox   { Compare x to Lox                }
  JAE   @2        { if >= then do second validation }
  MOV   AL, Lox   { else bound x                    }
@2:
  CMP   AL, Hix   { Compare x to Hix                }
  JBE   @End      { if <= then allright - goto end  }
  MOV   AL, Hix   { else bound x                    }
@End:
end; { BoundByte }

  {***þ Subtracts the Smallest value from the Largest þ***}
function SubSmallW(x, y :Word) :Word; Assembler;
asm
	MOV   BX, x    { BX := x                     }
  MOV   AX, y    { AX := y                     }
  CMP   BX, AX   { Compare BX and AX (x and y) }
  JBE   @1       { if BX <= AX then Goto @1    }
  MOV   BX, y    { BX := y                     }
  MOV   AX, x    { AX := x                     }
@1:
  SUB   AX, BX   { AX := AX - BX  (AX = Result) }
end; { SubSmallW }

	{***þ Returns the Minimum value of the two in Integer format þ***}
function MinInt(x, y :Integer) :Integer;
begin
	If x < y then MinInt := x else MinInt := y;
end;

	{***þ Returns the Maximum value of the two in Integer format þ***}
function MaxInt(x, y :Integer) :Integer;
begin
	If x > y then MaxInt := x else MaxInt := y;
end;

{***þ Bit & Memmory routines þ***}
{ Clears an area of memmory by filling it with zeros }
procedure ClearMem(var Rec; Size :Word); assembler;
asm
  LES  DI, Rec    { Load Rec Pointer }
  MOV  CX, Size   { Store Size }
  XOR  AL, AL     { Clear AL   }
  REP  STOSB      { Move Bytes }
end; { ClearMem }

{***þ Moves Count bytes of memmory from Source to Dest þ***}
procedure MoveMem(var Source, Dest; Count :Word); assembler;
asm
  PUSH  DS          { Save Data Segment   }
  LDS   SI, Source  { Load Source Pointer }
  LES   DI, Dest    { Load Dest Pointer }
  MOV   CX, Count   { Set Count }
  CLD               { Set Direction to forward }
  REP   MOVSB       { Move Bytes }
  POP   DS          { Restore Data Segment }
end; { MoveMem }

{***þ Compares 2 areas of memmory up to Len Bytes - Does no error checking þ***}
function CompMem(var Source, Dest; Len : Word) :Boolean; assembler;
asm
  PUSH    DS              { Save Data segment }
  MOV     CX, Len         { Set Len }
  JCXZ    @@0             { Quit if Len = 0, returning True }
  LDS     SI, Source      { Load Source pointer }
  LES     DI, Dest        { Load Dest pointer }
  CLD                     { Set direction to forward }
  REPZ    CMPSB           { Compare the two areas }
  JZ      @@0             { Return True if the compare was completed }
  MOV     CL, True
@@0:
  MOV     AL, CL          { If CL = 0, return True, otherwise return False }
  XOR     AL, True
  POP     DS              { Restore Data segment }
end; { CompMem }

{ Returns true if a free memmory block of Size bytes is available }
function EnoughMem (Size :Word) :Boolean;
begin
  EnoughMem := MemAvail >= Size;
end; { EnoughMem }

{ Returns true if the file described in name exists }
function FileExists(Name :TExtrFile) :Boolean;
  var SR :SearchRec;
begin
  FindFirst(Name, ReadOnly+Hidden+SysFile+Archive, SR);
  FileExists := DosError = 0;
end;

{ Tells if a certain directory exists. }
function DirExists(Path :TExtrFile) :Boolean;
  var SR :SearchRec;
begin
  FindFirst(Path, directory, SR);
  DirExists := DosError = 0;
  if Path = '\' then DirExists := True;
  if (Path[2] = ':') and
     ((Length(Path) = 2) or ((Length(Path) = 3) and (Path[3] = '\')))
  then DirExists := DriveValid(Path[1]);
end; { Func DirExists }

{ Returns the current drive as reported by Dos }
function GetCurrentDrive :Char; Assembler;
asm
  MOV AH, 19H
  INT 21H
  ADD AL, 'A'
end;

{ Tells if a givven drive is valid }
function DriveValid(Drive: Char): Boolean; assembler;
asm
  MOV AH, 19H    { Save the current drive in BL }
  INT 21H
  MOV BL, AL
  MOV DL, Drive	{ Select the given drive }
  SUB DL, 'A'
  MOV AH, 0EH
  INT 21H
  MOV AH, 19H	{ Retrieve what DOS thinks is current }
  INT 21H
  MOV CX, False { Assume false }
  CMP AL, DL		{ Is the current drive the given drive? }
  JNE @@1
  MOV CX, True  { It is, so the drive is valid }
  MOV DL, BL	  { Restore the old drive }
  MOV AH, 0EH
  INT 21H
@@1:
  XCHG AX, CX { Put the return value into AX }
end; { func DriveValid }

{ Tells if a givven drive is valid. Also check that the logical name/letter
  corresponds to the physical name }
function PhysDriveValid(Drive :Char) :Boolean;
  { Gets the logical drive map for the physical one as reported by dos }
  function GetLogicalMap(Drv :Char) :Byte; assembler;
  asm
    MOV  AX, 440EH
    MOV  BL, Drv
    SUB  BL, 'A'-1
    INT  21H
  end; { GetLogicalMap }
  var Map :Byte;
begin
  Map := GetLogicalMap(Drive);
  PhysDriveValid := DriveValid(Drive) and
                    ((Map = 0) or (Map = ord(Drive)-64));
end; { func PhysDriveValid }

{***þ Returns the current directory on the active drive þ***}
function GetCurPath :String; assembler;
asm
  PUSH DS
  MOV  AH, 19H     { Get Current Drive }
  INT  21H
  ADD  AL, 'A'
  LES  DI, @Result { Load Result Pointer }
  PUSH DI
  INC  DI
  PUSH DI
  STOSB
  MOV  AL, ':'     { Add ':\' }
  STOSB
  MOV  AL, '\'
  STOSB
  MOV  AH, 47H     { Get Path }
  MOV  DL, 0
  PUSH ES
  POP  DS
  MOV  SI, DI
  INT  21H
  POP  DI          { Calculate Length }

	MOV	  CX, $FF
	XOR	  AL, AL
  REPNE SCASB
	MOV	 AX, $FE
	SUB	 AX, CX
  POP  DI
  STOSB
  POP  DS
end; { GetCurPath }

{ Returns the Path where the currently executing Exe file resides }
function GetExeDir  :String;
  var S :String;
begin
  S := ParamStr(0);
  Repeat
    Dec(S[0])
  Until S[Length(S)] = '\';
  GetExeDir := S;
end; { GetExeDir }

{ Sets up a new String Linking(PLPString) record for use with linkrd lists
  of Strings }
function NewLPString(Val :String; NextLink :PLPString) :PLPString;
  var P :PLPString;
begin
  New(P);
  with P^ do
  begin
    Value := NewStr(Val);
    Next := NextLink;
  end;
  NewLPString := P;
end; { NewLPString }

{***þ Disposes of a String Linking record þ***}
procedure FreeLPString(var Item :PLPString);
begin
  with Item^ do DisposeStr(Value);
  Dispose(Item);
  Item := nil;
end; { FreeLPString }

{***þ Converts a Integer to a string þ***}
function SInt (Num :LongInt; Width :Byte) :String;
  var S :String;
begin
  Str(Num:Width, S);
  SInt := S;
end; { SInt }

  {***þ Converts a string to Uppercase þ***}
function SUpper(Str :String) :String; Assembler;
asm
  PUSH   DS
  { Load pointers & set direction to forward }
  LDS    SI, Str
  LES    DI, @Result
  CLD
  { Load & store size }
  LODSB
  STOSB
  XOR    AH, AH
  XCHG   AX, CX
  JCXZ   @3

@1:
  { Load Character }
  LODSB
  { Convertion section }
  CMP    AL, 'a'
  JB     @2
  CMP    AL, 'z'
  JA     @2
  SUB    AL, 20H
@2:
  { Store character }
  STOSB
  LOOP   @1
@3:
  POP    DS
end; { SUpper }

  {***þ Fills a String up to Len with Character ch þ***}
function SFill(Ch :Char; Len :Byte) :String; assembler;
asm
  {Load Pointer & set direction to forward }
  LES    DI, @Result
  CLD
  {Store Size}
  MOV    AL, Len
  XOR    AH, AH
  MOV    CX, AX
  STOSB
  {Store Characters}
  MOV    AL, &Ch
  REP    STOSB
end; { SFill }

  {***þ Removes all occurances of Ch in Str þ***}
function SRemoveCh(Str :String; Ch :Char) :String; Assembler;
asm
  {Save Data Segment}
  PUSH    DS
  {Load Pointers & set direction to forward }
  CLD
  LDS    SI, Str      {Source}
  LES    DI, @Result  {Destination}
  {Load Source Size}
  LODSB
  MOV    BX, 01H
  Xor    AH, AH
  XCHG   AX, CX
  JCXZ   @3
@1:
  LODSB
  CMP    AL, &Ch
  JE     @2
  MOV    ES:[DI+BX], AL
  INC    BX
@2:
  LOOP   @1

@3:
  DEC    BX
  MOV    ES:[DI], BL
  POP    DS
end; { SRemoveCh }

function SPad(Str :String; Ch :Char; Len :Byte) :String;
  var CurrLen : Byte;
begin
  CurrLen := MinWord(Length(Str), Len);
  SSetLen(Str, Len);
  FillChar(Str[Succ(CurrLen)], Len - CurrLen, Ch);
  SPad := Str;
end; { SPad }

{***þ Returns an Index to the First occurance of Ch in Str þ***}
function SFScan(Str: String; Ch: Char): Byte; assembler;
asm
	CLD
	LES	   DI, Str
  MOV    CL, ES:[DI]
  XOR    CH, CH
  MOV    BX, CX
  INC    DI
	MOV	   AL, &Ch
	REPNE	 SCASB
	MOV    AX, 0
	CWD
  JNE	   @End
  MOV    AX, BX
  SUB    AX, CX
@End:
end; { SFScan }

{ÄÄ PChar type routines ÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄ-}
{ Deallocates memmory of a PChar string with a spesific size on the heap. }
procedure StrFreeMem(var P :PChar; StrLen :Word);
begin
  if P <> nil then
  begin
    P^ := #0;
    FreeMem(P, StrLen+1);
  end;
end; { StrFreemem }

{ Allocates memmory for a PChar string on the heap }
procedure StrGetMem(var P :PChar; StrLen :Word);
begin
  GetMem(P, StrLen+1);
  P^ := #0;
end;

{***þ Removes all occurances of Ch in Str þ***}
function StrRemoveCh(Str :PChar; Ch :Char) :PChar; assembler;
asm
  { Set Up Registers }
  CLD
	LES	  DI, Str
  MOV   AX, DI
  MOV   DX, ES
  PUSH  AX
  PUSH  DX
  { Check for nil pointer }
  CMP   DI, 0
  JNE   @CheckEnd
  MOV   CX, ES
  JCXZ  @End
@CheckEnd:
  { Calculate Length - Save In CX }
	MOV	  CX, 0FFFFH
	XOR	  AL, AL
	REPNE	SCASB
	MOV	  DX, 0FFFEH
	SUB	  DX, CX
  MOV   CX, DX
  { Set Up Registers }
  PUSH  DS
  LDS   SI, Str  { Source }
  LES   DI, Str  { Destination }
  MOV   AH, &Ch
  { Check for Empty String }
  JCXZ   @3
  { Copy the relevant characters }
@1:
  LODSB
  CMP    AL, AH
  JE     @2
  STOSB
@2:
  LOOP   @1

@3:
  { Save null terminator }
  XOR    AL, AL
  STOSB

  POP    DS

@End:
  { Load Result Pointer }
  POP    DX
  POP    AX
end; { StrRemoveChar }

{ Adds the Pascal string Source to the end of Dest.
  No length Checking is performed. The destination buffer must have
  room for at least Length(Source)+1 characters.}
procedure StrPCat(Dest :PChar; Source :String);
  var P :PChar;
begin
  { Set P to point to where the null terminator should be placed }
  P := StrEnd(Dest)+length(Source);
  { copy the characters }
  Move(Source[1], StrEnd(Dest)^, Length(Source));
  { Set null terminator }
  P^ := #0;
end; { StrPCat }


{ÄÄ PString type routines ÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄÄÄÄÄ-ÄÄ-}
function NewStr(Str: String): PString;
  var P :PString;
begin
  if Length(Str) > 0 then GetMem(P, Length(Str)+1) else P := nil;
  MoveMem(Str[0], P^[0], Length(Str)+1);
  NewStr := P;
end;

{***þ Allocates Size Space for a String on the Heap þ***}
function GetStr(Size :Byte) :PString;
  var P :PString;
begin
  if Size > 255 then Size := 255;
  if Size > 0 then
  begin
    GetMem(P, Size+1);
    SSetLen(P^, 0);
  end {if}
  else P := nil;
  GetStr := P;
end; { func GetStr }

{ Disposes of a dyanamic string allocated by NewStr or GetStr }
procedure DisposeStr(Str :PString);
begin
  if Str <> nil then FreeMem(Str, Length(Str^)+1);
end;

{****************************************************************************}
{*  TWrapper object tool                                                          *}
{****************************************************************************}
{ Assigns Text to the Text Field of the wrapper and initializes it }
procedure TWrapper.AssignText(AText :PChar; AWidth, AIndent :Byte);
begin
  Text := AText;
  Width := AWidth;
  Position := Text;
  Allignment := Wrapper_Left;
  IndentSize := AIndent;
  Indent := False;
  Dyanamic := False;
  LineCount := 0;
end; { TWrapper.AssignText }

{ Assigns a String to the Text Field of the wrapper and initializes it }
procedure TWrapper.AssignStr(S :String; AWidth, AIndent :Byte);
begin
  StrGetMem(Text, Length(S));
  AssignText(StrPCopy(Text, S), AWidth, AIndent);
  Dyanamic := True;
end; { TWrapper.AssignStr }

{ This function is used to return the wrapped text line by line
  If the end of the text is reached it returns an empty string }
function TWrapper.NextLine :String;

  var S :String;
      Line :String;
      WordCount :Byte;

   { Returns the next available continious word }
   function ScanNext :String;
     const Deviders :TCharSet = [Wrapper_Left, Wrapper_Center,
                                 Wrapper_Right, Wrapper_Indent,
                                 Wrapper_Cr, ' ', ',','-', '(',')'];
       var S :String;
   begin
     { If End of String is reached }
     if Position = StrEnd(Text) then ScanNext := ''
     else
     { if a devider was found at current position }
     if Position^ in Deviders then
     begin
       ScanNext := Position^;
       Inc(Position);
     end
     else
     { regular character was found at current position }
     begin
       S := '';
       while not (Position^ in Deviders) and
                 (Position < StrEnd(Text)) do
       begin
         S := S+Position^;
         Inc(Position);
       end;
       ScanNext := S;
     end; { else }
   end; { sub func ScanNext }

   { Alligns the text by adding the relevant amount of Spaces at the front
     of the current output Line. Then sets the allignment to left. }
   procedure Allign;
   begin
     case Allignment of
       Wrapper_Left   :;
       Wrapper_Center :Line := SFill(' ', (Width - Length(Line)) shr 1) +Line;
       Wrapper_Right  :Line := SFill(' ', Width - Length(Line)) +Line;
     end; {case}
     Allignment := Wrapper_Left;
   end; { sub proc Allign }

begin { TWrapper.NextLine }
  NextLine := '';
  WordCount := 0;
  if Text = nil then Exit;
  S := ScanNext;
  if Indent and (LineCount > 0) and (S <> '') then
    Line := SFill(' ', IndentSize)
  else Line := '';
  while S <> '' do
  begin
    { A Cr is detected }
    if S = Wrapper_Cr then begin Indent := False; Allign; Break; end
    else
    { Left allignment control character is detected }
    if S = Wrapper_Center then Allignment := Wrapper_Center
    else
    { Center allignment control character is detected }
    if S = Wrapper_Center then Allignment := Wrapper_Center
    else
    { Right allignment control character is detected }
    if S = Wrapper_Right then Allignment := Wrapper_Right
    else
    { Indent control character was detected }
    if S = Wrapper_Indent then Indent := True
    else
    { Space is detected }
    if S = ' ' then begin if Line <> '' then Line := Line+' '; end
    { Word Is Detected }
    else
    if Length(Line+S) <= Width then begin Line := Line+S; Inc(WordCount); end
    else
      begin
        if WordCount > 0 then begin Dec(Position, Length(S)); Break; end
        else
        begin
          Dec(Position, Length(Line+S)-Width+1);
          S[0] := Char(Width-Length(Line)-1);
          Line := Line+S+'-';
          Break;
        end; {else}
      end; {else}
    S := ScanNext;
  end; {while}
  if Line <> '' then
  begin
    { Truncate spaces }
    if Line[Length(Line)] = ' ' then Dec(Line[0]);
    Allign;
  end;
  if Position^ = #0 then
    if Dyanamic then begin StrDispose(Text); Text := nil; end
    else Text := nil;
  NextLine := Line;
  Inc(LineCount);
end; { TWrapper.NextLine }

{ Called to check if any more text is left in the wrapper buffer }
function TWrapper.IsDone :Boolean;
begin
  IsDone := Text = nil;
end;

end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* Basic view object deratives                                              *}
{****************************************************************************}
Unit STDViews;
  {$F-,O-,Q-,R-,S-}

Interface
  uses Objects, sBasic, sView, sInput, sTypes;


{***þ Button View þ***}
type
  PButton = ^TButton;
  TButton = Object(TView)
    Caption :PString;
    Command :Word;
    constructor Init(B :TBounds; Cap :String; Cm, Hc :Word);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   MouseInput(var Input :TMouseInput); virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    procedure   SetState(StateFlag :Word; Enable :Boolean); virtual;
    procedure   Pressed;
  end;

{***þ InputLine þ***}
  PInputLine = ^TInputLine;
  TInputLine = Object(TView)
    DataStr    :PString;
    Max        :Word;
    Cursor     :Byte;
    FirstChar  :Word;
    ValidSet   :TCharSet;
    constructor Init(Bounds :TBounds; MaxLen :Byte; InitStr :String; CharSet :TCharset);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   MouseInput(var Input :TMouseInput); virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    function    LastChar :Word;
    function    InsPos :Word;
    procedure   GetData(var Rec); virtual;
    procedure   SetData(var Rec); virtual;
    function    DataSize :Word; virtual;
    procedure   Changed; virtual;
    function    DispCount :Integer;
    private
      function   ValidOpr(Opr :Word) :Word;
      procedure  ControlOpr(Opr :Word; Key :Word);
  end;

{***þ List Scroller þ***}
type
  PListScroller = ^TListScroller;
  TListScroller = Object(TView)
    Items     :PCollection;
    FirstStr  :Word;
    FirstCol  :Byte;
    BarPos    :Byte;
    MaxStrLen :Byte;
    constructor Init(Bounds :TBounds; List :PCollection);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   MouseInput(var Input :TMouseInput); virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    procedure   Reset; virtual;
    function    CurStr  :Word;
    function    Count :Word; virtual;
    function    ItemPtr(Index :Word) :Pointer; virtual;
    procedure   NewItems(List :PCollection);
    function    GetString(Index :Word) :String; virtual;
    procedure   Selected(Index :Word); virtual;
    procedure   BarChanged; virtual;
    procedure   ItemsChanged; virtual;
    procedure   ScrollTo(Pos :Word);
    private
      function    ValidOpr(Opr :Byte; Key :Word) :Byte;
      procedure   ControlOpr(Opr :Byte; Key :Word);
      function    LastPos :Word;
      function    LastStr :Word;
      function    DispWidth :Word;
      function    DispHeight :Word;
  end;

{***þ Cluster Object þ***}
type
  PCluster = ^TCluster;
  TCluster = Object(TView)
    Value      :LongInt;
    EnableMask :LongInt;
    Selected   :Byte;
    Text       :PLPString;
    constructor Init(B :TBounds; Strings :PLPString; Hc :Word);
    destructor  Done; virtual;
    procedure   Art; virtual;
    function    ValidAmount :Byte;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    procedure   MouseInput(var Input :TMouseInput); virtual;
    function    On(Which :LongInt) :Boolean;
    procedure   GetData(var Rec); virtual;
    procedure   SetData(var Rec); virtual;
    function    DataSize :Word; virtual;
  end;

{***þ Static Text þ***}
type
  PStaticText = ^TStaticText;
  TStaticText = Object(TView)
    Text :PString;
    Font, CharSize, Colors :Byte;
    constructor Init(B :TBounds; AFont, ASize, AColor :Byte; AText :String);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   SetData(var Data); virtual;
    procedure   GetData(var Data); virtual;
    function    DataSize :Word; virtual;
  end;

{***þ Message Window appearance States þ***}
const
  mwfWarning      = $01;
  mwfError        = $02;
  mwfConfirmation = $03;
  mwfInformation  = $04;
  mwfOk           = $10;
  mwfYes          = $20;
  mwfNo           = $40;
  mwfCancel       = $80;

{***þ Message Window View Object þ***}
  { Created for the  MessageWindow function }
type
  PMessageWindow = ^TMessageWindow;
  TMessageWindow = Object(TViewGroup)
    Caption :PString;
    Colors  :LongInt;
    constructor Init(B :TBounds; ACaption, AText :String; AColors :LongInt);
    destructor  Done; virtual;
    procedure   Art; virtual;
    procedure   Listen(var Speech :TSpeech); virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
  end;


{ MessageWindow function
  -----------------------
  Displays dialog box on the screen, using the bounds passed in parameter B,
  containing the formatted message passed in Text, and having an appearance
  described by the flags passed in Options.

  Options contains some combination of the mwfXXXX flag constants,
  determining which buttons appear in the message box and how then title looks
  like.

  MessageBox uses the TMessagewindow object to insert a modal view into the
  application object and then executes the newly inserted object.
  It also uses a TStatictext Object to display the given text centered and
  word-wrapped within the dialog box.

  When the message box finishes by means of a button press the application
  is redrawn by calling application^.redraw.
  }

  function MessageWindow(B :TBounds; Text :String; Options :Byte) :Word;




Implementation
  uses sGraph, graph, sProcs, consts, Main;

{****************************************************************************}
{*   TButton                                                                *}
{****************************************************************************}
constructor TButton.Init(B :TBounds; Cap :String; Cm, Hc :Word);
begin
  Inherited Init(B);
  Caption := NewStr(Cap);
  Command := cm;
  ViewOptions := ViewOptions or voSelectable or voFirstClick;
  HelpCtx := Hc;
end;

destructor TButton.Done;
begin
  DisposeStr(Caption);
  Inherited Done;
end;


procedure TButton.Art;
  var C, TC :Word;
begin
  if StateOn(vsPressed) then C := LowerGrey else C := RaiseGrey;
  if StateOn(vsDisabled) then TC := 8 else
  begin
    if StateOn(vsSelected) then TC := ShadowGreen else TC := $C;
  end;
  Platform(0, 0, Size.X, Size.Y, C);
  Platform(1, 1, Size.X-1, Size.Y-1, C);
  if StateOn(vsPressed) then
    WriteStrXY(Size.X shr 1+2, size.Y shr 1+3,
      8, 0, 1, JustCenter, False, Caption^);
  WriteStrXY(Size.X shr 1, size.Y shr 1+1,
             TC, 0, 1, JustCenter, False, Caption^);
end;

procedure TButton.MouseInput(var Input :TMouseInput);
  var P :TPoint;
begin
  inherited MouseInput(Input);
  if not (Input.What = inMouseLD) then exit;
  SetState(vsPressed, True);
  while not MouseInputMatch(Input, inMouseUp) do
  begin
    if Input.What and inMouseMove <> 0 then { Mouse Movement }
		begin                                   { while pressed  }
      if PointIn(MouseWhere) then
      begin
        if not StateOn(vsPressed) then SetState(vsPressed, True)
      end
      else if StateOn(vsPressed) then SetState(vsPressed, False);
    end;
  end;
  if PointIn(MouseWhere) then Pressed;
end;

procedure TButton.KeybordInput(var Input :TKeybordInput);
begin
  inherited KeybordInput(Input);
  if Input.What and inKeybord <> 0 then
  case Input.Keycode of
    kbEnter :
      begin
        Pressed;
        InputHandled(Input);
      end;
  end;
end;

procedure TButton.SetState(StateFlag :Word; Enable :Boolean);
begin
  inherited SetState(StateFlag, Enable);
  if StateFlag and vsPressed <> 0 then Draw;
end;

procedure TButton.Pressed;
  var S :TSpeech;
begin
  SetState(vsPressed, True);
  PutMessage(spCommand, Command, nil);
  SetState(vsPressed, False);
end;

{****************************************************************************}
{*   TInputLine                                                             *}
{****************************************************************************}
constructor TInputLine.Init
  (Bounds :TBounds; MaxLen :Byte; InitStr :String; Charset :TCharSet);
begin
  Inherited Init(Bounds);
  ViewOptions := ViewOptions or voSelectAble or voFirstClick;
  GetMem(DataStr, MaxLen+1);
  DataStr^  := InitStr;
  Cursor    := 1;
  FirstChar := 1;
  Max := MaxLen;
  SetState(vsInsert, True);
  ValidSet := CharSet;
end;

destructor TInputLine.Done;
begin
  FreeMem(DataStr, Max+1);
  Inherited Done;
end;

procedure TInputLine.Art;
  var C :Word;
      S :String;
      X :Integer;
  var MarkBegin, MarkEnd :Byte;
begin
  Level(0, 0, Size.X, Size.Y, Raisegrey);
  Level(1, 1, Size.X-1, Size.Y-1, Raisegrey);
  Level(2, 2, Size.X-2, Size.Y-2, Lowergrey);
  Level(3, 3, Size.X-3, Size.Y-3, Lowergrey);
  if StateOn(vsSelected) then C := $8F01 else C := $8F07;
  Platform(4, 4, Size.X-4, Size.Y-4, C);
  S := Copy(DataStr^, FirstChar, DispCount);
  WriteStrXY(15, Size.Y shr 1-3, ShadowWhite,
             DefaultFont, 1, JustLeft+JustTop, False, S);
  SettextStyle(DefaultFont, HorizDir, 1);
  if Cursor <> 0 then X := 15+(Cursor-1)*TextWidth('X')
  else X := 15;
  if StateOn(vsSelected) then
  begin
    if StateOn(vsInsert) then Setcolor($A) else Setcolor($C);
    Line(X, 6, X, Size.Y-6);
  end;
end;

function TInputLine.LastChar :Word;
begin
  SettextStyle(DefaultFont, HorizDir, 1);
  LastChar :=
    MinWord(FirstChar + DispCount,Length(DataStr^));
end;

function TInputLine.InsPos :Word;
begin
  InsPos := FirstChar + Cursor-1;
end;

function TInputLine.ValidOpr(Opr :Word) :Word;
  var ValidOp:Boolean;
begin
  ValidOp:= True;
  Case Opr of
    qAppend,
    qInsert       :ValidOp := Length(DataStr^) < Max;
    qOverwrite    :ValidOp := InsPos <= Max;
    qDelete       :ValidOp := (Length(DataStr^) > 0) and
                              (InsPos <= Length(DataStr^));
    qBack         :ValidOp := InsPos > 1;
    qClear        :ValidOp := Length(DataStr^) > 0;
    qToggleIns    :ValidOp := True;
    qLeft         :ValidOp := InsPos > 1;
    qRight        :ValidOp := (InsPos <= Length(DataStr^)) and (InsPos < Max);
    qHome         :ValidOp := (InsPos > 1);
    qEnd          :ValidOp := (InsPos <= Length(DataStr^)) and (InsPos < Max);
  end;
  if ValidOp then ValidOpr := Opr else ValidOpr := qNone;
end;

procedure TInputLine.ControlOpr(Opr :Word; Key :Word);
  var I :Word;

{ Shifts each character, from position Index to position Lastshift in
	  Buffer, one position to the right. }
  procedure ShiftRight(Index, LastShift :Word);
  var I, J :Word;
      Size :Word;
  begin
    SettextStyle(DefaultFont, HorizDir, 1);
    J := DispCount;
    Size := Max;
    if LastShift = 0 then LastShift := J else
  	  LastShift := MinWord(J, LastShift);
    Index := MaxWord(MinWord(Index, J), 1);
    For I := LastShift downto Index do DataStr^[I+1] := DataStr^[I];
    DataStr^[Index] := #0;
  end;

  { Shifts each character, from position Index to position LastShift in
	  the buffer, one position to the left. }
  procedure ShiftLeft(Index, LastShift :Word);
    var I :Word;
        Size :Word;
  begin
    Size := Max;
    if LastShift = 0 then LastShift := Size else
  	  LastShift := MinWord(Size, LastShift);
    Index := MaxWord(MinWord(Index, Size), 2);
    For I := Index to LastShift do DataStr^[I-1] := DataStr^[I];
    DataStr^[LastShift] := #0;
  end;

begin
  { Check if the operation is valid }
  Opr := ValidOpr(Opr);
  { Do Operation }
  Case Opr of
    qAppend    :
      begin
        DataStr^ := DataStr^+ TKbKey(Key).CharCode;
        If Cursor = DispCount then Inc(FirstChar)
        else if Length(DataStr^) < Max then Inc(Cursor);
      end;
    qInsert    :
      begin
        ShiftRight(InsPos, Length(DataStr^));
        DataStr^[InsPos] := TKbKey(Key).CharCode;
        Inc(DataStr^[0]);
        If Cursor = DispCount then Inc(FirstChar)
        else if Length(DataStr^) < Max then Inc(Cursor);
      end;
    qOverwrite :
      begin
        DataStr^[InsPos] := TKbKey(Key).CharCode;
        If Cursor = DispCount then Inc(FirstChar)
        else Inc(Cursor);
      end;
    qDelete    :
      Begin
        ShiftLeft(InsPos+1, Length(DataStr^));
        Dec(DataStr^[0]);
      end;
    qBack      :
      Begin
        ShiftLeft(InsPos, Length(DataStr^));
        Dec(DataStr^[0]);
        if (Cursor > 1) and (FirstChar > 1) then Dec(FirstChar)
        else Dec(Cursor);
      end;
    qToggleIns :ToggleState(vsInsert);
    qClear :
      Begin
        DataStr^[0] := #0;
        Cursor    := 1;
        FirstChar := 1;
      end;
    qLeft         :if Cursor > 1 then Dec(Cursor) else Dec(FirstChar);
    qRight        :if Cursor < DispCount then Inc(Cursor) else Inc(FirstChar);
    qHome      :
      Begin
        FirstChar := 1;
        Cursor    := 1;
      end;
    qEnd    :
      begin
      end;
  end;
  { Input of the view has changed }
  if Opr <> qNone then Changed;
  if Opr in
    [qAppend, qInsert, qOverwrite, qDelete, qBack, qClear] then Changed;
  if Opr <> qNone then Draw
end;

procedure TInputLine.KeybordInput(var Input :TKeybordInput);
  var Operation :Word;
begin
  Inherited KeybordInput(Input);
  Operation := qNone;
  With Input do
  begin
    Case KeyCode of
      kbEsc      :Operation := qDelete;
      kbBack     :Operation := qBack;
      kbIns      :Operation := qToggleIns;
      kbDel      :if Keybord.StateOn(ksShift) then Operation := qClear
  	              else Operation := qDelete;
      kbLeft     :if ShiftState and ksShift <> 0 then
                  Operation := qMarkLeft
			            else Operation := qLeft;
      kbRight    :if ShiftState and ksShift <> 0 then
		              Operation := qMarkRight
		             else Operation := qRight;
      kbHome     :Operation := qHome;
      kbEnd      :Operation := qEnd;
      else { character key was typed }
        if CharCode in ValidSet then
        begin
          if InsPos > Length(DataStr^) then Operation := qAppend
          else if StateOn(vsInsert) then Operation := qInsert
		           else Operation := qOverwrite;
        end
        else Exit;
     end;
    ControlOpr(Operation, KeyCode);          { Do Operation }
  end;
  InputHandled(Input);
end;

procedure TInputLine.MouseInput(var Input :TMouseInput);
  var Operation :Word;
      P :TPoint;
begin
  Operation := qNone;
  with Input do
  begin
    if what and inMouseLD <> 0 then
    begin
      MakeLocal(Where, P);
      SettextStyle(DefaultFont, HorizDir, 1);
      P.X := P.X div TextWidth('X') + 1;
      if P.X > 2 then Dec(P.X, 2)
      else P.X := MinByte(DispCount, P.X);
      if Length(DataStr^) > 0 then
        if (P.X >= 1) and (P.X <= MinWord(LastChar-FirstChar+1, DispCount)) then
        begin
	   		  Cursor := P.X;
          Draw;
          Exit;
        end
        else if P.X  <= 0 then
        begin
			    Operation := qLeft;
        end
        else if P.X >= MinWord(LastChar-FirstChar+2, DispCount) then
        begin
			    Operation := qRight;
        end;
		end
    else Exit;
    ControlOpr(Operation, kbNoKey);          { Do Operation }
  end;
end;

procedure TInputLine.GetData(var Rec);
begin
  Move(DataStr^, Rec, Datasize);
end;

procedure TInputLine.SetData(var Rec);
begin    { Assume Rec is of type string }
  Move(Rec, DataStr^, Datasize);
  FirstChar := 1;
  Cursor := 1;
  Draw;
end;

function TInputLine.DataSize :Word;
begin
  DataSize := Max+1;
end;

procedure TInputLine.Changed;
begin
  Message(Owner, spNotify, msgChanged, DataStr);
end;

function TInputLine.DispCount :Integer;
begin
  SettextStyle(DefaultFont, HorizDir, 1);
  DispCount := (Size.X-25) div TextWidth('X');
end;

{****************************************************************************}
{*   TListScroller                                                          *}
{****************************************************************************}
constructor TListScroller.Init(Bounds :TBounds; List :PCollection);
  var I :Word;
begin
  Inherited Init(Bounds);
  ViewOptions := ViewOptions or voSelectable or voFirstClick;
  Items := List;
  FirstCol := 1;
  if Count > 0 then
    for I := 0 to Count-1 do
      MaxStrLen := MaxInt(MaxStrLen, Length(GetString(I)));
end;

destructor TListScroller.Done;
begin
  if Items <> nil then Dispose(Items, Done);
  Inherited Done;
end;

procedure TListScroller.Art;
  var C :Word;
      I, J :Word;
      S, S2 :String;
      TxtHeight :Word;
begin
  Platform(0, 0, Size.X, Size.Y, $870F);
  if StateOn(vsSelected) then C := $0A else C := $08;
  SetColor(C);
  SetTextStyle(defaultfont, Horizdir, 1);
  SetTextJustify(LeftText, CenterText);
  TxtHeight := TextHeight('X')+3;
  SetColor(C);
  Platform(0, TxtHeight*(BarPos+1)-2, Size.X, TxtHeight*(BarPos+1)+10 , 9);
  J := 0;
  if Count > 0 then
    For I := FirstStr to LastStr do        { Each String  }
    begin
      Inc(J);
      S := GetString(I);            { Fetch String }
      S2 := Copy(S, FirstCol, MinInt(LastPos, Length(S))+1);
      OutTextXY(10, J*TxtHeight+TxtHeight shr 1, S2);
    end;
end;

procedure TListScroller.MouseInput(var Input :TMouseInput);
  var P :TPoint;
      Item :Integer;
begin
  inherited MouseInput(Input);
  if Input.What and inMouseLU <> 0 then
  begin
    MakeLocal(Input.Where, P);
    Item := (P.Y-16) div (TextHeight('X')+3);
    if (Item >= 0) and (Item < Count) then Selected(Item);
    InputHandled(Input);
  end;
end;

procedure TListScroller.KeybordInput(var Input :TKeybordInput);
begin
  if Input.What and inKeybord <> 0 then
  case Input.KeyCode of
    kbLeft   :ControlOpr(qLeft, kbLeft);
    kbRight  :ControlOpr(qRight, kbRight);
    kbUp     :ControlOpr(qUp, kbUp);
    kbDown   :ControlOpr(qDown, kbDown);
    kbPgDn   :ControlOpr(qEndX, kbPgDn);
    kbPgUp   :ControlOpr(qHomeX, kbPgUp);
		kbHome   :if Input.ShiftState and ksShift <> 0 then
              ControlOpr(qHomeX, kbHome) else ControlOpr(qHome, kbHome);
    kbEnd    :if Input.ShiftState and ksShift <> 0 then
              ControlOpr(qEndX, kbEnd) else ControlOpr(qEnd, kbEnd);
    kbEnter  :ControlOpr(qSelect, kbEnter);
    else begin inherited KeybordInput(Input); exit; end;
  end;
  InputHandled(Input);
end;

function TListScroller.ItemPtr(Index :Word) :Pointer;
begin
  if Count > 0 then ItemPtr := Items^.At(Index)
  else ItemPtr := nil;
end;

procedure TListScroller.NewItems(List :PCollection);
begin
  if Items <> nil then Dispose(Items, Done);
  Items := List;
  Reset;
  ItemsChanged;
end;

function TListScroller.GetString(Index :Word) :String;
begin
  Abstract('TListScroller.GetString');
end;

procedure TListScroller.BarChanged;
begin
end;

procedure TListScroller.ItemsChanged;
begin
end;

procedure TListScroller.Reset;
  var I :Word;
begin
  FirstStr := 0;
  Barpos   := 0;
  FirstCol := 1;
  MaxStrLen := 0;
  if Count > 0 then
    for I := 0 to Count-1 do
      MaxStrLen := MaxInt(MaxStrLen, Length(GetString(I)));
  Draw;
  BarChanged;
end;

function TListScroller.ValidOpr(Opr :Byte; Key :Word) :Byte;
  var OpValid :Boolean;
begin
  OpValid := False;
  if Count < 1 then exit;
  case opr of
    qUp    :OpValid := CurStr > 0;
    qDown  :OpValid := CurStr < Count-1;
    qEnd   :OpValid := CurStr < Count-1;
    qHome  :OpValid := CurStr > 0;
    qLeft,
    qHomeX  :OpValid := FirstCol > 1;
    qRight,
    qEndX   :OpValid :=
		    LastPos < MaxByte(Length(GetString(CurStr)), MaxStrLen);
    qSelect :OpValid := True;
  end;
  if OpValid then ValidOpr := opr else ValidOpr := qNone;
end;

procedure TListScroller.ControlOpr(opr :Byte; Key :Word);
  var OldCurr :Word;
begin
  OldCurr := CurStr;
  Opr := ValidOpr(Opr, Key);
  case Opr of
    qUp     :if Barpos > 0 then Dec(Barpos) else Dec(FirstStr);
    qDown   :if Barpos < DispHeight-1 then Inc(Barpos) else Inc(FirstStr);
    qHome   :begin FirstStr := 0; BarPos := 0; end;
    qEnd    :
		  begin
			  FirstStr := Count - MinInt(DispHeight, Count);
				BarPos   := MinInt(Count, DispHeight)-1;
			end;
    qLeft   :Dec(FirstCol);
    qRight  :Inc(FirstCol);
    qHomeX  :FirstCol := 1;
    qEndX   :FirstCol := MaxStrLen - DispWidth + 3;
    qSelect :Selected(CurStr);
  end;
  if Opr <> qNone then Draw;
  if OldCurr <> CurStr then BarChanged;
end;

procedure TListScroller.Selected(Index :Word);
begin
end;

function TListScroller.LastPos :Word;
begin
  LastPos := DispWidth + FirstCol-1;
end;

function TListScroller.CurStr :Word;
begin
  CurStr :=  FirstStr + BarPos;
end;

function TListScroller.Count :Word;
begin
  if Items <> nil then Count := Items^.Count else Count := 0;
end;

function TListScroller.LastStr :Word;
begin
  LastStr := MinWord(DispHeight + FirstStr-1, Count-1);
end;

function TListScroller.DispWidth :Word;
begin
  SettextStyle(DefaultFont, HorizDir, 1);
  DispWidth := (Size.X-16) div (TextWidth('X')+1);
end;

function TListscroller.DispHeight :Word;
begin
  SettextStyle(DefaultFont, HorizDir, 1);
  DispHeight := (Size.Y-16) div (TextHeight('X')+3);
end;

procedure TListScroller.ScrollTo(Pos :Word);
begin
  if Pos in [0..Count-1] then
  begin
    FirstStr := MinWord(Pos, Count-Dispheight);
    BarPos := Pos - Firststr;
    Draw;
  end;
end; { TListScroller.Scrollto }

{****************************************************************************}
{*   TCluster                                                               *}
{****************************************************************************}
constructor TCluster.Init(B :TBounds; Strings :PLPString; Hc :Word);
begin
  Inherited Init(B);
  Text := Strings;
  ViewOptions := Viewoptions or voSelectable or voFirstClick;
  Value := 0;
  HelpCtx := Hc;
end;

destructor TCluster.Done;
  var P, D :PLPString;
begin
  P := Text;
  while P <> nil do
  begin
    D := P;
    P := P^.Next;
    FreeLPString(D);
  end;
  inherited Done;
end;

procedure TCluster.Art;
  var I:Byte; P :PLPString; Sel :Boolean;
      Y :Integer; C :Word;
begin
  P := Text;
  SetTextStyle(2, HorizDir, 4);
  SetTextJustify(LeftText, TopText);
  Sel := StateOn(vsSelected);
  for I := 0 to ValidAmount-1 do
  begin
    Y := I*(TextHeight('X')+3);
    if StateOn(vsDisabled) then SetColor($08)
    else if sel then SetColor($A) else SetColor($C);
    OutTextXY(25, Y, P^.Value^);
    P := P^.Next;
    if (I = Selected) and (Sel) then Platform(0, Y+2, 20, Y+10, Lowergrey)
    else Platform(0, Y+2, 20, Y+10, Raisegrey);
    if ((1 shl I) and Value <> 0) and not StateOn(vsDisabled) then
      C := $0F0A else C := $0F08;
    Platform(4, Y+5, 15, Y+7, C);
  end;
end;

function TCluster.ValidAmount :Byte;
  var I :Byte; P :PLPString;
begin
  P := Text;
  I := 0;
  while (P <> nil) and (I < 32) do
  begin
    Inc(I);
    P := P^.Next;
  end;
  ValidAmount := I;
end;

procedure TCluster.KeybordInput(var Input :TKeybordInput);
begin
  inherited KeybordInput(Input);
  if Input.What and InKeybord = 0 then Exit;
  case Input.Keycode of
    kbUp   :
      begin
        if Selected = 0 then Selected := ValidAmount-1
        else Dec(Selected);
      end;
    kbDown :
      begin
        if Selected = ValidAmount-1 then Selected := 0
        else Inc(Selected);
      end;
    kbSpace :
      begin
        Value := Value xor (1 shl Selected);
      end;
    else Exit;
  end;
  InputHandled(Input);
  Draw;
end;

procedure TCluster.MouseInput(var Input :TMouseInput);
  var P :TPoint;
      Sel :Integer;
begin
  inherited MouseInput(Input);
  with Input do
  begin
    if What and (inMouseLD or inMouseLU) <> 0 then
    begin
      MakeLocal(Where, P);
      SetTextStyle(2, Horizdir, 4);
      Sel := P.Y div (TextHeight('X')+3);
      if (What and inMouseLD <> 0) and (sel < ValidAmount) and
         (Sel >= 0) then Selected := Sel
      else if Sel = Selected then Value := Value xor (1 shl Selected);
      InputHandled(Input);
      Draw;
    end;
  end;
end;

function TCluster.On(Which :LongInt) :Boolean;
begin
  On := Value and Which <> 0;
end;

procedure TCluster.GetData(var Rec);
begin
  Move(Value, Rec, DataSize);
end;

procedure TCluster.SetData(var Rec);
begin
  Move(Rec, Value, DataSize);
  Draw;
end;

function TCluster.DataSize :Word;
begin
  Case ValidAmount of
    1..8   :DataSize := 1;
    9..16  :DataSize := 2;
    17..32 :DataSize := 4;
  end;
end;


{****************************************************************************}
{*   TStaticText                                                            *}
{****************************************************************************}
constructor TStaticText.Init
  (B :TBounds; AFont, ASize, AColor :Byte; AText :String);
begin
  inherited Init(B);
  Text := NewStr(AText);
  Font := AFont;
  CharSize := ASize;
  Colors := AColor;
end;

destructor TStaticText.Done;
begin
  inherited done;
  DisposeStr(Text);
end;

procedure TStaticText.Art;
  var Y :Word;
      Position :Word;
      S :String[100];
      Len :Byte;
      Centered :Boolean;
      Line :String;

    function ReadNext :String;
      const Deviders :TCharSet = [#3, #13, ' '];
        var I :Byte;
    begin
      if Position > Len then ReadNext := ''
      else
      if Text^[Position] in Deviders then
      begin
        ReadNext := Text^[Position];
        Inc(Position);
      end
      else
      begin
        I := Position;
        while not (Text^[Position] in Deviders) and (Position <= Len)
        do Inc(Position);
        ReadNext := Copy(Text^, I, Position-I);
      end;
    end;

    Procedure PrintLine;
    begin
      if Centered then
      begin
        SetTextJustify(CenterText, TopText);
        if Line[Length(Line)] = ' ' then Dec(Line[0]);
        OutTextXY(Size.X shr 1, Y, Line);
      end
      else
      begin
        SetTextJustify(LeftText, TopText);
        OutTextXY(0, Y, Line);
      end;
      Inc(Y, TextHeight('X'));
      Line := '';
    end;

begin { TStatictext.Art }
  Platform(0, 0, Size.X, Size.Y, Colors div 16);
  SetTextStyle(Font, Horizdir, CharSize);
  SetColor(Colors mod 16);
  Centered := False;
  Position := 1;
  Y := 0;
  Len := Length(Text^);
  Line := '';
  S := ReadNext;
  while S <> '' do
  begin
    if S = #13 then begin PrintLine; Centered := False; end else
    if S = #3 then Centered := True else
    if S = ' ' then begin if Line <> '' then Line := Line+' '; end else
    if (TextWidth(Line+S) <= Size.X) then Line := Line+S
    else
      begin
        PrintLine;
        Line := S;
      end;
    S := ReadNext;
  end;
  PrintLine;
end; { TStatictext.Art }

procedure TStatictext.SetData(var Data);
begin
  DisposeStr(Text);
  Text := NewStr(String(Data));
  Draw;
end;

procedure TStatictext.GetData(var Data);
begin
  String(Data) := Text^;
end;

function TStatictext.DataSize :Word;
begin
  DataSize := Sizeof(String);
end;

{****************************************************************************}
{* TMessagewindow Object Implementation                                     *}
{****************************************************************************}
constructor TMessageWindow.Init
  (B :TBounds; ACaption, AText :String; AColors :LongInt);
begin
  inherited Init(B);
  { set fields }
  Caption := NewStr(ACaption);
  Colors  := AColors;
  { Add the text object }
  B.Assign(8, 36, Size.X-8, Size.Y-35);
  Append(New(PStatictext, Init(B, 2, 5, $70+Lo(Colors) mod 16 , AText)));
end; { Init }

destructor TMessageWindow.Done;
begin
  DisposeStr(Caption);
  inherited done;
end; { Done }

procedure TMessageWindow.Art;
begin
  Platform(0, 0, Size.X, Size.Y,  $F008);
  Platform(5, 5, Size.X-5, Size.Y-5,  $0F07);
  { Draw Caption }
  Platform(6, 6, Size.X-6, 26,  TLongRec(Colors).Hi);
  if Caption <> nil then
    WriteStrXY(Size.X shr 1, 13, Lo(Colors) div 16, 2, 5, JustCenter,
      False, Caption^);
end;{ Art }

procedure TMessageWindow.Listen(var Speech :TSpeech);
begin
  { React to button press }
  if Speech.Tone <> 0 then
  begin
    EndModal(Speech.What);
    SpeechHeard(Speech);
  end;
end; { Listen }

procedure TMessageWindow.KeybordInput(var Input :TKeybordInput);
begin
  inherited KeybordInput(Input);
  { React to Arrows for button selection }
  if Input.What <> inNothing then
  case Input.Keycode of
    kbLeft  :SelectPrevious;
    kbRight :SelectNext;
  end;
end; { KeybordInput }


{****************************************************************************}
{*  Public Routines                                                         *}
{****************************************************************************}
function MessageWindow(B :TBounds; Text :String; Options :Byte) :Word;
  const Caption :Array[mwfWarning..mwfInformation] of String[27] =
          ('Testmaker Waarskuwing', 'Testmaker Fout Rapportering',
           'TestMaker Bevestiging', 'TestMaker Informasie');
        Colors :Array[mwfWarning..mwfInformation] of LongInt =
          ($F80400E0, $F80400E0, $F80600F0, $F80900F0);
        ButtonName: array[0..3] of string[10] =
          ('Aanvaar', 'Ja', 'Nee', 'Kanselleer');
        Command: array[0..3] of word =
          (cmOK, cmYes, cmNo, cmCancel);
  var
    Win :TMessageWindow; I :Byte;
    ButtonList :Array[0..3] of PButton;
    ButtonCount :Byte; X, D :Integer;
begin
  { Initialize a TMessageWindow Object }
  Win.Init(B, Caption[Options mod 16], Text, Colors[Options mod 16]);
  with Win do
  begin
    { Add the buttons }
    D := 0;
    ButtonCount := 0;
    for I := 0 to 3 do
      if Options and ($10 shl I) <> 0 then
      begin
        Inc(ButtonCount);
        X := 10*Length(ButtonName[I])+5;
        B.Assign(D, Size.Y-25, D+X, Size.Y-10);
        ButtonList[ButtonCount-1] :=
          New(PButton, Init(B, ButtonName[I], Command[I], 0));
        D := D+X+10;
      end;
    X := Size.X shr 1 - (D-10) shr 1;
    for I := 0 to ButtonCount-1 do
    begin
      Inc(ButtonList[I]^.Origin.X, X);
      Append(ButtonList[I]);
    end;
    { execute the view }
    MessageWindow := Execute;
    { clean up }
    Done;
  end;
  { remove view }
  Application^.Draw;
end; { Function Messagewindow }


end. { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* Constants and types for general use                                      *}
{****************************************************************************}
Unit sTypes;

Interface

const
{***þ Control Operation Constants þ***}
  qNone         = 0;
  qUp           = 1;    { Movement }
  qDown         = 2;
  qLeft         = 3;
  qRight        = 4;
  qHome         = 5;
  qEnd          = 6;
  qHomeX        = 7;
  qEndX         = 8;
  qHomeY        = 9;
  qEndY         = 10;
  qMarkLeft     = 11;
  qMarkRight    = 12;
  qSelect       = 13;   { selection }
  qTag          = 14;
  qEdit         = 15;   { edit }
  qAppend       = 16;
  qInsert       = 17;
  qOverWrite    = 18;
  qDelete       = 19;
  qBack         = 20;
  qClear        = 21;
  qToggleIns    = 22;   { toggle }
  qConvertUpper = 23;   { conversion }
  qConvertLower = 24;

{***þ Character set þ***}
type
  TCharSet = Set of Char;
  TCommandSet = set of Byte;

{***þ Typecasting Arrays þ***}
type
	TByteArray    = array[0..$FFFE] of Byte;
	TWordArray    = array[0..$7FFE] of Word;
	TLongArray    = array[0..$3FFE] of LongInt;
	TPointerArray = array[0..$3FFE] of Pointer;

{***þ Typecasting Buffers þ***}
type
  TByteBuffer = array[1..32768] of Byte;
  TCharBuffer = array[1..32768] of Char;
  TWordBuffer = array[1..16384] of Word;

{***þ Typecasting Records þ***}
	TLongRec = record
		case Integer of
			0 : (Long            :LongInt);
			1 : (Ptr             :Pointer);
			2 : (Offset, Segment :Word);
			3 : (Lo, Hi          :Word);
			4 : (B1, B2, B3, B4  :Byte);
	end;

	TWordRec = record
		case Integer of
			0 :(W :Word);
			1 :(Lo, Hi: Byte);
	end;

{***þ String Types with defined length þ***}
type
  String8  = String[8];
  String32 = String[32];
  String5  = String[5];
  String17 = String[17];

{***þ File name string types þ***}
type
	TFileExt   = String[3];
	TFileName  = String[8];
	TFileStr   = String[12];
  TDirStr    = String[12];
	TExtrFile  = String[79];

{***þ String Relative þ***}
type
  PString = ^String;
  PPalette = ^TPalette;
  TPalette = String;

{***þ General Types þ***}
type
  TOffset = LongInt;

{***þ Date data record with numeric format þ***}
type
  PDateRecord = ^TDateRecord;
  TDateRecord = record
    Year, Month, Day, DayofWeek :Word;
  end;

{***þ Date data record with numeric and string format
       used for fancy displays of dates þ***}
  TFancyDate = record
    DayofWeek :PString;
    Day       :Word;
    Month     :PString;
    Year      :Word;
  end;

{***þ Linking þ***}
type
  PLPString = ^TLPString;
  TLPString = record
    Value :PString;
    Next  :PLPString;
  end;


Implementation


end.  { Unit }{****************************************************************************}
{*  TestMaker Test Paper Creating Tool                                      *}
{*    Edit by Hannes de Jager 1996                                          *}
{*  View and Group objects                                                  *}
{****************************************************************************}
Unit SView;
  {$F-,O-,Q-,R-,S-}

Interface
  Uses Objects, sBasic, sInput, sTypes;

{***þ View Communication Constants þ***}
const
  spNone      = $00;
  spCommand   = $01;
  spRespond   = $02;
  spNotify    = $04;
  spRecommend = $08;
  spRequest   = $10;


{***þ View Options þ***}
const
 voSelectable = $0001;
 voFirstclick = $0002;
 voMoveable   = $0004;

{***þ View States þ***}
const
  vsVisible    = $0001;
  vsModal      = $0002;
  vsSelected   = $0004;
  vsPressed    = $0008;
  vsDisabled   = $0010;
  vsInsert     = $0020;
  vsDeleted    = $F000;

{***þ View Pointer þ***}
type
  PView = ^TView;
  PViewGroup = ^TViewGroup;

{***þ View Communication transfer Record þ***}
  TSpeech = record
    Talker  :PView; { The View that called }
    Tone    :Word;  { Command, Respond, Notify or Recomend }
    What    :Word;
    case Word of    { Info }
      0 :(InfoPtr     :Pointer);
      1 :(InfoPChar   :PChar);
	    2 :(InfoPString :PString);
      3 :(InfoLong    :LongInt);
      4 :(InfoWord    :Word);
      5 :(InfoInt     :Integer);
      6 :(InfoByte    :Byte);
      7 :(InfoShort   :ShortInt);
      8 :(InfoChar    :Char);
  end;

{***þ View Object þ***}
  TView = Object(TObject)
    Owner       :PViewGroup;
    Next        :PView;
    Origin      :TPoint;
    Size        :TPoint;
    ViewOptions :Word;
    ViewState   :Word;
    InputMask   :Word;
    HelpCtx     :Word;
    constructor Init(Bounds :TBounds);
    procedure   Art; virtual;
    function    Previous :PView;
    procedure   Draw; virtual;
    procedure   MouseInput(var Input :TMouseInput); virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    procedure   Listen(var Speech :TSpeech); virtual;
    procedure   Speak(Listener :PView; var Speech :TSpeech);
    function    Message(Listener :PView; ATone, AWhat :Word; Info :Pointer) :PView;
    procedure   PutSpeech(var Speech :TSpeech);
    function    StateOn(StateFlags :Word) :Boolean;
    procedure   SetState(StateFlag :Word; Enable :Boolean); virtual;
    procedure   ToggleState(StateFlag :Word);
    function    PointIn(P :TPoint) :Boolean;
    procedure   PutMessage(ATone, AWhat :Word; Info :Pointer);
    procedure   SpeechHeard(var speech :TSpeech);
    function    ID :Word; virtual;
    function    Palette :PPalette; virtual;
    function    GetColor(Color :Word) :Word;
    procedure   MakeLocal(Source :TPoint; var Dest :TPoint);
    procedure   MakeGlobal(Source :TPoint; var Dest :TPoint);
    function    Execute :Word; virtual;
    procedure   EndModal(Condition :Word);
    procedure   InputHandled(var Input);
    procedure   Select;
    function    Valid(Command :Word) :Boolean; virtual;
    procedure   Turn; virtual;
    procedure   Terminate; virtual;
    procedure   Getdata(var Rec); virtual;
    procedure   SetData(var Rec); virtual;
    function    DataSize :Word; virtual;
    procedure   GotFocus; virtual;
    procedure   LostFocus; virtual;
    procedure   Lock;
    procedure   Unlock;
    function    Locked :Boolean;
    private
       LockCount :Word;
  end;

{***þ View Group Object þ***}
  TViewGroup = Object(TView)
    LastView   :PView;
    ActiveView :PView;
    constructor Init(Bounds :TBounds);
    destructor  Done; virtual;
    procedure   Append(View :PView);
    procedure   Insert(View, Target :PView);
    procedure   Remove(View :PView);
    procedure   Delete(View :PView);
    procedure   ForEach(Action :Pointer);
    function    FirstThat(Condition :Pointer) :PView;
    procedure   Draw; virtual;
    procedure   MouseInput(var Input :TMouseInput); virtual;
    procedure   KeybordInput(var Input :TKeybordInput); virtual;
    procedure   SelectNext;
    procedure   SelectPrevious;
    procedure   SelectWithMouse(Where :TPoint);
    procedure   Listen(var Speech :TSpeech); virtual;
    function    ExecView(P :PView) :Word;
    function    Valid(Command :Word) :Boolean; virtual;
    procedure   Turn; virtual;
    procedure   Getdata(var Rec); virtual;
    procedure   SetData(var Rec); virtual;
    function    DataSize :Word; virtual;
    private
      function    ViewWithPoint(Where :TPoint) :PView;
      procedure   DrawSubViews;
  end;


Implementation
  uses sProcs, Graph, consts;

const
  { The Word returned when a model view terminates }
  ModalEndCondition :Word = 0;
  { The next message to be send to the modal view }
  NextMessage :TSpeech =
    (Talker :nil;
     Tone   :spNone;
     What   :0);

{****************************************************************************}
{*  TView                                                                   *}
{****************************************************************************}
constructor TView.Init(Bounds :TBounds);
begin
  Inherited Init;
  Origin := TPoint(Bounds.A);
  Size.X := Bounds.Width;
  Size.Y := Bounds.Height;
  ViewState := vsVisible;
  InputMask := $FF00;
  if MouseAvail then inputMask := inkeybord or inMouse;
end;

procedure TView.Art;
begin
  Abstract('TView.Art');
end;

procedure TView.Draw;
  var HideMousePointer :Boolean;
      P :TPoint; B :TBounds;
begin
  if Locked then Exit;
  if not StateOn(vsVisible) then Exit;
  ClearMem(P, Sizeof(P));
  MakeGlobal(P, P);
  B.Assign(P.X-10, P.Y-10, P.X+Size.X+10, P.Y+Size.Y+10);
  HideMousePointer := MouseAvail and B.Within(MouseWhere);
  SetViewPort(P.X, P.Y, P.X+Size.X, P.Y+Size.Y, ClipOn);
  if HideMousePointer then HideMouse;
  Art;
  if HideMousePointer then ShowMouse;
end;

function TView.Previous :PView;
  var P :PView;
begin
  P := @Self;
  while (P^.Next <> @self) do P := P^.Next;
  Previous := P;
end;

procedure TView.MouseInput(var Input :TMouseInput);
begin
end;

procedure TView.KeybordInput(var Input :TKeybordInput);
begin;
  if Input.What and inKeyDown <> 0 then
    case Input.KeyCode of
     kbCtrlBreak :PutMessage(spCommand, cmQuit, nil);
     kbF1 :
       Putmessage(spCommand, cmHelpDisplay, Ptr(0, HelpCtx));
     else Exit;
   end;
   InputHandled(Input);
end;

function TView.StateOn(StateFlags :Word) :Boolean;
  var P :PView;
begin
  StateOn := StateFlags and ViewState <> 0;
  if not
   (StateFlags and (vsSelected or vsDisabled or vsVisible) <> 0) then exit;
  P    := @Self;
  while P <> nil do
  begin
    if not(P^.ViewState and StateFlags <> 0) then StateOn := False;
    P := P^.Owner;
  end;
end;

procedure TView.SetState(StateFlag :Word; Enable :Boolean);
  var Speech :TSpeech;
begin
  Case Enable of
    True  :ViewState := ViewState or StateFlag;
    False :ViewState := ViewState - (ViewState and StateFlag);
  end;
  if StateFlag and vsDisabled <> 0 then
  begin
    SetState(vsSelected, False);
    if Owner <> nil then Owner^.SelectNext;
  end;
  if StateFlag and vsSelected <> 0 then
  begin
    if Enable then GotFocus else LostFocus;
    Draw;
  end;
  if StateFlag and vsVisible <> 0 then
  with Speech do
  begin
    Talker := @Self;
    Tone   := spCommand;
    What   := cmDraw;
    Speak(Owner, Speech);
  end;
end;

procedure TView.ToggleState(StateFlag :Word);
begin
  SetState(StateFlag, not (ViewState and StateFlag <> 0));
end;

function TView.PointIn(P :TPoint) :Boolean;
begin
  MakeLocal(P, P);
  PointIn := (P.X >= 0) and (P.X <= Size.X) and
             (P.Y >= 0) and (P.Y <= Size.Y);
end;

procedure TView.Speak(Listener :PView; var Speech :TSpeech);
begin
  if Listener <> nil then Listener^.Listen(Speech);
end;

procedure TView.PutSpeech(var Speech :TSpeech);
begin
  NextMessage := Speech;
end;

function TView.Message
  (Listener :PView; ATone, AWhat :Word; Info :Pointer) :PView;
  var Speech :TSpeech;
begin
  with Speech do
  begin
    Talker  := @Self;
    Tone    := ATone;
    What    := AWhat;
    InfoPtr := Info;
  end;
  if Listener <> nil then Listener^.Listen(Speech);
  with Speech do
    if Tone = spNone then Message := Talker else Message := nil;
end;

procedure TView.PutMessage(ATone, AWhat :Word; Info :Pointer);
  var Speech :TSpeech;
begin
  with speech do
  begin
    Talker  := @Self;
    Tone    := ATone;
    What    := AWhat;
    InfoPtr := Info;
  end;
  PutSpeech(Speech);
end;

procedure TView.SpeechHeard(var Speech :TSpeech);
begin
  with Speech do
  begin
    Talker := @Self;
    Tone := spNone;
  end;
end;

procedure TView.Listen(var Speech :TSpeech);
begin
  if Speech.Tone = spCommand then
  Case Speech.What of
    cmDraw      :Draw;
    cmTerminate :Terminate;
    cmEndModal  :EndModal(cmEndModal);
  end;
end;

function TView.ID :Word;
begin
  Abstract('TView.ID');
end;

function TView.Palette :PPalette;
begin
  Abstract('TView.Palette');
end;

function TView.GetColor(Color :Word) :Word;
  var Pal :PPalette;
begin
  Pal := Palette;
  if (Color > Length(Pal^)) or (Color = 0) then GetColor := $00
  else
    Getcolor := Byte(Pal^[Color]);
end;

procedure TView.MakeLocal(Source :TPoint; var Dest :TPoint);
  var P :PView;
begin
  Dest := Source;
  P    := @Self;
  while P <> nil do
  begin
    Dest.X := Dest.X - P^.Origin.X;
    Dest.Y := Dest.Y - P^.Origin.Y;
    P := P^.Owner;
  end;
end;

procedure TView.MakeGlobal(Source :TPoint; var Dest :TPoint);
  var P :PView;
begin
  Dest := Source;
  P := @Self;
  while P <> nil do
  begin
    Dest.X := Dest.X + P^.Origin.X;
    Dest.Y := Dest.Y + P^.Origin.Y;
    P := P^.Owner;
  end
end;

function TView.Execute :Word;
  var MInput :TMouseInput;
      KInput  :TKeybordInput;
      Transfer :Boolean;
      Speech   :TSpeech;
begin
  if StateOn(vsDisabled) then Exit;
  SetState(vsModal+vsSelected, True);
  repeat
    Speech := NextMessage;
    NextMessage.Tone := spNone;
    if Speech.Tone <> spNone then Listen(Speech);
    GetKeyInput(KInput, False, False);
    with KInput do
      if What and InputMask <> 0 then KeybordInput(KInput);
    GetMouseInput(MInput);
    with MInput Do
      if (What and InputMask <> 0) and PointIn(Where) then MouseInput(MInput);
    Turn;
  until not StateOn(vsModal);
  Execute := ModalEndCondition;
end;

procedure TView.EndModal(Condition :Word);
begin
  if not StateOn(vsModal) or not Valid(cmClose) then Exit;
  SetState(vsModal, False);
  ModalEndCondition := Condition;
end;

procedure TView.InputHandled(var Input);
begin
  with TKeybordInput(Input) do
  begin
    What := inNothing;
    HandledBy := @Self;
  end;
end;

procedure TView.Select;
begin
  if not ((Owner <> nil) and (ViewOptions and voSelectable <> 0)) or
     StateOn(vsSelected) or StateOn(vsDisabled) then exit;
  if Owner^.ActiveView <> nil then
    Owner^.ActiveView^.SetState(vsSelected, False);
  Owner^.ActiveView := @Self;
  SetState(vsSelected, True);
end;

function TView.Valid(Command :Word) :Boolean;
begin
  Valid := True;
end;

procedure TView.Turn;
begin
end;

procedure TView.Terminate;
begin
  if Valid(cmTerminate) then
  begin
    SetState(vsDeleted, True);
    if Message(Owner, spNotify, cmTerminate, @Self) = nil then EndModal(cmQuit);
  end;
end;

procedure TView.Getdata(var Rec);
begin
end;

procedure TView.SetData(var Rec);
begin
end;

function TView.DataSize :Word;
begin
  DataSize := 0;
end;

procedure TView.Lock;
begin
  if LockCount < 65535 then Inc(LockCount);
end;

procedure TView.Unlock;
begin
  if LockCount > 0 then Dec(LockCount);
end;

function TView.Locked :Boolean;
  var P :PViewGroup;
begin
  P := @Self;
  Locked := False;
  while P <> nil do
  begin
    if P^.LockCount > 0 then Locked := True;
    P := P^.Owner;
  end;
end;

procedure TView.GotFocus;
begin
end;

procedure TView.LostFocus;
begin
end;


{****************************************************************************}
{*  TViewGroup                                                              *}
{****************************************************************************}
constructor TViewGroup.Init(Bounds :TBounds);
begin
  inherited Init(Bounds);
  LastView   := nil;
  ActiveView := nil;
end;

destructor TViewGroup.Done;
    procedure FreeView(View :PView); far;
    begin
      Dispose(View, Done);
    end;
begin
  Lock;
  ForEach(@FreeView);
  Unlock;
  inherited Done;
end;

procedure TViewGroup.Append(View :PView);
begin
  {$IFNDEF FinalVersion}
  if View = nil then Abort('Append of nil View');
  {$EndIf}
  View^.Owner := @Self;        { Set view's owner }
  if LastView <> nil then      { if there are already views in the list }
  begin
	  View^.Next := LastView^.Next;
    LastView^.Next := View;
    LastView := View;
  end
  else                         { if this view is the only one in the list }
  begin
    View^.Next := View;
    LastView := View;
  end;
  View^.Select;
end;

procedure TViewGroup.Insert(View, Target :PView);
begin
  {$IFNDEF FinalVersion}
  if View = nil then Abort('Insert of nil View');
  {$EndIf}
  if (Target = nil) or (LastView = nil) then begin Append(View); exit; end;
  with View^ do
  begin
    View^.Owner := @Self;        { Set view's owner }
    View^.Next := Target^.Next;
    Target^.Next := View;
    Select;
  end;
end;

procedure TViewGroup.Remove(View :PView);
begin
  {$IFNDEF FinalVersion}
  if View = nil then Abort('Remove of nil View');
  {$EndIf}
  if View = LastView then LastView := View^.Previous;
  Lock;
  if View = ActiveView then SelectNext;
  Unlock;
  View^.Previous^.Next := View^.Next;
  if View = LastView then LastView := nil;
  if View = ActiveView then Activeview := nil;
  Draw;
end;

procedure TViewGroup.Delete(View :PView);
begin
  {$IFNDEF FinalVersion}
  if View = nil then Abort('Delete of nil View');
  {$EndIf}
  Remove(View);
  Dispose(View, Done);
  View := nil;
end;

{ ForEach Help Routines }
function CallerFrame: Word; inline(
  $8B/$46/$00  { MOV   AX, [BP] }
);
procedure ActionCall(View :PView; Action :Pointer; Frame :Word); near; assembler;
asm
  LES    DI, View
  PUSH   ES                { Pass Parameter - View }
  PUSH   DI
  PUSH   WORD  PTR Frame   { Pass Callers Stack Frame }
  CALL   DWORD PTR Action  { Call Local Procedure }
end;
  { procedure Action(View :PView); far; local; }
procedure TViewGroup.ForEach(Action :Pointer);
  var First, P, P2 :PView;
      CallerStackFrame :Word;
begin
  if LastView = nil then exit; { Can't do an action on an empty List }
  CallerStackFrame := CallerFrame;
  First := LastView^.Next;
  P := First;         { Set P to point to First View }
  repeat
    P2 := P;
    if P2 <> nil then
    begin
      P := P^.Next;
      ActionCall(P2, Action, CallerStackFrame);
    end;
  until P = First;
end;

function ConditionCall
  (View :PView; Condition :Pointer; Frame :Word) :Boolean; near; assembler;
asm
  LES    DI, View
  PUSH   ES                  { Pass Parameter - View }
  PUSH   DI
  PUSH   WORD  PTR Frame     { Pass Callers Stack Frame }
  CALL   DWORD PTR Condition { Call Local Procedure }
end;

  { function Action(View :PView) :Boolean; far; local; }
function TViewGroup.FirstThat(Condition :Pointer) :PView;
  var P :PView;
      CallerStackFrame :Word;
begin
  FirstThat := nil;
  if LastView = nil then exit; { Can't do an action on an empty List }
  CallerStackFrame := CallerFrame;
  P := LastView^.Next;         { Set P to point to First View }
  repeat
    if ConditionCall(P, Condition, CallerStackFrame) then
    begin
      FirstThat := P;
      Break;
    end else FirstThat := nil;
    P := P^.Next;
  until P = LastView^.Next;
end;

procedure TViewGroup.Draw;
begin
  if Locked then Exit;
  inherited Draw;
  DrawSubViews;
end;

procedure TViewGroup.MouseInput(var Input :TMouseInput);
  var Transfer :Boolean;
begin
  with Input do
  begin
    if What and inMouseDown <> 0 then
    begin
		  Transfer := ActiveView^.PointIn(Where);
      if not Transfer then
      begin
        SelectWithMouse(Where);
        if ActiveView^.PointIn(Where) then
          if not ActiveView^.ViewOptions and voFirstClick <> 0 then
          begin
    			  InputHandled(Input);
            Transfer := False;
          end
          else Transfer := True;
      end;
    end
    else Transfer := True;
  end;
  Transfer := Transfer and (ActiveView <> nil);
  if Transfer then ActiveView^.MouseInput(Input);
end;

procedure TViewGroup.KeybordInput(var Input :TKeybordInput);
begin
  if ActiveView = nil then exit;
  ActiveView^.KeybordInput(Input);
  Inherited KeybordInput(Input);
  if Input.What <> inNothing then
  case Input.KeyCode of
    kbTab :
      begin
        SelectNext;
        InputHandled(Input);
      end;
    kbShiftTab :
      begin
        SelectPrevious;
        InputHandled(Input);
      end;
    else Exit;
  end;
End;

procedure TViewGroup.SelectNext;
  var P, A :PView;
begin
  if ActiveView = nil then exit;
  A := ActiveView;
  P := ActiveView^.Next;
  while (ActiveView = A) and (P <> A) do
  begin
    P^.Select;
    P := P^.Next;
  end;
end;

procedure TViewGroup.SelectPrevious;
  var P, A :PView;
begin
  if ActiveView = nil then exit;
  A := ActiveView;
  P := ActiveView^.Previous;
  while (ActiveView = A) and (P <> A) do
  begin
    P^.Select;
    P := P^.Previous;
  end;
end;

procedure TViewGroup.SelectWithMouse(Where :TPoint);
  var P :PView;
begin
  P := ViewWithPoint(Where);
  if P <> nil then  P^.Select;
end;

procedure TViewgroup.Listen(var Speech :TSpeech);
    procedure SpeakToThisOne(View :PView); far;
    begin
      if not View^.StateOn(vsDisabled) then View^.Listen(Speech);
    end;
begin
  inherited Listen(Speech);
  if Speech.Tone = spCommand then
    Case Speech.What of
      cmDraw :
        begin
          Draw;
          SpeechHeard(Speech);
        end;
      cmNext :
        begin
          SelectNext;
          SpeechHeard(Speech);
        end;
      cmPrevious :
        begin
          SelectPrevious;
          SpeechHeard(Speech);
        end;
      cmQuit :EndModal(cmQuit);
    end;
  ForEach(@SpeakToThisOne);
end;

function TViewGroup.ExecView(P :PView) :Word;
begin
  Lock;
  Append(P);
  Unlock;
  ExecView := P^.Execute;
  Delete(P);
end;

function TViewGroup.Valid(Command :Word) :Boolean;
    procedure CheckForValid(View :PView); far;
    begin
      if Not View^.Valid(Command) then Valid := False;
    end;
begin
  Valid := True;
  ForEach(@CheckForValid);
end;

Procedure TViewGroup.Turn;
    procedure ViewTurn(View :PView); far;
    begin
      if View^.StateOn(vsDeleted) then Delete(View) else
        if not View^.StateOn(vsDisabled) then View^.Turn;
    end;
begin
  ForEach(@ViewTurn);
end;

procedure TViewGroup.Getdata(var Rec);
   procedure GetViewData(View :PView); far;
     var Amount :Word;
   begin
     View^.GetData(Rec);
     Amount := View^.DataSize;
     asm
       MOV  BX, [BP+6]              { Get Parent's Stack Frame }
       MOV  AX, SS:[BX+OFFSET Rec]  { Put ParamsIndex in AX    }
       ADD  AX, Amount
       MOV  SS:[BX+OFFSET Rec], AX
     end;
   end;
begin
  ForEach(@GetViewData);
end;

procedure TViewGroup.SetData(var Rec);
   procedure SetViewData(View :PView); far;
     var Amount :Word;
   begin
     View^.SetData(Rec);
     Amount := View^.DataSize;
     asm
       MOV  BX, [BP+6]              { Get Parent's Stack Frame }
       MOV  AX, SS:[BX+OFFSET Rec]  { Put ParamsIndex in AX    }
       ADD  AX, Amount
       MOV  SS:[BX+OFFSET Rec], AX
     end;
   end;
begin
  ForEach(@SetViewData);
end;

function TViewGroup.DataSize :Word;
  var Total :Word;
     procedure GetViewSize(View :PView); far;
     begin
       Inc(Total, View^.DataSize);
     end;
begin
  Total := 0;
  ForEach(@GetViewSize);
  DataSize := Total;
end;

function TViewGroup.ViewWithPoint(Where :TPoint) :PView;
    function ContainsMouse(View :PView) :Boolean; far;
    begin
      ContainsMouse := View^.PointIn(Where);
    end;
begin
  ViewWithPoint := FirstThat(@ContainsMouse);
end;

procedure TViewGroup.DrawSubViews;
    procedure DrawThisView(View :PView); far;
    begin
      if View <> nil then View^.Draw;
    end;
begin
  ForEach(@DrawThisView);
end;


end.  { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{****************************************************************************}
Unit TMData;
  {$F+,O+,Q-,R-,S-}

interface
  uses Objects, sTypes;

{***þ Program File Names þ***}
const
  CnfFile_Name    = 'TESTMAKE.CNF';
  DemoFile_Name   = 'DEMO.TMS';
  HelpFile_Name   = 'TESTMAKE.HLP';
  ResFile_Name    = 'TESTMAKE.RES';

{***þ HelpFile Errors þ***}
const
  HelpFile_Ok        = 0;
  HelpFile_NotFound  = 1;
  HelpFile_NoCtx     = 2;
  HelpFile_IOError   = 3;
  HelpFile_DataError = 4;

{***þ Testmaker Setfile signature þ***}
const
  TMFile_Signature = 'TMSET';

  TMFile_NoErr          = 0;
  TMFile_FormatErr      = 1;
  TMFile_InvalidName    = 2;
  TMFile_ReadErr        = 3;
  TMFile_WriteErr       = 4;
  TMFile_NotFound       = 5;

{***þ DataStream for save and load of Setfiles þ***}
type
  TDataStream = Object(TDosStream)
    procedure Error(Code, Info: Integer); virtual;
  end;


{***þ Data: Paper Description þ***}
type
  TTDescript = record
    Description :String[30];
    Password    :String[30];
    Mask        :Byte;
  end;

{***þ Data: Paper Header þ***}
type
  TTHeader = record
    Subject  :String[30];
    Number   :String[15];
    Standard :String[20];
    Grade    :String[15];
    Date     :String[20];
    Setter   :String[30];
    Time     :String[10];
  end;

{***þ Data object controlling data of a Testmaker setfile þ***}
type
  PPaperData = ^TPaperData;
  TPaperData = Object(TObject)
    FileName     :PString;
    Modified     :Boolean;
    Descript     :TTDescript;
    Header       :TTHeader;
    Items        :PCollection;
    Error        :Byte;
    constructor Init(F :String);
    destructor  Done; virtual;
    procedure   Load;
    procedure   Save;
    procedure   NotifyOfError;
    function    ValidFileName(Name :String) :Boolean;
    function    GetTruncfileName :String;
  end;

{***þ Helpfile controller þ***}
type
  PHelpFile = ^THelpFile;
  THelpFile = Object(TObject)
    Handle   :Text;
    CtxEnd   :Boolean;
    ErrorVal :Integer;
    constructor Init;
    destructor  Done; virtual;
    procedure   Error(Code :Integer);
    function    Readline :String;
    procedure   ScanToCtx(Ctx :Word);
    procedure   ScanToTopic(Topic :String);
  end;

{***þ Routines þ***}
  function GetfileNameOnly(FileName :String) :String;
  function GetResource(Name :String) :PObject;

{***þ Initialized vairables þ***}
const
  PaperData  :PPaperData  = nil;
  StartUpDir :PString = nil;


Implementation
  uses sProcs, sBasic, STDViews;

{ Takes a Full Path+File Name as Parameter and returns only the FileName }
function GetfileNameOnly(FileName :String) :String;
  var S :String;
      B :Byte;
begin
  S := FileName;
  for B := Length(S) downto 1 do
   if S[B] = '\' then
   begin
     S := copy(S, B+1, Length(S)-B);
     Break;
   end;
  S := SRemoveCh(S, ' ');
  GetFileNameOnly := S;
end;

{ Reads any resource object from Testmaker's resource file }
function GetResource(Name :String) :PObject;
  var RF :TResourceFile;
begin
  RF.Init(New(PBufStream, Init(StartUpDir^+'TESTMAKE.RES', stOpenRead, 510)));
  GetResource := RF.Get(Name);
  RF.Done;
end;

{ Specialized Datastream error handler }
procedure TDataStream.Error(Code, Info: Integer);
  var S :String;
      B :TBounds;
begin
  Status := Code;
  case Code of
    stError      :S := 'File access error';
    stInitError  :S := 'Cannot initialize File';
    stReadError  :S := 'Read beyond end of stream';
    stWriteError :S := 'Cannot expand stream';
    stGetError   :S := 'Get of unregistered object type';
    stPutError   :S := 'Put of unregistered object type';
  end;
  S := #3+S;
  B.Assign(125, 200, 515, 300);
  MessageWindow(B, S, mwfError+mwfOk);
end;


{****************************************************************************}
{*  TPaperdata Objet                                                       *}
{****************************************************************************}
{ Initializes the PaperData Object }
constructor TPaperData.Init(F :String);
begin
  Inherited Init;
  FileName := NewStr(F);
  New(Items, Init(1, 1));
end;

{ Does the disposal of the paperdata object }
destructor TPaperData.Done;
begin
  DisposeStr(FileName);
  if Items <> nil then Dispose(Items, Done);
  inherited done;
end;

{ This procedure does the actual reading of the data from the file. }
procedure TPaperData.Load;
  var F :TDataStream;
      S :String;
      Signature :Array[0..4] of Char;

    Procedure ReadPassword;
      var I :Byte; PW :String[30];
    begin
      F.Read(PW, Sizeof(PW));
      for I := 1 to Length(PW) do
      begin
        if PW[I] in [#2..#255] then Dec(PW[I]);
        if PW[I] = #1 then PW[I] := #255;
      end;
      Descript.Password := PW;
    end;

begin
  with F do
  begin
    Init(FileName^, stOpenRead);
    Read(Signature, Sizeof(Signature));
    with Descript do
    begin
      Read(Description, Sizeof(Description));
      ReadPassword;
      Read(Mask, Sizeof(Mask));
    end;
    Read(Header, Sizeof(Header));
    if Items <> nil then Dispose(Items, Done);
    Items := PCollection(F.Get);
    Done;
  end;
end;

procedure TPaperData.Save;
  var F :TDataStream;
      Signature :Array[0..4] of Char;

    Procedure WritePassword;
      var I :Byte;
    begin
      with Descript do
      begin
        for I := 1 to Length(Password) do
        begin
          Password[I] := Upcase(Password[I]);
          if Password[I] in [#1..#254] then Inc(Password[I]);
          if Password[I] = #255 then Password[I] := #1;
        end;
        F.Write(Password, Sizeof(Password));
        for I := 1 to Length(Password) do
        begin
          if Password[I] in [#2..#255] then Dec(Password[I]);
          if Password[I] = #1 then Password[I] := #255;
        end;
      end;{with}
    end;

begin
  with F do
  begin
    Init(FileName^, stCreate);
    Signature := TMFile_Signature;
    Write(Signature, Sizeof(Signature));
    with Descript do
    begin
      Write(Description, Sizeof(Description));
      WritePassword;
      Write(Mask, Sizeof(Mask));
    end;
    Write(Header, Sizeof(Header));
    Put(Items);
    Done;
  end;
  Modified := False;
end;

function TPaperData.GetTruncfileName :String;
begin
  GetTruncFileName := GetfileNameOnly(FileName^);
end;

procedure TPaperData.NotifyofError;
  var B :TBounds;
  const Errs :Array[1..4] of String[38] =
    ('Lˆer is nie ''n Testmaker stel lˆer nie',
     'Ongeldige lˆernaam of toegang geweier',
     'Kon nie vanaf Lˆer Lees nie',
     'Kon nie na Lˆer Skryf nie'
    );

begin
  if Error = TMFile_NoErr then exit;
  B.Assign(125,200,515,300);
  MessageWindow(B, #3+errs[Error], mwfError+mwfOk);
  Error := TMFile_NoErr;
end;

function TPaperData.ValidFileName(Name :String) :Boolean;
  var f :File;
begin
  Assign(F, Name);
  {$I-}
  Reset(F);
  Close(F);
  if IOResult <> 0 then
  begin
    Rewrite(F);
    Close(F);
    Erase(F);
  end;
  {$I+}
  if not(IOResult = 0) then Error := TMFile_InvalidName;
  ValidFileName := Error = TMFile_NoErr;
end;

{***************************************************************************}
{*  THelpFile Objet                                                        *}
{***************************************************************************}
constructor THelpFile.Init;
begin
  inherited Init;
  Assign(Handle, StartUpDir^+HelpFile_Name);
  {$I-}
  Reset(Handle);
  if IOResult <> 0 then Error(HelpFile_IOError);
  {$I+}
end; { THelpFile.Init }

destructor THelpFile.Done;
begin
  {$I-}
  Close(Handle);
  If IOResult <> 0 then Error(HelpFile_DataError);
  {$I+}
  inherited Done;
end; { THelpFile.Done }

procedure THelpFile.Error(Code :Integer);
  var S :String;
      B :TBounds;
begin
  if ErrorVal > HelpFile_Ok then Exit;
  ErrorVal := Code;
  case ErrorVal of
    HelpFile_NotFound  :S := 'Hulplˆer kon nie gevind word nie: Testmake.Hlp.';
    HelpFile_IOError   :S := 'Data lees fout met Hulplˆer: Testmake.Hlp';
    HelpFile_DataError :S := 'Data fout met Hulplˆer: Testmake.Hlp';
    else Exit;
  end;
  S := #3+S;
  B.Assign(125, 200, 515, 300);
  MessageWindow(B, S, mwfError+mwfOk);
end; { THelpFile.Error }

function THelpFile.Readline :String;
  var S :String;
begin
  if ErrorVal > HelpFile_Ok then Exit;
  ReadLine := '';
  {$I-}
  If not Eof(Handle) then
  begin
    Readln(Handle, S);
    if IOResult <> 0 then Error(HelpFile_IOError);
    if Pos('*Ctx:', S) = 1 then
    begin
      ReadLine := '';
      CtxEnd := True;
      Exit;
    end;
  end
  else
  begin
    S := '';
    CtxEnd := True;
  end;
  if IOResult <> 0 then Error(HelpFile_IOError);
  {$I+}
  Readline := S;
end; { THelpFile.Readline }

procedure THelpFile.ScanToCtx(Ctx :Word);
  var S :String;
      ValErr :Integer;
      Num :Integer;
      Found :Boolean;
begin
  if ErrorVal > HelpFile_Ok then Exit;
  {$I-}
  Reset(Handle);
  if IOResult <> 0 then Error(HelpFile_IOError);
  S := '';
  Found := False;
  while not Eof(Handle) Do
  begin
    Readln(Handle, S);
    if IOResult <> 0 then
    begin
      Error(HelpFile_IOError);
      Exit;
    end;
    if Pos('*Ctx:', S) = 1 then
    begin
      Delete(S, 1, Pos('=', S));
      Val(S, Num, ValErr);
      if (ValErr = 0) and (Num = Ctx) then
      begin
        Found := True;
        CtxEnd := False;
        Break;
      end;{if}
    end;{if}
  end;{while}
 if IOResult <> 0 then Error(HelpFile_IOError);
 {$I+}
 if not Found then Error(HelpFile_NoCtx);
end; { THelpFile.ScanToCtx }

procedure THelpFile.ScanToTopic(Topic :String);
  var S :String;
      Found :Boolean;
begin
  if ErrorVal > HelpFile_Ok then Exit;
  {$I-}
  Reset(Handle);
  if IOResult <> 0 then Error(HelpFile_IOError);
  S := '';
  Found := False;
  while not Eof(Handle) Do
  begin
    Readln(Handle, S);
    if IOResult <> 0 then
    begin
      Error(HelpFile_IOError);
      Exit;
    end;
    if Pos('*Ctx:', S) = 1 then
    begin
      Delete(S, 1, 5);
      Delete(S, Pos('=', S), Length(S));
      if S = Topic then
      begin
        Found := True;
        CtxEnd := False;
        Break;
      end;{if}
    end;{if}
  end;{while}
  if IOResult <> 0 then Error(HelpFile_IOError);
 {$I+}
 if not Found then Error(HelpFile_NoCtx);
end; { THelpFile.ScanToTopic }

begin
  RegisterType(RCollection);
end.  { Unit }{****************************************************************************}
{* TestMaker Test Paper Creating Tool                                       *}
{*   Edit by Hannes de Jager 1996 & 1997                                    *}
{* Unit for overlay process                                                 *}
{****************************************************************************}
Unit TMOVRLAY;

Interface

Implementation
  uses Overlay, Crt;

begin
  Clrscr;
  Writeln('Testmaker Weergawe 1.0');
  Writeln('Deur: Hannes de Jager (1997)');
  { Initialize overlay manager }
  OvrInit('TESTMAKE.OVR');
  { Halt on error }
  if OvrResult <> 0 then
  begin
    Writeln('Fout : TESTMAKE.OVR kon nie gelaai word nie !');
    Halt(1);
  end;
  { Try to use EMS }
  OvrInitEms;
  if OvrResult <> 0 then
    Writeln('Ems geheue ondersteuning huidiglik nie beskikbaar.')
  else  Writeln('TESTMAKE.OVR is in Ems geheue gelaai.');
  OvrResult := OvrOk;
end. { Unit }